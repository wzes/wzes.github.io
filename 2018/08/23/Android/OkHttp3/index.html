<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000">
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top">
  
  
  <title>Android OkHttp3 源码解析 | Xuantang Cun 的博客</title>
  <meta name="description" content="总觉得网络这一块不是那么的熟悉，也找不到窍门，索性看一个网络请求框架，来加深自己对网络请求的认识。这个系列应该会很长，毕竟这个库也不简单，里面包含了很多知识，我会先从使用，再到简单 API源码 的分析，再到框架内部各个模块的仔细研读这样一个顺序去分析">
<meta name="keywords" content="Android,Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Android OkHttp3 源码解析">
<meta property="og:url" content="https://wzes.github.io/2018/08/23/Android/OkHttp3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="总觉得网络这一块不是那么的熟悉，也找不到窍门，索性看一个网络请求框架，来加深自己对网络请求的认识。这个系列应该会很长，毕竟这个库也不简单，里面包含了很多知识，我会先从使用，再到简单 API源码 的分析，再到框架内部各个模块的仔细研读这样一个顺序去分析">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-09-02T12:19:12.575Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android OkHttp3 源码解析">
<meta name="twitter:description" content="总觉得网络这一块不是那么的熟悉，也找不到窍门，索性看一个网络请求框架，来加深自己对网络请求的认识。这个系列应该会很长，毕竟这个库也不简单，里面包含了很多知识，我会先从使用，再到简单 API源码 的分析，再到框架内部各个模块的仔细研读这样一个顺序去分析">
  <!-- Canonical links -->
  <link rel="canonical" href="https://wzes.github.io/2018/08/23/Android/OkHttp3/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
  
  
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.css">
  
</head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/wzes" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.png" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">爨</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">美团点评 Android 开发</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> 上海, 中国</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/wzes" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://weibo.com/u/5589559954" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/Xuantang4" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎加入美团点评的大家庭～～内推找18001997427（微信 备注Github）</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">15</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Java/">Java</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SQLite/">SQLite</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Array/">Array</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Babel/">Babel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOM/">DOM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">19</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Koa/">Koa</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lazyload/">Lazyload</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/">Node</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redux/">Redux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLite/">SQLite</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TabLayout/">TabLayout</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Test/">Test</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ViewPager/">ViewPager</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/">Webpack</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Android/" style="font-size: 13.6px;">Android</a> <a href="/tags/Array/" style="font-size: 13px;">Array</a> <a href="/tags/Babel/" style="font-size: 13px;">Babel</a> <a href="/tags/DOM/" style="font-size: 13px;">DOM</a> <a href="/tags/HTML/" style="font-size: 13px;">HTML</a> <a href="/tags/HTTP/" style="font-size: 13.2px;">HTTP</a> <a href="/tags/Java/" style="font-size: 14px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 13.8px;">JavaScript</a> <a href="/tags/Koa/" style="font-size: 13.4px;">Koa</a> <a href="/tags/Lazyload/" style="font-size: 13px;">Lazyload</a> <a href="/tags/MySQL/" style="font-size: 13px;">MySQL</a> <a href="/tags/Node/" style="font-size: 13.4px;">Node</a> <a href="/tags/React/" style="font-size: 13.2px;">React</a> <a href="/tags/Redux/" style="font-size: 13px;">Redux</a> <a href="/tags/SQLite/" style="font-size: 13px;">SQLite</a> <a href="/tags/TabLayout/" style="font-size: 13px;">TabLayout</a> <a href="/tags/Test/" style="font-size: 13px;">Test</a> <a href="/tags/ViewPager/" style="font-size: 13px;">ViewPager</a> <a href="/tags/Webpack/" style="font-size: 13px;">Webpack</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a><span class="archive-list-count">18</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JavaScript/">JavaScript</a>
              </p>
              <p class="item-title">
                <a href="/2019/11/24/JavaScript/Javascript Test/" class="title">Javascript 单元测试</a>
              </p>
              <p class="item-date">
                <time datetime="2019-11-24T11:09:16.000Z" itemprop="datePublished">2019-11-24</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JavaScript/">JavaScript</a>
              </p>
              <p class="item-title">
                <a href="/2019/11/17/JavaScript/koa-ejs/" class="title">Koa-ejs 入门</a>
              </p>
              <p class="item-date">
                <time datetime="2019-11-17T04:56:00.000Z" itemprop="datePublished">2019-11-17</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JavaScript/">JavaScript</a>
              </p>
              <p class="item-title">
                <a href="/2019/11/09/JavaScript/NextJS/" class="title">NextJS 入门指南</a>
              </p>
              <p class="item-date">
                <time datetime="2019-11-09T10:30:16.000Z" itemprop="datePublished">2019-11-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JavaScript/">JavaScript</a>
              </p>
              <p class="item-title">
                <a href="/2019/11/09/JavaScript/Less/" class="title">Less 入门指南</a>
              </p>
              <p class="item-date">
                <time datetime="2019-11-09T10:30:16.000Z" itemprop="datePublished">2019-11-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/JavaScript/">JavaScript</a>
              </p>
              <p class="item-title">
                <a href="/2019/10/26/JavaScript/IntersectionObserverAPI/" class="title">Intersection Obersever API 中文</a>
              </p>
              <p class="item-date">
                <time datetime="2019-10-26T07:30:16.000Z" itemprop="datePublished">2019-10-26</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-Android/OkHttp3" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Android OkHttp3 源码解析
    </h1>
  


      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2018/08/23/Android/OkHttp3/" class="article-date">
	  <time datetime="2018-08-23T11:30:00.000Z" itemprop="datePublished">2018-08-23</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/Java/">Java</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Android/">Android</a>, <a class="article-tag-link" href="/tags/Java/">Java</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2018/08/23/Android/OkHttp3/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 8.8k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 45(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>总觉得网络这一块不是那么的熟悉，也找不到窍门，索性看一个网络请求框架，来加深自己对网络请求的认识。这个系列应该会很长，毕竟这个库也不简单，里面包含了很多知识，我会先从使用，再到简单 API源码 的分析，再到框架内部各个模块的仔细研读这样一个顺序去分析。</p>
<h3 id="okhttp3"><a class="markdownIt-Anchor" href="#okhttp3"></a> <a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp3</a></h3>
<p>这个库可以说是很优秀，使用起来也很简单，关键是，你可以对它进行各种定制，来做到各种各样的功能，在Android 中，Retrofit 底层就是用 OkHttpClient 去实现的。OkHttp 虽然没有浏览器那么强大，但他内部实现了很多请求服务器数据的场景，能处理很多不同的结果，比如常见的 100 101 Continue 301 302 重定向等等，遇到301，则会触发重定向，从Response 里边取出 Location ，然后再封装 Request，重新访问。这些它在内部帮我们直接去实现，里面还有请求的缓存，应该是根据服务端的Cache-Control 来做的，还有 HTTP 的连接复用，它支持 HTTP1.1 HTTP2 也支持 HTTPS，底层分别使用 Socket 和 sslSocket 写的。另外，它提供了同步，异步的请求方式，可以很方便使用者进行调用。说了很多特性，但我目前仅仅是一个抽象，很难说清楚里面的实现，所以就想好好去看一下里面的实现原理，提升一下内功</p>
<h3 id="使用篇"><a class="markdownIt-Anchor" href="#使用篇"></a> 使用篇</h3>
<p>官方的 GET Sample</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import okhttp3.OkHttpClient;</span><br><span class="line">import okhttp3.Request;</span><br><span class="line">import okhttp3.Response;</span><br><span class="line"></span><br><span class="line">public class GetExample &#123;</span><br><span class="line">  // 首先构建一个 OkHttpClient ，当然你也可以使用 Builder 去构建</span><br><span class="line">  OkHttpClient client = new OkHttpClient();</span><br><span class="line"></span><br><span class="line">  String run(String url) throws IOException &#123;</span><br><span class="line">    // 构建一个 Request 默认是 GET 请求</span><br><span class="line">    Request request = new Request.Builder()</span><br><span class="line">        .url(url)</span><br><span class="line">        .build();</span><br><span class="line">    // 同步的方式去执行</span><br><span class="line">    // 返回一个 Response 对象</span><br><span class="line">    try (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">      return response.body().string();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    GetExample example = new GetExample();</span><br><span class="line">    String response = example.run(&quot;https://raw.github.com/square/okhttp/master/README.md&quot;);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>POST Sample</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import okhttp3.MediaType;</span><br><span class="line">import okhttp3.OkHttpClient;</span><br><span class="line">import okhttp3.Request;</span><br><span class="line">import okhttp3.RequestBody;</span><br><span class="line">import okhttp3.Response;</span><br><span class="line"></span><br><span class="line">public class PostExample &#123;</span><br><span class="line">  public static final MediaType JSON = MediaType.get(&quot;application/json; charset=utf-8&quot;);</span><br><span class="line"></span><br><span class="line">  OkHttpClient client = new OkHttpClient();</span><br><span class="line"></span><br><span class="line">  // 在构建一个 Request 的时候，提交一个 body</span><br><span class="line">  // 通过 RequestBody.create() 来创建一个 Json 格式的 body</span><br><span class="line">  String post(String url, String json) throws IOException &#123;</span><br><span class="line">    RequestBody body = RequestBody.create(JSON, json);</span><br><span class="line">    Request request = new Request.Builder()</span><br><span class="line">        .url(url)</span><br><span class="line">        .post(body)</span><br><span class="line">        .build();</span><br><span class="line">    // 一个小小的API，会在请求结束后调用</span><br><span class="line">    client.dispatcher().setIdleCallback(new Runnable() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Request is Over&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    try (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">      return response.body().string();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String bowlingJson(String player1, String player2) &#123;</span><br><span class="line">    return &quot;&#123;&apos;winCondition&apos;:&apos;HIGH_SCORE&apos;,&quot;</span><br><span class="line">        + &quot;&apos;name&apos;:&apos;Bowling&apos;,&quot;</span><br><span class="line">        + &quot;&apos;round&apos;:4,&quot;</span><br><span class="line">        + &quot;&apos;lastSaved&apos;:1367702411696,&quot;</span><br><span class="line">        + &quot;&apos;dateStarted&apos;:1367702378785,&quot;</span><br><span class="line">        + &quot;&apos;players&apos;:[&quot;</span><br><span class="line">        + &quot;&#123;&apos;name&apos;:&apos;&quot; + player1 + &quot;&apos;,&apos;history&apos;:[10,8,6,7,8],&apos;color&apos;:-13388315,&apos;total&apos;:39&#125;,&quot;</span><br><span class="line">        + &quot;&#123;&apos;name&apos;:&apos;&quot; + player2 + &quot;&apos;,&apos;history&apos;:[6,10,5,10,10],&apos;color&apos;:-48060,&apos;total&apos;:41&#125;&quot;</span><br><span class="line">        + &quot;]&#125;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    PostExample example = new PostExample();</span><br><span class="line">    String json = example.bowlingJson(&quot;Jesse&quot;, &quot;Jake&quot;);</span><br><span class="line">    String response = example.post(&quot;http://www.roundsapp.com/post&quot;, json);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，GET，POST 还是挺简单的，为了满足好奇心，我们看一个方法的源码，OkHttpClient 的 newCall 方法，类似工厂的方法，构建一个 RealCall 的，然后调用 RealCall 的 execute 方法执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Override public Call newCall(Request request) &#123;</span><br><span class="line">  return RealCall.newRealCall(this, request, false /* for web socket */);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override public Response execute() throws IOException &#123;</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</span><br><span class="line">    executed = true;</span><br><span class="line">  &#125;</span><br><span class="line">  captureCallStackTrace();</span><br><span class="line">  eventListener.callStart(this);</span><br><span class="line">  try &#123;</span><br><span class="line">    // 只是放入同步队列</span><br><span class="line">    client.dispatcher().executed(this);</span><br><span class="line">    // 真正的网络调用在这个地方</span><br><span class="line">    Response result = getResponseWithInterceptorChain();</span><br><span class="line">    if (result == null) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">    return result;</span><br><span class="line">  &#125; catch (IOException e) &#123;</span><br><span class="line">    eventListener.callFailed(this, e);</span><br><span class="line">    throw e;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    // 结束那个任务</span><br><span class="line">    client.dispatcher().finished(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从队列里面移除一个 call</span><br><span class="line">private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123;</span><br><span class="line">  int runningCallsCount;</span><br><span class="line">  Runnable idleCallback;</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">    // 移除</span><br><span class="line">    if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;);</span><br><span class="line">    // 触发任务</span><br><span class="line">    if (promoteCalls) promoteCalls();</span><br><span class="line">    runningCallsCount = runningCallsCount();</span><br><span class="line">    idleCallback = this.idleCallback;</span><br><span class="line">  &#125;</span><br><span class="line">  // dispatcher 的api，通过 client 获取然后设置</span><br><span class="line">  if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123;</span><br><span class="line">    idleCallback.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下集预告，OkHttp 的核心，请求链都是在这个这个方法里，调用是从上往下，又从下传到最上，如果到了 CallServerInterceptor，它把数据发到服务端，然后获取结果，再返回给上层处理</p>
<ul>
<li>RetryAndFollowUpInterceptor</li>
<li>BridgeInterceptor</li>
<li>CacheInterceptor</li>
<li>ConnectInterceptor</li>
<li>CallServerInterceptor</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">  // Build a full stack of interceptors.</span><br><span class="line">  List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">  interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">  if (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">  Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</span><br><span class="line">      originalRequest, this, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">  return chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3>
<p>我们大致知道了流程，就是先创建一个 OkHttpClient，然后再创建一个 Request，然后再调用 newCall 执行，暂时我们看了同步的方式</p>
<h3 id="前言-2"><a class="markdownIt-Anchor" href="#前言-2"></a> 前言</h3>
<p>之前我们掌握了 OkHttpClient 的基本使用，在最后面我们抛出了很多 Interceptor，现在我们看一下 Interceptor 到底是什么东西，英文是拦截器的意思，当我看了源码后，我觉得我更容易理解的是，处理器</p>
<h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3>
<p>如果定义自己的 interceptor，要实现 intercept，里面有一个内部类 Chain ，链</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public interface Interceptor &#123;</span><br><span class="line">  Response intercept(Chain chain) throws IOException;</span><br><span class="line"></span><br><span class="line">  interface Chain &#123;</span><br><span class="line">    Request request();</span><br><span class="line"></span><br><span class="line">    Response proceed(Request request) throws IOException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the connection the request will be executed on. This is only available in the chains</span><br><span class="line">     * of network interceptors; for application interceptors this is always null.</span><br><span class="line">     */</span><br><span class="line">    @Nullable Connection connection();</span><br><span class="line"></span><br><span class="line">    Call call();</span><br><span class="line"></span><br><span class="line">    int connectTimeoutMillis();</span><br><span class="line"></span><br><span class="line">    Chain withConnectTimeout(int timeout, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">    int readTimeoutMillis();</span><br><span class="line"></span><br><span class="line">    Chain withReadTimeout(int timeout, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">    int writeTimeoutMillis();</span><br><span class="line"></span><br><span class="line">    Chain withWriteTimeout(int timeout, TimeUnit unit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看一下这个函数，如果我们没有自定义的 interceptor，最先的是RetryAndFollowUpInterceptor，他是一个 重试和重定向的拦截器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">  // Build a full stack of interceptors.</span><br><span class="line">  List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">  interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">  if (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">  Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,</span><br><span class="line">      originalRequest, this, eventListener, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">  return chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看一下 RealInterceptorChain， 他实现了 Interceptor.Chain</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">public final class RealInterceptorChain implements Interceptor.Chain &#123;</span><br><span class="line">  private final List&lt;Interceptor&gt; interceptors;</span><br><span class="line">  private final StreamAllocation streamAllocation;</span><br><span class="line">  private final HttpCodec httpCodec;</span><br><span class="line">  private final RealConnection connection;</span><br><span class="line">  private final int index;</span><br><span class="line">  private final Request request;</span><br><span class="line">  private final Call call;</span><br><span class="line">  private final EventListener eventListener;</span><br><span class="line">  private final int connectTimeout;</span><br><span class="line">  private final int readTimeout;</span><br><span class="line">  private final int writeTimeout;</span><br><span class="line">  private int calls;</span><br><span class="line"></span><br><span class="line">  public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,</span><br><span class="line">      HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call,</span><br><span class="line">      EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) &#123;</span><br><span class="line">    this.interceptors = interceptors;</span><br><span class="line">    this.connection = connection;</span><br><span class="line">    this.streamAllocation = streamAllocation;</span><br><span class="line">    this.httpCodec = httpCodec;</span><br><span class="line">    this.index = index;</span><br><span class="line">    this.request = request;</span><br><span class="line">    this.call = call;</span><br><span class="line">    this.eventListener = eventListener;</span><br><span class="line">    this.connectTimeout = connectTimeout;</span><br><span class="line">    this.readTimeout = readTimeout;</span><br><span class="line">    this.writeTimeout = writeTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Connection connection() &#123;</span><br><span class="line">    return connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public int connectTimeoutMillis() &#123;</span><br><span class="line">    return connectTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) &#123;</span><br><span class="line">    int millis = checkDuration(&quot;timeout&quot;, timeout, unit);</span><br><span class="line">    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">        request, call, eventListener, millis, readTimeout, writeTimeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public int readTimeoutMillis() &#123;</span><br><span class="line">    return readTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) &#123;</span><br><span class="line">    int millis = checkDuration(&quot;timeout&quot;, timeout, unit);</span><br><span class="line">    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">        request, call, eventListener, connectTimeout, millis, writeTimeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public int writeTimeoutMillis() &#123;</span><br><span class="line">    return writeTimeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) &#123;</span><br><span class="line">    int millis = checkDuration(&quot;timeout&quot;, timeout, unit);</span><br><span class="line">    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,</span><br><span class="line">        request, call, eventListener, connectTimeout, readTimeout, millis);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StreamAllocation streamAllocation() &#123;</span><br><span class="line">    return streamAllocation;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HttpCodec httpStream() &#123;</span><br><span class="line">    return httpCodec;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Call call() &#123;</span><br><span class="line">    return call;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public EventListener eventListener() &#123;</span><br><span class="line">    return eventListener;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Request request() &#123;</span><br><span class="line">    return request;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Response proceed(Request request) throws IOException &#123;</span><br><span class="line">    return proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">      RealConnection connection) throws IOException &#123;</span><br><span class="line">    if (index &gt;= interceptors.size()) throw new AssertionError();</span><br><span class="line"></span><br><span class="line">    calls++;</span><br><span class="line"></span><br><span class="line">    // If we already have a stream, confirm that the incoming request will use it.</span><br><span class="line">    if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</span><br><span class="line">          + &quot; must retain the same host and port&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If we already have a stream, confirm that this is the only call to chain.proceed().</span><br><span class="line">    if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</span><br><span class="line">          + &quot; must call proceed() exactly once&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call the next interceptor in the chain.</span><br><span class="line">    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout);</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">    // Confirm that the next interceptor made its required call to chain.proceed().</span><br><span class="line">    if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptor</span><br><span class="line">          + &quot; must call proceed() exactly once&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Confirm that the intercepted response isn&apos;t null.</span><br><span class="line">    if (response == null) &#123;</span><br><span class="line">      throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (response.body() == null) &#123;</span><br><span class="line">      throw new IllegalStateException(</span><br><span class="line">          &quot;interceptor &quot; + interceptor + &quot; returned a response with no body&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我把最关键的代码贴出来，Interceptors 获取实例Interceptor，比如第一个的话，是RetryAndFollowUpInterceptor，然后执行 intercept方法，将下一个RealInterceptorChain 传进去，所以其实这里是一个递归，会不断调用，知道最后一层返回 Response</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Call the next interceptor in the chain.</span><br><span class="line">RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">    connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class="line">    writeTimeout);</span><br><span class="line">Interceptor interceptor = interceptors.get(index);</span><br><span class="line">// </span><br><span class="line">Response response = interceptor.intercept(next);</span><br></pre></td></tr></table></figure>
<p>RetryAndFollowUpInterceptor 实现机制，里面有个重要的东西，重定向次数，最大为20，还有 OkHttpClient 的实例，还有一个volatile 的 canceled ，标记是否取消，还有 forWebSocket，这个等到用到了再解释，StreamAllocation也是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final class RetryAndFollowUpInterceptor implements Interceptor &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,</span><br><span class="line"> * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.</span><br><span class="line"> */</span><br><span class="line">private static final int MAX_FOLLOW_UPS = 20;</span><br><span class="line"></span><br><span class="line">private final OkHttpClient client;</span><br><span class="line">private final boolean forWebSocket;</span><br><span class="line">private volatile StreamAllocation streamAllocation;</span><br><span class="line">private Object callStackTrace;</span><br><span class="line">private volatile boolean canceled;</span><br></pre></td></tr></table></figure>
<p>我们看一下他的 intercept 方法，第一个 interceptor 是RetryAndFollowUpInterceptor，Chain 包含了当前是第几个拦截器的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Call call = realChain.call();</span><br><span class="line">    EventListener eventListener = realChain.eventListener();</span><br><span class="line">    // 构建一个 StreamAllocation对象</span><br><span class="line">    // client连接池，Address 地址，call对象，监听对象</span><br><span class="line">    StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),</span><br><span class="line">        createAddress(request.url()), call, eventListener, callStackTrace);</span><br><span class="line">    this.streamAllocation = streamAllocation;</span><br><span class="line">    // 初始化跟踪次数</span><br><span class="line">    int followUpCount = 0;</span><br><span class="line">    Response priorResponse = null;</span><br><span class="line">    // 循环，为了处理重定向，失败重试的问题</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      // 每一次首先判断是否取消</span><br><span class="line">      if (canceled) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      //</span><br><span class="line">      Response response;</span><br><span class="line">      boolean releaseConnection = true;</span><br><span class="line">      try &#123;</span><br><span class="line">        // 调用 Chain 对象的 proceed，这里最后也</span><br><span class="line">        // 会进到下一个 Interceptor 的 intercept</span><br><span class="line">        response = realChain.proceed(request, streamAllocation, null, null);</span><br><span class="line">        releaseConnection = false;</span><br><span class="line">      &#125; catch (RouteException e) &#123;</span><br><span class="line">        // The attempt to connect via a route failed. The request will not have been sent.</span><br><span class="line">        if (!recover(e.getLastConnectException(), streamAllocation, false, request)) &#123;</span><br><span class="line">          throw e.getFirstConnectException();</span><br><span class="line">        &#125;</span><br><span class="line">        releaseConnection = false;</span><br><span class="line">        continue;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        // An attempt to communicate with a server failed. The request may have been sent.</span><br><span class="line">        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);</span><br><span class="line">        if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;</span><br><span class="line">        releaseConnection = false;</span><br><span class="line">        continue;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        // We&apos;re throwing an unchecked exception. Release any resources.</span><br><span class="line">        if (releaseConnection) &#123;</span><br><span class="line">          streamAllocation.streamFailed(null);</span><br><span class="line">          streamAllocation.release();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Attach the prior response if it exists. Such responses never have a body.</span><br><span class="line">      if (priorResponse != null) &#123;</span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                    .body(null)</span><br><span class="line">                    .build())</span><br><span class="line">            .build();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // 检查是否出现需要重试，比如重定向，服务器问题</span><br><span class="line">      Request followUp;</span><br><span class="line">      try &#123;</span><br><span class="line">        followUp = followUpRequest(response, streamAllocation.route());</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        throw e;</span><br><span class="line">      &#125;</span><br><span class="line">      // 无重试，直接返回结果</span><br><span class="line">      if (followUp == null) &#123;</span><br><span class="line">        if (!forWebSocket) &#123;</span><br><span class="line">          streamAllocation.release();</span><br><span class="line">        &#125;</span><br><span class="line">        return response;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      closeQuietly(response.body());</span><br><span class="line">      // 检查重试次数，超出的话抛出异常</span><br><span class="line">      if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (followUp.body() instanceof UnrepeatableRequestBody) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());</span><br><span class="line">      &#125;</span><br><span class="line">      // 不是同一个连接</span><br><span class="line">      if (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        streamAllocation = new StreamAllocation(client.connectionPool(),</span><br><span class="line">            createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class="line">        this.streamAllocation = streamAllocation;</span><br><span class="line">      &#125; else if (streamAllocation.codec() != null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Closing the body of &quot; + response</span><br><span class="line">            + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      request = followUp;</span><br><span class="line">      priorResponse = response;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>判断是否需要跟踪的代码，可以好好补一补状态码了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">private Request followUpRequest(Response userResponse, Route route) throws IOException &#123;</span><br><span class="line">  if (userResponse == null) throw new IllegalStateException();</span><br><span class="line">  int responseCode = userResponse.code();</span><br><span class="line"></span><br><span class="line">  final String method = userResponse.request().method();</span><br><span class="line">  switch (responseCode) &#123;</span><br><span class="line">    // 407 代理服务器需要认证</span><br><span class="line">    case HTTP_PROXY_AUTH:</span><br><span class="line">      Proxy selectedProxy = route != null</span><br><span class="line">          ? route.proxy()</span><br><span class="line">          : client.proxy();</span><br><span class="line">      if (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">        throw new ProtocolException(&quot;Received HTTP_PROXY_AUTH (407) code while not using proxy&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return client.proxyAuthenticator().authenticate(route, userResponse);</span><br><span class="line">    // 401 未授权，根据Header Authenticate 进行授权</span><br><span class="line">    case HTTP_UNAUTHORIZED:</span><br><span class="line">      return client.authenticator().authenticate(route, userResponse);</span><br><span class="line">    // 如果是非GET，HEAD，则不管，注意 307,308 和 301 302 的区别</span><br><span class="line">    // 308</span><br><span class="line">    case HTTP_PERM_REDIRECT:</span><br><span class="line">    // 307</span><br><span class="line">    case HTTP_TEMP_REDIRECT:</span><br><span class="line">      // &quot;If the 307 or 308 status code is received in response to a request other than GET</span><br><span class="line">      // or HEAD, the user agent MUST NOT automatically redirect the request&quot;</span><br><span class="line">      if (!method.equals(&quot;GET&quot;) &amp;&amp; !method.equals(&quot;HEAD&quot;)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      // fall-through</span><br><span class="line">    // 根据Location 重定向，构建一条新的 Request</span><br><span class="line">    // 300</span><br><span class="line">    case HTTP_MULT_CHOICE:</span><br><span class="line">    // 301</span><br><span class="line">    case HTTP_MOVED_PERM:</span><br><span class="line">    // 302</span><br><span class="line">    case HTTP_MOVED_TEMP:</span><br><span class="line">    // 303</span><br><span class="line">    case HTTP_SEE_OTHER:</span><br><span class="line">      // Does the client allow redirects?</span><br><span class="line">      if (!client.followRedirects()) return null;</span><br><span class="line"></span><br><span class="line">      String location = userResponse.header(&quot;Location&quot;);</span><br><span class="line">      if (location == null) return null;</span><br><span class="line">      HttpUrl url = userResponse.request().url().resolve(location);</span><br><span class="line"></span><br><span class="line">      // Don&apos;t follow redirects to unsupported protocols.</span><br><span class="line">      if (url == null) return null;</span><br><span class="line"></span><br><span class="line">      // If configured, don&apos;t follow redirects between SSL and non-SSL.</span><br><span class="line">      boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());</span><br><span class="line">      if (!sameScheme &amp;&amp; !client.followSslRedirects()) return null;</span><br><span class="line"></span><br><span class="line">      // Most redirects don&apos;t include a request body.</span><br><span class="line">      Request.Builder requestBuilder = userResponse.request().newBuilder();</span><br><span class="line">      if (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">        final boolean maintainBody = HttpMethod.redirectsWithBody(method);</span><br><span class="line">        if (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">          requestBuilder.method(&quot;GET&quot;, null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          RequestBody requestBody = maintainBody ? userResponse.request().body() : null;</span><br><span class="line">          requestBuilder.method(method, requestBody);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!maintainBody) &#123;</span><br><span class="line">          requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">          requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">          requestBuilder.removeHeader(&quot;Content-Type&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // When redirecting across hosts, drop all authentication headers. This</span><br><span class="line">      // is potentially annoying to the application layer since they have no</span><br><span class="line">      // way to retain them.</span><br><span class="line">      if (!sameConnection(userResponse, url)) &#123;</span><br><span class="line">        requestBuilder.removeHeader(&quot;Authorization&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return requestBuilder.url(url).build();</span><br><span class="line">    // 408 客户端连接超时</span><br><span class="line">    case HTTP_CLIENT_TIMEOUT:</span><br><span class="line">      // 408&apos;s are rare in practice, but some servers like HAProxy use this response code. The</span><br><span class="line">      // spec says that we may repeat the request without modifications. Modern browsers also</span><br><span class="line">      // repeat the request (even non-idempotent ones.)</span><br><span class="line">      if (!client.retryOnConnectionFailure()) &#123;</span><br><span class="line">        // The application layer has directed us not to retry the request.</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (userResponse.request().body() instanceof UnrepeatableRequestBody) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      if (userResponse.priorResponse() != null</span><br><span class="line">          &amp;&amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) &#123;</span><br><span class="line">        // We attempted to retry and got another timeout. Give up.</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      // 尝试重试</span><br><span class="line">      if (retryAfter(userResponse, 0) &gt; 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return userResponse.request();</span><br><span class="line">    // 503</span><br><span class="line">    case HTTP_UNAVAILABLE:</span><br><span class="line">      if (userResponse.priorResponse() != null</span><br><span class="line">          &amp;&amp; userResponse.priorResponse().code() == HTTP_UNAVAILABLE) &#123;</span><br><span class="line">        // We attempted to retry and got another timeout. Give up.</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) &#123;</span><br><span class="line">        // specifically received an instruction to retry without delay</span><br><span class="line">        return userResponse.request();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return null;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析重试的时间，在客户端请求超时，服务器负载过高造成的都有可能进行重试，这时候会根据服务器给的 retry-after 属性进行重试，默认的重试时间为0，立刻重试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private int retryAfter(Response userResponse, int defaultDelay) &#123;</span><br><span class="line">  String header = userResponse.header(&quot;Retry-After&quot;);</span><br><span class="line"></span><br><span class="line">  if (header == null) &#123;</span><br><span class="line">    return defaultDelay;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // https://tools.ietf.org/html/rfc7231#section-7.1.3</span><br><span class="line">  // currently ignores a HTTP-date, and assumes any non int 0 is a delay</span><br><span class="line">  if (header.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">    return Integer.valueOf(header);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断是否是同一个连接的方法，比较host 和 port，以及scheme（http 或 https），至于为什么要这样写，我们在之后会看到原理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns true if an HTTP request for &#123;@code followUp&#125; can reuse the connection used by this</span><br><span class="line"> * engine.</span><br><span class="line"> */</span><br><span class="line">private boolean sameConnection(Response response, HttpUrl followUp) &#123;</span><br><span class="line">  HttpUrl url = response.request().url();</span><br><span class="line">  return url.host().equals(followUp.host())</span><br><span class="line">      &amp;&amp; url.port() == followUp.port()</span><br><span class="line">      &amp;&amp; url.scheme().equals(followUp.scheme());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理类型，三种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public enum Type &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Represents a direct connection, or the absence of a proxy.</span><br><span class="line">     */</span><br><span class="line">    DIRECT,</span><br><span class="line">    /**</span><br><span class="line">     * Represents proxy for high level protocols such as HTTP or FTP.</span><br><span class="line">     */</span><br><span class="line">    HTTP,</span><br><span class="line">    /**</span><br><span class="line">     * Represents a SOCKS (V4 or V5) proxy.</span><br><span class="line">     */</span><br><span class="line">    SOCKS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="小结-2"><a class="markdownIt-Anchor" href="#小结-2"></a> 小结</h3>
<p>我们详细的看了这个 RetryAndFollowUpInterceptor，可能你现在还不是很清晰，但相信之后看了其他的一些Interceptor，你就会十分了解这个东西</p>
<h3 id="前言-3"><a class="markdownIt-Anchor" href="#前言-3"></a> 前言</h3>
<p>之前我们学习了 OkHttp3 的使用以及 RetryAndFollowUpInterceptor 的源码，至今还记忆尤新，今天我给大家带来一个 BridgeInterceptor，这个东西也很重要，那它到底是个什么东西呢？</p>
<h3 id="是什么东西"><a class="markdownIt-Anchor" href="#是什么东西"></a> 是什么东西</h3>
<p>Bridge，桥接，是不是说起着承上启下的作用，的确如此，原文是这么说的</p>
<blockquote>
<p>Bridges from application code to network code. First it builds a network request from a user request. Then it proceeds to call the network. Finally it builds a user response from the network response</p>
</blockquote>
<p>翻译过来，就是说将请求或者响应在应用层和网络层相互转化</p>
<h3 id="源码"><a class="markdownIt-Anchor" href="#源码"></a> 源码</h3>
<p>里面的 Intercept 方法，首先，获取到用过刚开始构建的 request 对象，因为用户仅仅配置了几个简单的属性，比如 url，method等，但这远远不够，我们传给服务器的数据不仅仅如此，如果看过 http 协议，我们应该比较了解明文模式下的数据格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">  Request userRequest = chain.request();</span><br><span class="line">  Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">  RequestBody body = userRequest.body();</span><br><span class="line">  if (body != null) &#123;</span><br><span class="line">    MediaType contentType = body.contentType();</span><br><span class="line">    if (contentType != null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果body 的长度为 -1 那么将使用</span><br><span class="line">    // Transfer-Encoding 设置为 chunked </span><br><span class="line">    // 意思是分块传输</span><br><span class="line">    long contentLength = body.contentLength();</span><br><span class="line">    if (contentLength != -1) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));</span><br><span class="line">      requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);</span><br><span class="line">      requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>给 request 添加 Host，以及Connection 为 Keep-Alive，以及使用 Accept-Encoding 为 gzip</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (userRequest.header(&quot;Host&quot;) == null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Connection&quot;) == null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also decompressing</span><br><span class="line">    // the transfer stream.</span><br><span class="line">    boolean transparentGzip = false;</span><br><span class="line">    if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123;</span><br><span class="line">      transparentGzip = true;</span><br><span class="line">      requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>封装Cookie，以及User-Agent 为 okhttp<br>
关于 Cookie 的格式如下，其中 Name = Value 必须要有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: Name = Value; Comment = value; Domain = value; Max-Age = value; Path = Value;Secure; Version = 1 * DIGIT;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">   if (!cookies.isEmpty()) &#123;</span><br><span class="line">     requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (userRequest.header(&quot;User-Agent&quot;) == null) &#123;</span><br><span class="line">     requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final class Version &#123;</span><br><span class="line">     public static String userAgent() &#123;</span><br><span class="line">       return &quot;okhttp/3.11.0&quot;;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     private Version() &#123;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>之后就是转发给下一个 Interceptor 了，在拿到数据以后，处理一下 cookie 的数据，具体就是更新Cookie，之后就是处理数据了，如果服务端使用了gzip，我们就需要解压，在构建 response，之后再返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">    .request(userRequest);</span><br><span class="line"></span><br><span class="line">if (transparentGzip</span><br><span class="line">    &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))</span><br><span class="line">    &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">  GzipSource responseBody = new GzipSource(networkResponse.body().source());</span><br><span class="line">  Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">      .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">      .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">      .build();</span><br><span class="line">  responseBuilder.headers(strippedHeaders);</span><br><span class="line">  String contentType = networkResponse.header(&quot;Content-Type&quot;);</span><br><span class="line">  responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>差不多到这就完了</p>
<h3 id="小结-3"><a class="markdownIt-Anchor" href="#小结-3"></a> 小结</h3>
<p>今天的bridgeInterceptor主要做的工作便是封装 request 和 处理 response 这个东西，中间我们学习了 content-encoding accept-encoding 等属性，另外详细的了解了cookie，终于搞明白了这东西的格式，收获不小</p>
<p>欢迎讨论</p>
<h3 id="前言-4"><a class="markdownIt-Anchor" href="#前言-4"></a> 前言</h3>
<p>桥接 Interceptor 之后就是缓存 Interceptor 了，缓存在浏览器中运用十分广泛，如果在加载网页时使用了缓存，主要是二次加载，那么一些不变的内容就可以不用去重新请求，这样数据就不用来回传送，性能便有所提高，通常我们遇到的 304 响应码便是缓存的象征，关于缓存还需要掌握很多请求头的知识，比如ETag，If-None-Match，If-Modified-Since，Last-Modified-Time 等等，这些属性是客户端，服务端缓存消息交互的关键。因此我们要学习缓存的话，这些知识必不可少。</p>
<h3 id="是什么东西-2"><a class="markdownIt-Anchor" href="#是什么东西-2"></a> 是什么东西？</h3>
<p>用于处理客户端的缓存，缓存的内容实在客户端的，但通常与服务器是脱不了关系的，这里我们需要明白的是，关于网络缓存有很多很多中，可以在很多地方做缓存，而这里是在客户端做缓存。</p>
<h3 id="源码学习"><a class="markdownIt-Anchor" href="#源码学习"></a> 源码学习</h3>
<p>缓存的内核，所有的数据存取都与这家伙有关，内部是使用 Cache，如果我们需要使用缓存，那需要我们自己配置，默认是没有本地缓存的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final InternalCache cache;</span><br><span class="line"></span><br><span class="line">public final class Cache implements Closeable, Flushable &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数，我们可以看到，内部使用了 DiskLruCache，如果不了解 DiskLruCache的同学，可以参考我的另外一篇文章 <a href="https://www.jianshu.com/p/6ed80c0d91ee" target="_blank" rel="noopener">DiskLruCache 源码解析</a> ，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final DiskLruCache cache;</span><br><span class="line"></span><br><span class="line">/* read and write statistics, all guarded by &apos;this&apos; */</span><br><span class="line">int writeSuccessCount;</span><br><span class="line">int writeAbortCount;</span><br><span class="line">private int networkCount;</span><br><span class="line">private int hitCount;</span><br><span class="line">private int requestCount;</span><br><span class="line"></span><br><span class="line">public Cache(File directory, long maxSize) &#123;</span><br><span class="line">  this(directory, maxSize, FileSystem.SYSTEM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cache(File directory, long maxSize, FileSystem fileSystem) &#123;</span><br><span class="line">  this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来看看如何缓存放进去，当然，能缓存的请求类型只有 GET，HEAD，即首先判断 Response 类型，眼看这里代码写得好烂，估计作者可能睡着了，有空去 PR，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Nullable CacheRequest put(Response response) &#123;</span><br><span class="line">  String requestMethod = response.request().method();</span><br><span class="line"></span><br><span class="line">  if (HttpMethod.invalidatesCache(response.request().method())) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      remove(response.request());</span><br><span class="line">    &#125; catch (IOException ignored) &#123;</span><br><span class="line">      // The cache cannot be written.</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!requestMethod.equals(&quot;GET&quot;)) &#123;</span><br><span class="line">    // Don&apos;t cache non-GET responses. We&apos;re technically allowed to cache</span><br><span class="line">    // HEAD requests and some POST requests, but the complexity of doing</span><br><span class="line">    // so is high and the benefit is low.</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (HttpHeaders.hasVaryAll(response)) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Entry entry = new Entry(response);</span><br><span class="line">  DiskLruCache.Editor editor = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    editor = cache.edit(key(response.request().url()));</span><br><span class="line">    if (editor == null) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    entry.writeTo(editor);</span><br><span class="line">    return new CacheRequestImpl(editor);</span><br><span class="line">  &#125; catch (IOException e) &#123;</span><br><span class="line">    abortQuietly(editor);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 url 的 md5 值的16进制来获取key，为什么要这么做呢？别想了，就这样吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String key(HttpUrl url) &#123;</span><br><span class="line">    return ByteString.encodeUtf8(url.toString()).md5().hex();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>验证请求能否缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static boolean invalidatesCache(String method) &#123;</span><br><span class="line">  return method.equals(&quot;POST&quot;)</span><br><span class="line">      || method.equals(&quot;PATCH&quot;)</span><br><span class="line">      || method.equals(&quot;PUT&quot;)</span><br><span class="line">      || method.equals(&quot;DELETE&quot;)</span><br><span class="line">      || method.equals(&quot;MOVE&quot;);     // WebDAV</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码是获取缓存的代码，同样先获取 key，然后获取缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Nullable Response get(Request request) &#123;</span><br><span class="line">  String key = key(request.url());</span><br><span class="line">  DiskLruCache.Snapshot snapshot;</span><br><span class="line">  Entry entry;</span><br><span class="line">  try &#123;</span><br><span class="line">    snapshot = cache.get(key);</span><br><span class="line">    if (snapshot == null) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (IOException e) &#123;</span><br><span class="line">    // Give up because the cache cannot be read.</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    entry = new Entry(snapshot.getSource(ENTRY_METADATA));</span><br><span class="line">  &#125; catch (IOException e) &#123;</span><br><span class="line">    Util.closeQuietly(snapshot);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response response = entry.response(snapshot);</span><br><span class="line"></span><br><span class="line">  if (!entry.matches(request, response)) &#123;</span><br><span class="line">    Util.closeQuietly(response.body());</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在回过头来看，这里将获取一个 CacheStrategy，通常，cacheResponse 为空，所以这一步几乎没有任何缓存，只是封装了一下 request</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public CacheStrategy get() &#123;</span><br><span class="line">  CacheStrategy candidate = getCandidate();</span><br><span class="line"></span><br><span class="line">  if (candidate.networkRequest != null &amp;&amp; request.cacheControl().onlyIfCached()) &#123;</span><br><span class="line">    // We&apos;re forbidden from using the network and the cache is insufficient.</span><br><span class="line">    return new CacheStrategy(null, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return candidate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private CacheStrategy getCandidate() &#123;</span><br><span class="line">  // No cached response.</span><br><span class="line">  if (cacheResponse == null) &#123;</span><br><span class="line">    return new CacheStrategy(request, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Drop the cached response if it&apos;s missing a required handshake.</span><br><span class="line">  if (request.isHttps() &amp;&amp; cacheResponse.handshake() == null) &#123;</span><br><span class="line">    return new CacheStrategy(request, null);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>比较重要的逻辑，大致的思路为：首先检查缓存，如果存在，则根据缓存封装一个Request，带上 ETag，If-Modify-Since 标签，访问服务器，否则直接访问服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">  Response cacheCandidate = cache != null</span><br><span class="line">      ? cache.get(chain.request())</span><br><span class="line">      : null;</span><br><span class="line"></span><br><span class="line">  long now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">  CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">  Request networkRequest = strategy.networkRequest;</span><br><span class="line">  Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">  if (cache != null) &#123;</span><br><span class="line">    cache.trackResponse(strategy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">    closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // If we&apos;re forbidden from using the network and the cache is insufficient, fail.</span><br><span class="line">  if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">    return new Response.Builder()</span><br><span class="line">        .request(chain.request())</span><br><span class="line">        .protocol(Protocol.HTTP_1_1)</span><br><span class="line">        .code(504)</span><br><span class="line">        .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">        .body(Util.EMPTY_RESPONSE)</span><br><span class="line">        .sentRequestAtMillis(-1L)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // If we don&apos;t need the network, we&apos;re done.</span><br><span class="line">  if (networkRequest == null) &#123;</span><br><span class="line">    return cacheResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response networkResponse = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    networkResponse = chain.proceed(networkRequest);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body.</span><br><span class="line">    if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>访问完以后，如果是304返回码，说明可以从缓存中拿数据，那我们就可以从缓存中拿数据，构建一个新的 Response 就行了<br>
另一个操作就是，存储数据，即根据服务端的返回码把可以缓存的数据保存在 Cache 里，主要是根据 Cache-control Pragma ，只要能缓存，尽量缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> // If we have a cache response too, then we&apos;re doing a conditional get.</span><br><span class="line">  if (cacheResponse != null) &#123;</span><br><span class="line">    if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">      Response response = cacheResponse.newBuilder()</span><br><span class="line">          .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">          .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .networkResponse(stripBody(networkResponse))</span><br><span class="line">          .build();</span><br><span class="line">      networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">      // Update the cache after combining headers but before stripping the</span><br><span class="line">      // Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">      cache.trackConditionalCacheHit();</span><br><span class="line">      cache.update(cacheResponse, response);</span><br><span class="line">      return response;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      closeQuietly(cacheResponse.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response response = networkResponse.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .networkResponse(stripBody(networkResponse))</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  if (cache != null) &#123;</span><br><span class="line">    if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">      // Offer this request to the cache.</span><br><span class="line">      CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">      return cacheWritingResponse(cacheRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cache.remove(networkRequest);</span><br><span class="line">      &#125; catch (IOException ignored) &#123;</span><br><span class="line">        // The cache cannot be written.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以欣赏一下这个方法，可以加深我们对缓存的认识</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">public static CacheControl parse(Headers headers) &#123;</span><br><span class="line">    boolean noCache = false;</span><br><span class="line">    boolean noStore = false;</span><br><span class="line">    int maxAgeSeconds = -1;</span><br><span class="line">    int sMaxAgeSeconds = -1;</span><br><span class="line">    boolean isPrivate = false;</span><br><span class="line">    boolean isPublic = false;</span><br><span class="line">    boolean mustRevalidate = false;</span><br><span class="line">    int maxStaleSeconds = -1;</span><br><span class="line">    int minFreshSeconds = -1;</span><br><span class="line">    boolean onlyIfCached = false;</span><br><span class="line">    boolean noTransform = false;</span><br><span class="line">    boolean immutable = false;</span><br><span class="line"></span><br><span class="line">    boolean canUseHeaderValue = true;</span><br><span class="line">    String headerValue = null;</span><br><span class="line"></span><br><span class="line">    for (int i = 0, size = headers.size(); i &lt; size; i++) &#123;</span><br><span class="line">      String name = headers.name(i);</span><br><span class="line">      String value = headers.value(i);</span><br><span class="line"></span><br><span class="line">      if (name.equalsIgnoreCase(&quot;Cache-Control&quot;)) &#123;</span><br><span class="line">        if (headerValue != null) &#123;</span><br><span class="line">          // Multiple cache-control headers means we can&apos;t use the raw value.</span><br><span class="line">          canUseHeaderValue = false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          headerValue = value;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (name.equalsIgnoreCase(&quot;Pragma&quot;)) &#123;</span><br><span class="line">        // Might specify additional cache-control params. We invalidate just in case.</span><br><span class="line">        canUseHeaderValue = false;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      int pos = 0;</span><br><span class="line">      while (pos &lt; value.length()) &#123;</span><br><span class="line">        int tokenStart = pos;</span><br><span class="line">        pos = HttpHeaders.skipUntil(value, pos, &quot;=,;&quot;);</span><br><span class="line">        String directive = value.substring(tokenStart, pos).trim();</span><br><span class="line">        String parameter;</span><br><span class="line"></span><br><span class="line">        if (pos == value.length() || value.charAt(pos) == &apos;,&apos; || value.charAt(pos) == &apos;;&apos;) &#123;</span><br><span class="line">          pos++; // consume &apos;,&apos; or &apos;;&apos; (if necessary)</span><br><span class="line">          parameter = null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          pos++; // consume &apos;=&apos;</span><br><span class="line">          pos = HttpHeaders.skipWhitespace(value, pos);</span><br><span class="line"></span><br><span class="line">          // quoted string</span><br><span class="line">          if (pos &lt; value.length() &amp;&amp; value.charAt(pos) == &apos;\&quot;&apos;) &#123;</span><br><span class="line">            pos++; // consume &apos;&quot;&apos; open quote</span><br><span class="line">            int parameterStart = pos;</span><br><span class="line">            pos = HttpHeaders.skipUntil(value, pos, &quot;\&quot;&quot;);</span><br><span class="line">            parameter = value.substring(parameterStart, pos);</span><br><span class="line">            pos++; // consume &apos;&quot;&apos; close quote (if necessary)</span><br><span class="line"></span><br><span class="line">            // unquoted string</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            int parameterStart = pos;</span><br><span class="line">            pos = HttpHeaders.skipUntil(value, pos, &quot;,;&quot;);</span><br><span class="line">            parameter = value.substring(parameterStart, pos).trim();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (&quot;no-cache&quot;.equalsIgnoreCase(directive)) &#123;</span><br><span class="line">          noCache = true;</span><br><span class="line">        &#125; else if (&quot;no-store&quot;.equalsIgnoreCase(directive)) &#123;</span><br><span class="line">          noStore = true;</span><br><span class="line">        &#125; else if (&quot;max-age&quot;.equalsIgnoreCase(directive)) &#123;</span><br><span class="line">          maxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1);</span><br><span class="line">        &#125; else if (&quot;s-maxage&quot;.equalsIgnoreCase(directive)) &#123;</span><br><span class="line">          sMaxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1);</span><br><span class="line">        &#125; else if (&quot;private&quot;.equalsIgnoreCase(directive)) &#123;</span><br><span class="line">          isPrivate = true;</span><br><span class="line">        &#125; else if (&quot;public&quot;.equalsIgnoreCase(directive)) &#123;</span><br><span class="line">          isPublic = true;</span><br><span class="line">        &#125; else if (&quot;must-revalidate&quot;.equalsIgnoreCase(directive)) &#123;</span><br><span class="line">          mustRevalidate = true;</span><br><span class="line">        &#125; else if (&quot;max-stale&quot;.equalsIgnoreCase(directive)) &#123;</span><br><span class="line">          maxStaleSeconds = HttpHeaders.parseSeconds(parameter, Integer.MAX_VALUE);</span><br><span class="line">        &#125; else if (&quot;min-fresh&quot;.equalsIgnoreCase(directive)) &#123;</span><br><span class="line">          minFreshSeconds = HttpHeaders.parseSeconds(parameter, -1);</span><br><span class="line">        &#125; else if (&quot;only-if-cached&quot;.equalsIgnoreCase(directive)) &#123;</span><br><span class="line">          onlyIfCached = true;</span><br><span class="line">        &#125; else if (&quot;no-transform&quot;.equalsIgnoreCase(directive)) &#123;</span><br><span class="line">          noTransform = true;</span><br><span class="line">        &#125; else if (&quot;immutable&quot;.equalsIgnoreCase(directive)) &#123;</span><br><span class="line">          immutable = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!canUseHeaderValue) &#123;</span><br><span class="line">      headerValue = null;</span><br><span class="line">    &#125;</span><br><span class="line">    return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPrivate, isPublic,</span><br><span class="line">        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, immutable,</span><br><span class="line">        headerValue);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>大致的缓存就差不多了</p>
<h3 id="小结-4"><a class="markdownIt-Anchor" href="#小结-4"></a> 小结</h3>
<p>我们今天研究了一下缓存策略，到底什么时候可以缓存，什么时候不能缓存，缓存到底是什么操作，我们今天都弄清楚了，总的来说，缓存并不是说不访问服务器了，而是说访问服务器看是否有没有数据的变化，另外缓存针对于 GET HEAD 请求，另外 DiskLruCache 的使用</p>
<p>欢迎讨论～</p>
<h3 id="前言-5"><a class="markdownIt-Anchor" href="#前言-5"></a> 前言</h3>
<p>几天过去了，之前我们依次学习了 RetryAndFollowUpInterceptor、BridgeInterceptor、CacheInterceptor 看到了我们的 Request 怎么一步一步转化成 NetworkRequest，亦或是 Response 怎么处理 Response，重试跟踪，转化，缓存，但我们至今还未看到数据是怎么传送出去，今天，我们将要了解的 ConnectInterceptor 仍然没有传数据过去，但是他在建立连接，复用连接起着重要的作用，内部维护着一个连接池，连接使用的是 socket，sslsocket，分别对应HTTP1 HTTP2 的 socket 和 HTTPS 的 sslSocket 连接，关于 sslSocket，又涉及到安全问题，比如说，ssl 的建立，证书的认证，数据的加密传输，解密等等。</p>
<h3 id="是什么东西-3"><a class="markdownIt-Anchor" href="#是什么东西-3"></a> 是什么东西？</h3>
<p>关于连接的拦截器，里面管理着 socket 的连接，这样方便我们之后的请求做连接复用，提高效率</p>
<h3 id="源码解析"><a class="markdownIt-Anchor" href="#源码解析"></a> 源码解析</h3>
<p>首先获取 streamAllocation，然后新建一个 stream，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final class ConnectInterceptor implements Interceptor &#123;</span><br><span class="line">  public final OkHttpClient client;</span><br><span class="line"></span><br><span class="line">  public ConnectInterceptor(OkHttpClient client) &#123;</span><br><span class="line">    this.client = client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">    // We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br><span class="line">    boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);</span><br><span class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class="line">    RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">    return realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 findHealthyConnection 获取一个连接，在根据 RealConnection 建立 HttpCodec</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public HttpCodec newStream(</span><br><span class="line">    OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) &#123;</span><br><span class="line">  int connectTimeout = chain.connectTimeoutMillis();</span><br><span class="line">  int readTimeout = chain.readTimeoutMillis();</span><br><span class="line">  int writeTimeout = chain.writeTimeoutMillis();</span><br><span class="line">  int pingIntervalMillis = client.pingIntervalMillis();</span><br><span class="line">  boolean connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">    HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);</span><br><span class="line"></span><br><span class="line">    synchronized (connectionPool) &#123;</span><br><span class="line">      codec = resultCodec;</span><br><span class="line">      return resultCodec;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (IOException e) &#123;</span><br><span class="line">    throw new RouteException(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法有点长，主要的思路是先从连接池里查找，若找不到就创建一个 socket 连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,</span><br><span class="line">     int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException &#123;</span><br><span class="line">   boolean foundPooledConnection = false;</span><br><span class="line">   RealConnection result = null;</span><br><span class="line">   Route selectedRoute = null;</span><br><span class="line">   Connection releasedConnection;</span><br><span class="line">   Socket toClose;</span><br><span class="line">   synchronized (connectionPool) &#123;</span><br><span class="line">     if (released) throw new IllegalStateException(&quot;released&quot;);</span><br><span class="line">     if (codec != null) throw new IllegalStateException(&quot;codec != null&quot;);</span><br><span class="line">     if (canceled) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line"></span><br><span class="line">     // Attempt to use an already-allocated connection. We need to be careful here because our</span><br><span class="line">     // already-allocated connection may have been restricted from creating new streams.</span><br><span class="line">     releasedConnection = this.connection;</span><br><span class="line">     toClose = releaseIfNoNewStreams();</span><br><span class="line">     if (this.connection != null) &#123;</span><br><span class="line">       // We had an already-allocated connection and it&apos;s good.</span><br><span class="line">       result = this.connection;</span><br><span class="line">       releasedConnection = null;</span><br><span class="line">     &#125;</span><br><span class="line">     if (!reportedAcquired) &#123;</span><br><span class="line">       // If the connection was never reported acquired, don&apos;t report it as released!</span><br><span class="line">       releasedConnection = null;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (result == null) &#123;</span><br><span class="line">       // Attempt to get a connection from the pool.</span><br><span class="line">       Internal.instance.get(connectionPool, address, this, null);</span><br><span class="line">       if (connection != null) &#123;</span><br><span class="line">         foundPooledConnection = true;</span><br><span class="line">         result = connection;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         selectedRoute = route;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   closeQuietly(toClose);</span><br><span class="line"></span><br><span class="line">   if (releasedConnection != null) &#123;</span><br><span class="line">     eventListener.connectionReleased(call, releasedConnection);</span><br><span class="line">   &#125;</span><br><span class="line">   if (foundPooledConnection) &#123;</span><br><span class="line">     eventListener.connectionAcquired(call, result);</span><br><span class="line">   &#125;</span><br><span class="line">   if (result != null) &#123;</span><br><span class="line">     // If we found an already-allocated or pooled connection, we&apos;re done.</span><br><span class="line">     return result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // If we need a route selection, make one. This is a blocking operation.</span><br><span class="line">   boolean newRouteSelection = false;</span><br><span class="line">   if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection.hasNext())) &#123;</span><br><span class="line">     newRouteSelection = true;</span><br><span class="line">     routeSelection = routeSelector.next();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   synchronized (connectionPool) &#123;</span><br><span class="line">     if (canceled) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line"></span><br><span class="line">     if (newRouteSelection) &#123;</span><br><span class="line">       // Now that we have a set of IP addresses, make another attempt at getting a connection from</span><br><span class="line">       // the pool. This could match due to connection coalescing.</span><br><span class="line">       List&lt;Route&gt; routes = routeSelection.getAll();</span><br><span class="line">       for (int i = 0, size = routes.size(); i &lt; size; i++) &#123;</span><br><span class="line">         Route route = routes.get(i);</span><br><span class="line">         Internal.instance.get(connectionPool, address, this, route);</span><br><span class="line">         if (connection != null) &#123;</span><br><span class="line">           foundPooledConnection = true;</span><br><span class="line">           result = connection;</span><br><span class="line">           this.route = route;</span><br><span class="line">           break;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (!foundPooledConnection) &#123;</span><br><span class="line">       if (selectedRoute == null) &#123;</span><br><span class="line">         selectedRoute = routeSelection.next();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Create a connection and assign it to this allocation immediately. This makes it possible</span><br><span class="line">       // for an asynchronous cancel() to interrupt the handshake we&apos;re about to do.</span><br><span class="line">       route = selectedRoute;</span><br><span class="line">       refusedStreamCount = 0;</span><br><span class="line">       result = new RealConnection(connectionPool, selectedRoute);</span><br><span class="line">       acquire(result, false);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // If we found a pooled connection on the 2nd time around, we&apos;re done.</span><br><span class="line">   if (foundPooledConnection) &#123;</span><br><span class="line">     eventListener.connectionAcquired(call, result);</span><br><span class="line">     return result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Do TCP + TLS handshakes. This is a blocking operation.</span><br><span class="line">   result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class="line">       connectionRetryEnabled, call, eventListener);</span><br><span class="line">   routeDatabase().connected(result.route());</span><br><span class="line"></span><br><span class="line">   Socket socket = null;</span><br><span class="line">   synchronized (connectionPool) &#123;</span><br><span class="line">     reportedAcquired = true;</span><br><span class="line"></span><br><span class="line">     // Pool the connection.</span><br><span class="line">     Internal.instance.put(connectionPool, result);</span><br><span class="line"></span><br><span class="line">     // If another multiplexed connection to the same address was created concurrently, then</span><br><span class="line">     // release this connection and acquire that one.</span><br><span class="line">     if (result.isMultiplexed()) &#123;</span><br><span class="line">       socket = Internal.instance.deduplicate(connectionPool, address, this);</span><br><span class="line">       result = connection;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   closeQuietly(socket);</span><br><span class="line"></span><br><span class="line">   eventListener.connectionAcquired(call, result);</span><br><span class="line">   return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>建立protocol连接，此处如果是 TLS ，则建立 sslsocket 连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void establishProtocol(ConnectionSpecSelector connectionSpecSelector,</span><br><span class="line">    int pingIntervalMillis, Call call, EventListener eventListener) throws IOException &#123;</span><br><span class="line">  if (route.address().sslSocketFactory() == null) &#123;</span><br><span class="line">    if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) &#123;</span><br><span class="line">      socket = rawSocket;</span><br><span class="line">      protocol = Protocol.H2_PRIOR_KNOWLEDGE;</span><br><span class="line">      startHttp2(pingIntervalMillis);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    socket = rawSocket;</span><br><span class="line">    protocol = Protocol.HTTP_1_1;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eventListener.secureConnectStart(call);</span><br><span class="line">  connectTls(connectionSpecSelector);</span><br><span class="line">  eventListener.secureConnectEnd(call, handshake);</span><br><span class="line"></span><br><span class="line">  if (protocol == Protocol.HTTP_2) &#123;</span><br><span class="line">    startHttp2(pingIntervalMillis);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立 TSL，在 rawSocket 的基础上建立 sslSocket 连接，然后握手，检测证书，返回连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IOException &#123;</span><br><span class="line">  Address address = route.address();</span><br><span class="line">  SSLSocketFactory sslSocketFactory = address.sslSocketFactory();</span><br><span class="line">  boolean success = false;</span><br><span class="line">  SSLSocket sslSocket = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    // Create the wrapper over the connected socket.</span><br><span class="line">    sslSocket = (SSLSocket) sslSocketFactory.createSocket(</span><br><span class="line">        rawSocket, address.url().host(), address.url().port(), true /* autoClose */);</span><br><span class="line"></span><br><span class="line">    // Configure the socket&apos;s ciphers, TLS versions, and extensions.</span><br><span class="line">    ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);</span><br><span class="line">    if (connectionSpec.supportsTlsExtensions()) &#123;</span><br><span class="line">      Platform.get().configureTlsExtensions(</span><br><span class="line">          sslSocket, address.url().host(), address.protocols());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Force handshake. This can throw!</span><br><span class="line">    sslSocket.startHandshake();</span><br><span class="line">    // block for session establishment</span><br><span class="line">    SSLSession sslSocketSession = sslSocket.getSession();</span><br><span class="line">    Handshake unverifiedHandshake = Handshake.get(sslSocketSession);</span><br><span class="line"></span><br><span class="line">    // Verify that the socket&apos;s certificates are acceptable for the target host.</span><br><span class="line">    if (!address.hostnameVerifier().verify(address.url().host(), sslSocketSession)) &#123;</span><br><span class="line">      X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(0);</span><br><span class="line">      throw new SSLPeerUnverifiedException(&quot;Hostname &quot; + address.url().host() + &quot; not verified:&quot;</span><br><span class="line">          + &quot;\n    certificate: &quot; + CertificatePinner.pin(cert)</span><br><span class="line">          + &quot;\n    DN: &quot; + cert.getSubjectDN().getName()</span><br><span class="line">          + &quot;\n    subjectAltNames: &quot; + OkHostnameVerifier.allSubjectAltNames(cert));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Check that the certificate pinner is satisfied by the certificates presented.</span><br><span class="line">    address.certificatePinner().check(address.url().host(),</span><br><span class="line">        unverifiedHandshake.peerCertificates());</span><br><span class="line"></span><br><span class="line">    // Success! Save the handshake and the ALPN protocol.</span><br><span class="line">    String maybeProtocol = connectionSpec.supportsTlsExtensions()</span><br><span class="line">        ? Platform.get().getSelectedProtocol(sslSocket)</span><br><span class="line">        : null;</span><br><span class="line">    socket = sslSocket;</span><br><span class="line">    source = Okio.buffer(Okio.source(socket));</span><br><span class="line">    sink = Okio.buffer(Okio.sink(socket));</span><br><span class="line">    handshake = unverifiedHandshake;</span><br><span class="line">    protocol = maybeProtocol != null</span><br><span class="line">        ? Protocol.get(maybeProtocol)</span><br><span class="line">        : Protocol.HTTP_1_1;</span><br><span class="line">    success = true;</span><br><span class="line">  &#125; catch (AssertionError e) &#123;</span><br><span class="line">    if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);</span><br><span class="line">    throw e;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    if (sslSocket != null) &#123;</span><br><span class="line">      Platform.get().afterHandshake(sslSocket);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!success) &#123;</span><br><span class="line">      closeQuietly(sslSocket);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 SSL 更多的内容，可自行 google</p>
<h3 id="小结-5"><a class="markdownIt-Anchor" href="#小结-5"></a> 小结</h3>
<p>ConnectInterceptor 的作用我们现在大致有个轮廓了，但总感觉还不够清晰，需要多加巩固，其中有关于 X509TrustManager，自定义证书的信任，其他的由 sslContext 帮我们做了处理</p>
<h3 id="前言-6"><a class="markdownIt-Anchor" href="#前言-6"></a> 前言</h3>
<p>激动人心的时刻将要来了，我们将会看到数据是怎么在客户端服务端之间进行交互的，但是再此之前，我们有必要了解一下 socket 纠结是什么东西，与 HTTP 协议，TCP/IP 协议之间的关系又是如何，这些理论暂且自行查找，我在这暂且简单说一说，socket 并不是协议，它实现了 TCP/UDP 的语义，而HTTP 是属于应用层的协议，我们并不能直接使用 TCP、UDP 来传输数据，而这时候我们可以使用 socket 来实现。当我们使用 socket 建立 TCP 连接，之后便可以使用这个连接用来收发数据。当你对 HTTP 协议了解深入了，就会体会到这中间的妙处，建议是看一下 HTTP 协议，可以看 RFC 官方文档，下次在简历上可以说精通 TCP/IP、HTTP 协议，这可比项目吸引眼球多了。又想去改简历了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">                   |      SOCKET      |</span><br><span class="line">IP    -&gt;       TCP          -&gt;           HTTP</span><br></pre></td></tr></table></figure>
<h3 id="http-协议"><a class="markdownIt-Anchor" href="#http-协议"></a> HTTP 协议</h3>
<p>若要理解 HTTP 协议，莫过于使用它，安利一下 wireshark 这个工具，还是超级好用的，可以清楚地看到包的内容，各层协议封装的内容，看多了就会很清楚包里面的数据格式，之所以然而知其所以然。<br>
我们在使用 socket 的时候，通常就是往 socket 里写入 HTTP 消息，下面给出两个简单的例子，我们只需要把这些文本写入流中便可，即可完成一次简单的 HTTP 通信，当然，实际的协议要比这复杂得多，很多协议需要浏览器与服务器自行实现。<br>
Request</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET URL HTTP/1.1\r\n   // 请求行</span><br><span class="line">Host: www.cnblogs.com\r\n   // 请求头</span><br><span class="line">Connection: keep-alive\r\n</span><br><span class="line">Accept: application/json, text/javascript, */*; q=0.01\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
<p>Response</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK\r\n     // 响应行</span><br><span class="line">Date: Wed, 22 Aug 2018 02:10:58 GMT\r\n    // 响应头</span><br><span class="line">...</span><br><span class="line">\r\n                              // 空行</span><br><span class="line">File Data: 5 bytes       // 请求数据</span><br></pre></td></tr></table></figure>
<h3 id="源码解析-2"><a class="markdownIt-Anchor" href="#源码解析-2"></a> 源码解析</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final class CallServerInterceptor implements Interceptor &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>通常，是由　httpCodec.writeRequestHeaders(request) 写入 socket 流中，然后通过 flushRequest 刷新缓存，请求便发给服务端了，中间可能遇到很多情况</p>
<ul>
<li>100 如果客户端使用了 Expect：100-continue，那么客户端会先发送 headers，获取响应，如果服务器能够接收并且发送了 100 返回码，那么客户端会继续发送数据构建 Response</li>
<li>101 协议升级，重新构建 Response</li>
<li>204 205 检查是否有异常</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">  RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">  HttpCodec httpCodec = realChain.httpStream();</span><br><span class="line">  StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">  RealConnection connection = (RealConnection) realChain.connection();</span><br><span class="line">  Request request = realChain.request();</span><br><span class="line"></span><br><span class="line">  long sentRequestMillis = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">  realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class="line">  httpCodec.writeRequestHeaders(request);</span><br><span class="line">  realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class="line"></span><br><span class="line">  Response.Builder responseBuilder = null;</span><br><span class="line">  if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123;</span><br><span class="line">    // If there&apos;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100</span><br><span class="line">    // Continue&quot; response before transmitting the request body. If we don&apos;t get that, return</span><br><span class="line">    // what we did get (such as a 4xx response) without ever transmitting the request body.</span><br><span class="line">    if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) &#123;</span><br><span class="line">      httpCodec.flushRequest();</span><br><span class="line">      realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">      responseBuilder = httpCodec.readResponseHeaders(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (responseBuilder == null) &#123;</span><br><span class="line">      // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span><br><span class="line">      realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class="line">      long contentLength = request.body().contentLength();</span><br><span class="line">      CountingSink requestBodyOut =</span><br><span class="line">          new CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class="line">      BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line"></span><br><span class="line">      request.body().writeTo(bufferedRequestBody);</span><br><span class="line">      bufferedRequestBody.close();</span><br><span class="line">      realChain.eventListener()</span><br><span class="line">          .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class="line">    &#125; else if (!connection.isMultiplexed()) &#123;</span><br><span class="line">      // If the &quot;Expect: 100-continue&quot; expectation wasn&apos;t met, prevent the HTTP/1 connection</span><br><span class="line">      // from being reused. Otherwise we&apos;re still obligated to transmit the request body to</span><br><span class="line">      // leave the connection in a consistent state.</span><br><span class="line">      streamAllocation.noNewStreams();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  httpCodec.finishRequest();</span><br></pre></td></tr></table></figure>
<p>当然，其中也包括 https的传输，而使用 sslSocket 惊喜加密通信。</p>
<h3 id="小结-6"><a class="markdownIt-Anchor" href="#小结-6"></a> 小结</h3>
<p>基本上我们看到了 OkHttp 必备的 Interceptor，大致的流程我们已经清楚了，接下来就是细节推导，我们时常更新细节</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://wzes.github.io/2018/08/23/Android/OkHttp3/" title="Android OkHttp3 源码解析" target="_blank" rel="external">https://wzes.github.io/2018/08/23/Android/OkHttp3/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/wzes" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/wzes" target="_blank"><span class="text-dark">爨</span><small class="ml-1x">美团点评 Android 开发</small></a></h3>
        <div>一只会 FE 的 Android 工程师～</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
           
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2018/08/24/Android/DiskLruCache/" title="Android DiskLruCache 源码解析"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2018/08/23/Network/HTTP Code 总结/" title="HTTP-Code-总结"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.jpeg" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.jpeg" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/wzes" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://weibo.com/u/5589559954" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/Xuantang4" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>





   




   
    
  <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"> -->
  <script src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '5e22a8877cbd25268283',
    clientSecret: 'f47449129237f1d2c9c4fa92f9a6764c029f910a',
    repo: 'gitalk_blog',
    owner: 'wzes',
    admin: ['wzes'],
    id: md5(location.pathname).toString().substr(0, 49),
    distractionFreeMode: true
  })
  gitalk.render('comments')
  </script>

      







</body>
</html>