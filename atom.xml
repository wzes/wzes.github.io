<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wzes.github.io/"/>
  <updated>2019-09-01T14:31:10.512Z</updated>
  <id>https://wzes.github.io/</id>
  
  <author>
    <name>Xuantang Cun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript Array 的 1 个属性，35 个方法</title>
    <link href="https://wzes.github.io/2019/09/01/JavaScript%20Array/"/>
    <id>https://wzes.github.io/2019/09/01/JavaScript Array/</id>
    <published>2019-09-01T07:30:16.000Z</published>
    <updated>2019-09-01T14:31:10.512Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>这周呢，彻底学习一下 Array 的所有方法。学习地址 MDN，里面还有各个函数实现的源码！数组作为 JavaScript 的一种类型，与 Number，Boolean，Null，Undefined，Object，Symbol  齐驱并驾。了解 Array 的所有方法，能帮助我们最快找到适合自己的函数。</p><h4 id="create-an-array"><a class="markdownIt-Anchor" href="#create-an-array"></a> Create an Array</h4><p>创建一个数组很简单，直接赋值，或者使用 <code>[]</code> 创建空数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var fruits = [&apos;Apple&apos;, &apos;Banana&apos;];</span><br><span class="line">console.log(fruits.length); // 2</span><br></pre></td></tr></table></figure><h4 id><a class="markdownIt-Anchor" href="#"></a> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length#" target="_blank" rel="noopener"><strong>Properties</strong></a></h4><h5 id="arraylength"><a class="markdownIt-Anchor" href="#arraylength"></a> Array.length</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var clothing = [&apos;shoes&apos;, &apos;shirts&apos;, &apos;socks&apos;, &apos;sweaters&apos;];</span><br><span class="line"></span><br><span class="line">console.log(clothing.length);</span><br><span class="line">// expected output: 4</span><br><span class="line"></span><br><span class="line">var array = new Array(2)</span><br></pre></td></tr></table></figure><h4 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype#" target="_blank" rel="noopener"><strong>Methods</strong></a></h4><p>首先看一下 Array 的三个静态方法<br>#####1. Array.from()<br><strong>Array.from()</strong> 方法从类似数组或可迭代的对象创建一个新的，浅拷贝的 Array 实例，或者从 {length: 3} 对象中创建固定长度的 undefined 数组</p><blockquote><p>Array.from(arrayLike[, mapFn[, thisArg]])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(Array.from(&apos;foo&apos;));</span><br><span class="line">// expected output: Array [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]</span><br><span class="line"></span><br><span class="line">console.log(Array.from([1, 2, 3], x =&gt; x + x));</span><br><span class="line">// expected output: Array [2, 4, 6]</span><br><span class="line"></span><br><span class="line">console.log(Array.from(&#123;length: 3&#125;));</span><br><span class="line">// expected output: Array [undefined, undefined, undefined]</span><br></pre></td></tr></table></figure><h5 id="2-arrayisarray"><a class="markdownIt-Anchor" href="#2-arrayisarray"></a> 2. Array.isArray()</h5><p><strong>Array.isArray()</strong> 方法确定传递的值是否为 Array，由于 typeof Array = ‘object’ ，所以判断是否是一个数组使用 isArray 才可以</p><blockquote><p>Array.isArray(value)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray([1, 2, 3]);  // true</span><br><span class="line">Array.isArray(&#123;foo: 123&#125;); // false</span><br><span class="line">Array.isArray(&apos;foobar&apos;);   // false</span><br><span class="line">Array.isArray(undefined);  // false</span><br></pre></td></tr></table></figure><h5 id="3-arrayof"><a class="markdownIt-Anchor" href="#3-arrayof"></a> 3. Array.of()</h5><p><strong>Array.of()</strong> 方法从可变数量的参数创建一个新的Array实例，无论参数的数量或类型如何<br>注意它与构造函数的不同之处</p><blockquote><p>Array.of(element0[, element1[, …[, elementN]]])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.of(7);       // [7] </span><br><span class="line">Array.of(1, 2, 3); // [1, 2, 3]</span><br><span class="line"></span><br><span class="line">Array(7);          // array of 7 empty slots</span><br><span class="line">Array(1, 2, 3);    // [1, 2, 3]</span><br></pre></td></tr></table></figure><p>接下来看 Array 的对象方法</p><h5 id="4-arrayprototypeconcat"><a class="markdownIt-Anchor" href="#4-arrayprototypeconcat"></a> 4. Array.prototype.concat()</h5><p><strong>concat()</strong> 方法用于合并两个或多个数组。 此方法不会更改现有数组，而是返回一个新数组</p><blockquote><p>var new_array = old_array.concat([value1[, value2[, …[, valueN]]]])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">var array2 = [&apos;d&apos;, &apos;e&apos;, &apos;f&apos;];</span><br><span class="line"></span><br><span class="line">console.log(array1.concat(array2));</span><br><span class="line">// expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span><br></pre></td></tr></table></figure><h5 id="5-arrayprototypecopywithin"><a class="markdownIt-Anchor" href="#5-arrayprototypecopywithin"></a> 5. Array.prototype.copyWithin()</h5><p><strong>copyWithin()</strong> 方法浅析将数组的一部分复制到同一数组中的另一个位置，并返回它而不修改其长度</p><blockquote><p>arr.copyWithin(target[, start[, end]])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];</span><br><span class="line"></span><br><span class="line">// copy to index 0 the element at index 3</span><br><span class="line">console.log(array1.copyWithin(0, 3, 4));</span><br><span class="line">// expected output: Array [&quot;d&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br><span class="line"></span><br><span class="line">// copy to index 1 all elements from index 3 to the end</span><br><span class="line">console.log(array1.copyWithin(1, 3));</span><br><span class="line">// expected output: Array [&quot;d&quot;, &quot;d&quot;, &quot;e&quot;, &quot;d&quot;, &quot;e&quot;]</span><br></pre></td></tr></table></figure><h5 id="6-arrayprototypeentries"><a class="markdownIt-Anchor" href="#6-arrayprototypeentries"></a> 6. Array.prototype.entries()</h5><p><strong>entries()</strong> 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。</p><blockquote><p>array.entries()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">var iterator1 = array1.entries();</span><br><span class="line"></span><br><span class="line">console.log(iterator1.next().value);</span><br><span class="line">// expected output: Array [0, &quot;a&quot;]</span><br><span class="line"></span><br><span class="line">console.log(iterator1.next().value);</span><br><span class="line">// expected output: Array [1, &quot;b&quot;]</span><br><span class="line"></span><br><span class="line">// 使用 for of 遍历</span><br><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">var iterator = a.entries();</span><br><span class="line"></span><br><span class="line">for (let e of iterator) &#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;</span><br><span class="line">// [0, &apos;a&apos;]</span><br><span class="line">// [1, &apos;b&apos;]</span><br><span class="line">// [2, &apos;c&apos;]</span><br></pre></td></tr></table></figure><h5 id="7-arrayprototypeevery"><a class="markdownIt-Anchor" href="#7-arrayprototypeevery"></a> 7. Array.prototype.every()</h5><p><strong>every()</strong> 方法测试数组中的所有元素是否都通过了由提供的函数实现的测试。 它返回一个布尔值</p><blockquote><p>arr.every(callback(element[, index[, array]])[, thisArg])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function isBelowThreshold(currentValue) &#123;</span><br><span class="line">  return currentValue &lt; 40;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var array1 = [1, 30, 39, 29, 10, 13];</span><br><span class="line"></span><br><span class="line">console.log(array1.every(isBelowThreshold));</span><br><span class="line">// expected output: true</span><br></pre></td></tr></table></figure><h5 id="8-arrayprototypefill"><a class="markdownIt-Anchor" href="#8-arrayprototypefill"></a> 8. Array.prototype.fill()</h5><p><strong>fill()</strong> 方法使用静态值从开始索引（默认为零）到结束索引（默认数组长度）填充（修改）数组的所有元素。 它返回修改后的数组，原数组会改变～</p><blockquote><p>arr.fill(value[, start[, end]])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> var array1 = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">// fill with 0 from position 2 until position 4</span><br><span class="line">console.log(array1.fill(0, 2, 4));</span><br><span class="line">// expected output: [1, 2, 0, 0]</span><br><span class="line"></span><br><span class="line">// fill with 5 from position 1</span><br><span class="line">console.log(array1.fill(5, 1));</span><br><span class="line">// expected output: [1, 5, 5, 5]</span><br><span class="line"></span><br><span class="line">console.log(array1.fill(6));</span><br><span class="line">// expected output: [6, 6, 6, 6]</span><br></pre></td></tr></table></figure><h5 id="9-arrayprototypefilter"><a class="markdownIt-Anchor" href="#9-arrayprototypefilter"></a> 9.  Array.prototype.filter()</h5><p><strong>filter()</strong> 方法创建一个新数组，其中包含所有传递由提供的函数实现的测试的元素</p><blockquote><p>var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var words = [&apos;spray&apos;, &apos;limit&apos;, &apos;elite&apos;, &apos;exuberant&apos;, &apos;destruction&apos;, &apos;present&apos;];</span><br><span class="line"></span><br><span class="line">const result = words.filter(word =&gt; word.length &gt; 6);</span><br><span class="line"></span><br><span class="line">console.log(result);</span><br><span class="line">// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]</span><br></pre></td></tr></table></figure><h5 id="10-arrayprototypefind"><a class="markdownIt-Anchor" href="#10-arrayprototypefind"></a> 10. Array.prototype.find()</h5><p><strong>find()</strong> 方法返回数组中第一个满足提供的测试函数的元素的值。 否则返回undefined</p><blockquote><p>arr.find(callback(element[, index[, array]])[, thisArg])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [5, 12, 8, 130, 44];</span><br><span class="line"></span><br><span class="line">var found = array1.find(function(element) &#123;</span><br><span class="line">  return element &gt; 10;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(found);</span><br><span class="line">// expected output: 12</span><br></pre></td></tr></table></figure><h5 id="11-arrayprototypefindindex"><a class="markdownIt-Anchor" href="#11-arrayprototypefindindex"></a> 11. Array.prototype.findIndex()</h5><p><strong>findIndex()</strong> 方法返回数组中第一个满足提供的测试函数的元素的索引。 否则，它返回-1，表示没有元素通过测试</p><blockquote><p>arr.findIndex(callback(element[, index[, array]])[, thisArg])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [5, 12, 8, 130, 44];</span><br><span class="line"></span><br><span class="line">function isLargeNumber(element) &#123;</span><br><span class="line">  return element &gt; 13;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(array1.findIndex(isLargeNumber));</span><br></pre></td></tr></table></figure><h5 id="12-arrayprototypeflat"><a class="markdownIt-Anchor" href="#12-arrayprototypeflat"></a> 12. Array.prototype.flat()</h5><p><strong>flat()</strong> 方法创建一个新数组，所有子数组元素以递归方式连接到指定的深度。</p><blockquote><p>var newArray = arr.flat([depth]);</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1, 2, [3, 4]];</span><br><span class="line">arr1.flat(); </span><br><span class="line">// [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">var arr2 = [1, 2, [3, 4, [5, 6]]];</span><br><span class="line">arr2.flat();</span><br><span class="line">// [1, 2, 3, 4, [5, 6]]</span><br><span class="line"></span><br><span class="line">var arr3 = [1, 2, [3, 4, [5, 6]]];</span><br><span class="line">arr3.flat(2);</span><br><span class="line">// [1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];</span><br><span class="line">arr4.flat(Infinity);</span><br><span class="line">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure><h5 id="13-arrayprototypeflatmap"><a class="markdownIt-Anchor" href="#13-arrayprototypeflatmap"></a> 13. Array.prototype.flatMap()</h5><p><strong>flatMap()</strong> 方法首先使用映射函数映射每个元素，然后将结果展平为新数组。 它与map（）后跟深度为1的flat（）相同，但flatMap（）通常非常有用，因为将两者合并到一个方法中效率稍高</p><blockquote><p>var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) {<br>// return element for new_array<br>}[, thisArg])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [&quot;it&apos;s Sunny in&quot;, &quot;&quot;, &quot;California&quot;];</span><br><span class="line"></span><br><span class="line">arr1.map(x =&gt; x.split(&quot; &quot;));</span><br><span class="line">// [[&quot;it&apos;s&quot;,&quot;Sunny&quot;,&quot;in&quot;],[&quot;&quot;],[&quot;California&quot;]]</span><br><span class="line"></span><br><span class="line">arr1.flatMap(x =&gt; x.split(&quot; &quot;));</span><br><span class="line">// [&quot;it&apos;s&quot;,&quot;Sunny&quot;,&quot;in&quot;, &quot;&quot;, &quot;California&quot;]</span><br></pre></td></tr></table></figure><h5 id="14-arrayprototypeforeach"><a class="markdownIt-Anchor" href="#14-arrayprototypeforeach"></a> 14. Array.prototype.forEach()</h5><p><strong>forEach()</strong> 方法为每个数组元素执行一次提供的函数</p><blockquote><p>arr.forEach(callback(currentValue [, index [, array]])[, thisArg]);</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">array1.forEach(function(element) &#123;</span><br><span class="line">  console.log(element);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// expected output: &quot;a&quot;</span><br><span class="line">// expected output: &quot;b&quot;</span><br><span class="line">// expected output: &quot;c&quot;</span><br></pre></td></tr></table></figure><h5 id="15-arrayprototypeincludes"><a class="markdownIt-Anchor" href="#15-arrayprototypeincludes"></a> 15. Array.prototype.includes()</h5><p><strong>includes()</strong> 方法确定数组是否在其条目中包含某个值，并在适当时返回true或false</p><blockquote><p>arr.includes(valueToFind[, fromIndex])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">console.log(array1.includes(2));</span><br><span class="line">// expected output: true</span><br><span class="line"></span><br><span class="line">var pets = [&apos;cat&apos;, &apos;dog&apos;, &apos;bat&apos;];</span><br><span class="line"></span><br><span class="line">console.log(pets.includes(&apos;cat&apos;));</span><br><span class="line">// expected output: true</span><br><span class="line"></span><br><span class="line">console.log(pets.includes(&apos;at&apos;));</span><br><span class="line">// expected output: false</span><br></pre></td></tr></table></figure><h5 id="16-arrayprototypeindexof"><a class="markdownIt-Anchor" href="#16-arrayprototypeindexof"></a> 16. Array.prototype.indexOf()</h5><p><strong>indexOf()</strong> 方法返回可在数组中找到给定元素的第一个索引，如果不存在则返回-1</p><blockquote><p>arr.indexOf(searchElement[, fromIndex])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var beasts = [&apos;ant&apos;, &apos;bison&apos;, &apos;camel&apos;, &apos;duck&apos;, &apos;bison&apos;];</span><br><span class="line"></span><br><span class="line">console.log(beasts.indexOf(&apos;bison&apos;));</span><br><span class="line">// expected output: 1</span><br><span class="line"></span><br><span class="line">// start from index 2</span><br><span class="line">console.log(beasts.indexOf(&apos;bison&apos;, 2));</span><br><span class="line">// expected output: 4</span><br><span class="line"></span><br><span class="line">console.log(beasts.indexOf(&apos;giraffe&apos;));</span><br><span class="line">// expected output: -1</span><br></pre></td></tr></table></figure><h5 id="17-arrayprototypejoin"><a class="markdownIt-Anchor" href="#17-arrayprototypejoin"></a> 17. Array.prototype.join()</h5><p><strong>join()</strong> 方法通过连接数组（或类数组对象）中的所有元素（用逗号或指定的分隔符字符串分隔）来创建并返回一个新字符串。 如果数组只有一个项目，那么将返回该项目而不使用分隔符</p><blockquote><p>arr.join([separator])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ar elements = [&apos;Fire&apos;, &apos;Air&apos;, &apos;Water&apos;];</span><br><span class="line"></span><br><span class="line">console.log(elements.join());</span><br><span class="line">// expected output: &quot;Fire,Air,Water&quot;</span><br><span class="line"></span><br><span class="line">console.log(elements.join(&apos;&apos;));</span><br><span class="line">// expected output: &quot;FireAirWater&quot;</span><br><span class="line"></span><br><span class="line">console.log(elements.join(&apos;-&apos;));</span><br><span class="line">// expected output: &quot;Fire-Air-Water&quot;</span><br></pre></td></tr></table></figure><h5 id="18-arrayprototypekeys"><a class="markdownIt-Anchor" href="#18-arrayprototypekeys"></a> 18. Array.prototype.keys()</h5><p><strong>keys()</strong> 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键</p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">var iterator = array1.keys(); </span><br><span class="line">  </span><br><span class="line">for (let key of iterator) &#123;</span><br><span class="line">  console.log(key); // expected output: 0 1 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="19-arrayprototypelastindexof"><a class="markdownIt-Anchor" href="#19-arrayprototypelastindexof"></a> 19. Array.prototype.lastIndexOf()</h5><p><strong>lastIndexOf()</strong> 方法返回可在数组中找到给定元素的最后一个索引，如果不存在则返回-1。 从fromIndex开始向后搜索数组</p><blockquote><p>arr.lastIndexOf(searchElement[, fromIndex])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var animals = [&apos;Dodo&apos;, &apos;Tiger&apos;, &apos;Penguin&apos;, &apos;Dodo&apos;];</span><br><span class="line"></span><br><span class="line">console.log(animals.lastIndexOf(&apos;Dodo&apos;));</span><br><span class="line">// expected output: 3</span><br><span class="line"></span><br><span class="line">console.log(animals.lastIndexOf(&apos;Penguin&apos;, 1));</span><br><span class="line">// expected output: -1</span><br></pre></td></tr></table></figure><h5 id="20-arrayprototypemap"><a class="markdownIt-Anchor" href="#20-arrayprototypemap"></a> 20. Array.prototype.map()</h5><p><strong>map()</strong> 方法创建一个新数组，其结果是在调用数组中的每个元素上调用提供的函数</p><blockquote><p>var new_array = arr.map(function callback(currentValue[, index[, array]]) {<br>// Return element for new_array<br>}[, thisArg])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [1, 4, 9, 16];</span><br><span class="line"></span><br><span class="line">// pass a function to map</span><br><span class="line">const map1 = array1.map(x =&gt; x * 2);</span><br><span class="line"></span><br><span class="line">console.log(map1);</span><br><span class="line">// expected output: Array [2, 8, 18, 32]</span><br></pre></td></tr></table></figure><h5 id="21-arrayprototypepop"><a class="markdownIt-Anchor" href="#21-arrayprototypepop"></a> 21. Array.prototype.pop()</h5><p><strong>pop()</strong> 方法从数组中删除最后一个元素并返回该元素。 此方法更改数组的长度。</p><blockquote><p>arr.pop()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var plants = [&apos;broccoli&apos;, &apos;cauliflower&apos;, &apos;cabbage&apos;, &apos;kale&apos;, &apos;tomato&apos;];</span><br><span class="line"></span><br><span class="line">console.log(plants.pop());</span><br><span class="line">// expected output: &quot;tomato&quot;</span><br><span class="line"></span><br><span class="line">console.log(plants);</span><br><span class="line">// expected output: Array [&quot;broccoli&quot;, &quot;cauliflower&quot;, &quot;cabbage&quot;, &quot;kale&quot;]</span><br><span class="line"></span><br><span class="line">plants.pop();</span><br><span class="line"></span><br><span class="line">console.log(plants);</span><br><span class="line">// expected output: Array [&quot;broccoli&quot;, &quot;cauliflower&quot;, &quot;cabbage&quot;]</span><br></pre></td></tr></table></figure><h5 id="22-arrayprototypepush"><a class="markdownIt-Anchor" href="#22-arrayprototypepush"></a> 22. Array.prototype.push()</h5><p><strong>push()</strong> 方法将一个或多个元素添加到数组的末尾，并返回数组的新长度</p><blockquote><p>arr.push(element1[, …[, elementN]])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var animals = [&apos;pigs&apos;, &apos;goats&apos;, &apos;sheep&apos;];</span><br><span class="line"></span><br><span class="line">console.log(animals.push(&apos;cows&apos;));</span><br><span class="line">// expected output: 4</span><br><span class="line"></span><br><span class="line">console.log(animals);</span><br><span class="line">// expected output: Array [&quot;pigs&quot;, &quot;goats&quot;, &quot;sheep&quot;, &quot;cows&quot;]</span><br><span class="line"></span><br><span class="line">animals.push(&apos;chickens&apos;);</span><br><span class="line"></span><br><span class="line">console.log(animals);</span><br><span class="line">// expected output: Array [&quot;pigs&quot;, &quot;goats&quot;, &quot;sheep&quot;, &quot;cows&quot;, &quot;chickens&quot;]</span><br></pre></td></tr></table></figure><h5 id="23-arrayprototypereduce"><a class="markdownIt-Anchor" href="#23-arrayprototypereduce"></a> 23. Array.prototype.reduce()</h5><p><strong>reduce()</strong> 方法在数组的每个元素上执行reducer函数（您提供），从而产生单个输出值</p><blockquote><p>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const array1 = [1, 2, 3, 4];</span><br><span class="line">const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;</span><br><span class="line"></span><br><span class="line">// 1 + 2 + 3 + 4</span><br><span class="line">console.log(array1.reduce(reducer));</span><br><span class="line">// expected output: 10</span><br><span class="line"></span><br><span class="line">// 5 + 1 + 2 + 3 + 4</span><br><span class="line">console.log(array1.reduce(reducer, 5));</span><br><span class="line">// expected output: 15</span><br></pre></td></tr></table></figure><h5 id="24-arrayprototypereduceright"><a class="markdownIt-Anchor" href="#24-arrayprototypereduceright"></a> 24. Array.prototype.reduceRight()</h5><p><strong>reduceRight()</strong> 方法对累加器和数组的每个值（从右到左）应用函数以将其减少为单个值</p><blockquote><p>arr.reduceRight(callback(accumulator, currentValue[, index[, array]])[, initialValue])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const array1 = [[0, 1], [2, 3], [4, 5]].reduceRight(</span><br><span class="line">  (accumulator, currentValue) =&gt; accumulator.concat(currentValue)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(array1);</span><br><span class="line">// expected output: Array [4, 5, 2, 3, 0, 1]</span><br></pre></td></tr></table></figure><h5 id="25-arrayprototypereverse"><a class="markdownIt-Anchor" href="#25-arrayprototypereverse"></a> 25. Array.prototype.reverse()</h5><p><strong>reverse()</strong> 方法将数组反转到位。 第一个数组元素成为最后一个，最后一个数组元素成为第一个</p><blockquote><p>a.reverse()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;];</span><br><span class="line">console.log(&apos;array1: &apos;, array1);</span><br><span class="line">// expected output: Array [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]</span><br><span class="line"></span><br><span class="line">var reversed = array1.reverse(); </span><br><span class="line">console.log(&apos;reversed: &apos;, reversed);</span><br><span class="line">// expected output: Array [&apos;three&apos;, &apos;two&apos;, &apos;one&apos;]</span><br><span class="line"></span><br><span class="line">/* Careful: reverse is destructive. It also changes</span><br><span class="line">the original array */ </span><br><span class="line">console.log(&apos;array1: &apos;, array1);</span><br><span class="line">// expected output: Array [&apos;three&apos;, &apos;two&apos;, &apos;one&apos;]</span><br></pre></td></tr></table></figure><h5 id="26-arrayprototypeshift"><a class="markdownIt-Anchor" href="#26-arrayprototypeshift"></a> 26. Array.prototype.shift()</h5><p><strong>shift()</strong> 方法从数组中删除第一个元素并返回已删除的元素。 此方法更改数组的长度</p><blockquote><p>arr.shift()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">var firstElement = array1.shift();</span><br><span class="line"></span><br><span class="line">console.log(array1);</span><br><span class="line">// expected output: Array [2, 3]</span><br><span class="line"></span><br><span class="line">console.log(firstElement);</span><br><span class="line">// expected output: 1</span><br></pre></td></tr></table></figure><h5 id="27-arrayprototypeslice"><a class="markdownIt-Anchor" href="#27-arrayprototypeslice"></a> 27. Array.prototype.slice()</h5><p><strong>slice()</strong> 方法将数组的一部分的浅表副本返回到从头到尾选择的新数组对象（不包括结尾），其中begin和end表示该数组中项的索引。 原始数组不会被修改</p><blockquote><p>arr.slice([begin[, end]])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var animals = [&apos;ant&apos;, &apos;bison&apos;, &apos;camel&apos;, &apos;duck&apos;, &apos;elephant&apos;];</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(2));</span><br><span class="line">// expected output: Array [&quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(2, 4));</span><br><span class="line">// expected output: Array [&quot;camel&quot;, &quot;duck&quot;]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(1, 5));</span><br><span class="line">// expected output: Array [&quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</span><br></pre></td></tr></table></figure><h5 id="28-arrayprototypesome"><a class="markdownIt-Anchor" href="#28-arrayprototypesome"></a> 28. # Array.prototype.some()</h5><p><strong>some()</strong> 方法测试数组中是否至少有一个元素通过了由提供的函数实现的测试。 它返回一个布尔值</p><blockquote><p>arr.some(callback(element[, index[, array]])[, thisArg])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var array = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">var even = function(element) &#123;</span><br><span class="line">  // checks whether an element is even</span><br><span class="line">  return element % 2 === 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(array.some(even));</span><br><span class="line">// expected output: true</span><br></pre></td></tr></table></figure><h5 id="29-arrayprototypesort"><a class="markdownIt-Anchor" href="#29-arrayprototypesort"></a> 29. Array.prototype.sort()</h5><p><strong>sort()</strong> 方法对数组中的元素进行排序并返回已排序的数组。 默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的。</p><p>由于取决于实现，因此无法保证排序的时间和空间复杂性。</p><blockquote><p>arr.sort([compareFunction])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var months = [&apos;March&apos;, &apos;Jan&apos;, &apos;Feb&apos;, &apos;Dec&apos;];</span><br><span class="line">months.sort();</span><br><span class="line">console.log(months);</span><br><span class="line">// expected output: Array [&quot;Dec&quot;, &quot;Feb&quot;, &quot;Jan&quot;, &quot;March&quot;]</span><br><span class="line"></span><br><span class="line">var array1 = [1, 30, 4, 21, 100000];</span><br><span class="line">array1.sort();</span><br><span class="line">console.log(array1);</span><br><span class="line">// expected output: Array [1, 100000, 21, 30, 4]</span><br></pre></td></tr></table></figure><h5 id="30-arrayprototypesplice"><a class="markdownIt-Anchor" href="#30-arrayprototypesplice"></a> 30. Array.prototype.splice()</h5><p><strong>splice()</strong> 方法通过删除或替换现有元素和/或在适当位置添加新元素来更改数组的内容</p><blockquote><p>var arrDeletedItems = array.splice(start[, deleteCount[, item1[, item2[, …]]]])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var months = [&apos;Jan&apos;, &apos;March&apos;, &apos;April&apos;, &apos;June&apos;];</span><br><span class="line">months.splice(1, 0, &apos;Feb&apos;);</span><br><span class="line">// inserts at index 1</span><br><span class="line">console.log(months);</span><br><span class="line">// expected output: Array [&apos;Jan&apos;, &apos;Feb&apos;, &apos;March&apos;, &apos;April&apos;, &apos;June&apos;]</span><br><span class="line"></span><br><span class="line">months.splice(4, 1, &apos;May&apos;);</span><br><span class="line">// replaces 1 element at index 4</span><br><span class="line">console.log(months);</span><br><span class="line">// expected output: Array [&apos;Jan&apos;, &apos;Feb&apos;, &apos;March&apos;, &apos;April&apos;, &apos;May&apos;]</span><br></pre></td></tr></table></figure><h5 id="31-arrayprototypeunshift"><a class="markdownIt-Anchor" href="#31-arrayprototypeunshift"></a> 31. Array.prototype.unshift()</h5><p><strong>unshift()</strong> 方法将一个或多个元素添加到数组的开头并返回数组的新长度</p><blockquote><p>arr.unshift(element1[, …[, elementN]])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">console.log(array1.unshift(4, 5));</span><br><span class="line">// expected output: 5</span><br><span class="line"></span><br><span class="line">console.log(array1);</span><br><span class="line">// expected output: Array [4, 5, 1, 2, 3]</span><br></pre></td></tr></table></figure><h5 id="32-arrayprototypevalues"><a class="markdownIt-Anchor" href="#32-arrayprototypevalues"></a> 32. Array.prototype.values()</h5><p><strong>values()</strong> 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的值</p><blockquote><p>arr.values()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">const iterator = array1.values();</span><br><span class="line"></span><br><span class="line">for (const value of iterator) &#123;</span><br><span class="line">  console.log(value); // expected output: &quot;a&quot; &quot;b&quot; &quot;c&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="33-arrayprototypetolocalestring"><a class="markdownIt-Anchor" href="#33-arrayprototypetolocalestring"></a> 33. Array.prototype.toLocaleString()</h5><p><strong>toLocaleString()</strong> 方法返回表示数组元素的字符串。 使用toLocaleString方法将元素转换为字符串，并且这些字符串由特定于语言环境的字符串（例如逗号“，”）分隔</p><blockquote><p>arr.toLocaleString([locales[, options]]);</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [1, &apos;a&apos;, new Date(&apos;21 Dec 1997 14:12:00 UTC&apos;)];</span><br><span class="line">var localeString = array1.toLocaleString(&apos;en&apos;, &#123;timeZone: &quot;UTC&quot;&#125;);</span><br><span class="line"></span><br><span class="line">console.log(localeString);</span><br><span class="line">// expected output: &quot;1,a,12/21/1997, 2:12:00 PM&quot;,</span><br><span class="line">// This assumes &quot;en&quot; locale and UTC timezone - your results may vary</span><br></pre></td></tr></table></figure><h5 id="34-arrayprototypetostring"><a class="markdownIt-Anchor" href="#34-arrayprototypetostring"></a> 34. Array.prototype.toString()</h5><p><strong>toString()</strong> 方法返回表示指定数组及其元素的字符串</p><blockquote><p>arr.toString()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [1, 2, &apos;a&apos;, &apos;1a&apos;];</span><br><span class="line"></span><br><span class="line">console.log(array1.toString());</span><br><span class="line">// expected output: &quot;1,2,a,1a&quot;</span><br></pre></td></tr></table></figure><h5 id="35-arrayprototypeiterator"><a class="markdownIt-Anchor" href="#35-arrayprototypeiterator"></a> 35. Array.prototype<a href>@@iterator</a></h5><p><strong>@@iterator</strong> 属性的初始值与values（）属性的初始值是相同的函数对象。</p><blockquote><p>arr<a href>Symbol.iterator</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];</span><br><span class="line">var eArr = arr[Symbol.iterator]();</span><br><span class="line">// your browser must support for..of loop</span><br><span class="line">// and let-scoped variables in for loops</span><br><span class="line">// const and var could also be used</span><br><span class="line">for (let letter of eArr) &#123;</span><br><span class="line">  console.log(letter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Array
    
    </summary>
    
      <category term="JavaScript" scheme="https://wzes.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript Array" scheme="https://wzes.github.io/tags/JavaScript-Array/"/>
    
  </entry>
  
  <entry>
    <title>Redux v0.2.1 源码学习</title>
    <link href="https://wzes.github.io/2019/08/25/Redux%20V0.2.1/"/>
    <id>https://wzes.github.io/2019/08/25/Redux V0.2.1/</id>
    <published>2019-08-25T11:30:16.000Z</published>
    <updated>2019-09-01T14:29:39.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>这周突然想学习一下状态管理的写法。看看业界是怎么实现的，之前使用过 redux，那就先从 redux 下手吧，但是，一上来就看最新版本的代码，不太适合新手学习，一方面最新版本已经发展n多年了，功能已经非常完善（代码多难懂），另一方面直接看最新的不了解这个工具是怎么设计出来的。于是就打算学习最早的发布版本 v0.2.1</p><p>先来说下我认识的一般的状态管理的基本路子：</p><blockquote><p>全局只存在 <strong>唯一state</strong>，而前端不直接改变 state，而是通过 <strong>action</strong> 去改变 state</p></blockquote><h3 id="helloworld"><a class="markdownIt-Anchor" href="#helloworld"></a> HelloWorld</h3><p>一个计数器的栗子，目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">counter</span><br><span class="line">├── App.js</span><br><span class="line">├── Counter.js</span><br><span class="line">├── actions</span><br><span class="line">│   ├── CounterActions.js</span><br><span class="line">│   └── index.js</span><br><span class="line">├── constants</span><br><span class="line">│   └── ActionTypes.js</span><br><span class="line">├── dispatcher.js</span><br><span class="line">└── stores</span><br><span class="line">    ├── CounterStore.js</span><br><span class="line">    └── index.js</span><br></pre></td></tr></table></figure><h4 id="actions"><a class="markdownIt-Anchor" href="#actions"></a> actions</h4><p>函数，返回一个带 type 的对象，或者返回一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  INCREMENT_COUNTER,</span><br><span class="line">  DECREMENT_COUNTER</span><br><span class="line">&#125; from &apos;../constants/ActionTypes&apos;;</span><br><span class="line"></span><br><span class="line">export function increment() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: INCREMENT_COUNTER</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function incrementAsync() &#123;</span><br><span class="line">  return dispatch =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      dispatch(increment());</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function decrement() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: DECREMENT_COUNTER</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="store"><a class="markdownIt-Anchor" href="#store"></a> store</h4><p>返回一个函数，参数 state 和 action，当 state 为空时返回初始值，表示初始化。根据 action 的 type 值，进行相应的做法，返回一个新的 state。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  INCREMENT_COUNTER,</span><br><span class="line">  DECREMENT_COUNTER</span><br><span class="line">&#125; from &apos;../constants/ActionTypes&apos;;</span><br><span class="line"></span><br><span class="line">const initialState = &#123; counter: 0 &#125;;</span><br><span class="line"></span><br><span class="line">function incremenent(&#123; counter &#125;) &#123;</span><br><span class="line">  return &#123; counter: counter + 1 &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decremenent(&#123; counter &#125;) &#123;</span><br><span class="line">  return &#123; counter: counter - 1 &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function CounterStore(state, action) &#123;</span><br><span class="line">  if (!state) &#123;</span><br><span class="line">    return initialState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">  case INCREMENT_COUNTER:</span><br><span class="line">    return incremenent(state, action);</span><br><span class="line">  case DECREMENT_COUNTER:</span><br><span class="line">    return decremenent(state, action);</span><br><span class="line">  default:</span><br><span class="line">    return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入口 App.js 你会发现 @provides(dispatcher) 这个奇怪的东西，在 React 里面还经常出现，装饰器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import Counter from &apos;./Counter&apos;;</span><br><span class="line">import &#123; provides &#125; from &apos;redux&apos;;</span><br><span class="line">import dispatcher from &apos;./dispatcher&apos;;</span><br><span class="line"></span><br><span class="line">@provides(dispatcher)</span><br><span class="line">export default class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Counter /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Couter.js，同样，也出现 performs（方法），observes（观察者）等关键字。使用 state 直接使用 this.props 解构赋值即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123; performs, observes &#125; from &apos;redux&apos;;</span><br><span class="line"></span><br><span class="line">@performs(&apos;increment&apos;, &apos;decrement&apos;)</span><br><span class="line">@observes(&apos;CounterStore&apos;)</span><br><span class="line">export default class Counter &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; increment, decrement &#125; = this.props;</span><br><span class="line">    return (</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        Clicked: &#123;this.props.counter&#125; times</span><br><span class="line">        &#123;&apos; &apos;&#125;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; increment()&#125;&gt;+&lt;/button&gt;</span><br><span class="line">        &#123;&apos; &apos;&#125;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; decrement()&#125;&gt;-&lt;/button&gt;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些关键字是早起 Redux 状态管理的关键，现在的版本应该已经不使用这种方式了。</p><h3 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h3><h4 id="dispatcher"><a class="markdownIt-Anchor" href="#dispatcher"></a> dispatcher</h4><p>通过 provides 将 dispatcher 注入到 App 中，其中，dispatcher 是通过 createDispatcher 创建，并调用了 dispatcher.receive(stores, actions) 进行绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import * as stores from &apos;./stores/index&apos;;</span><br><span class="line">import * as actions from &apos;./actions/index&apos;;</span><br><span class="line">import &#123; createDispatcher &#125; from &apos;redux&apos;;</span><br><span class="line"></span><br><span class="line">const dispatcher =</span><br><span class="line">  module.hot &amp;&amp; module.hot.data &amp;&amp; module.hot.data.dispatcher ||</span><br><span class="line">  createDispatcher();</span><br><span class="line"></span><br><span class="line">dispatcher.receive(stores, actions);</span><br><span class="line"></span><br><span class="line">module.hot.dispose(data =&gt; &#123;</span><br><span class="line">  data.dispatcher = dispatcher;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default dispatcher;</span><br></pre></td></tr></table></figure><p>receive 方法，actionCreator 将 action 进行封装，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Provide a way to receive new stores and actions</span><br><span class="line">  function receive(nextStores, nextActionCreators) &#123;</span><br><span class="line">    stores = nextStores;</span><br><span class="line">    actionCreators = mapValues(nextActionCreators, wrapActionCreator);</span><br><span class="line"></span><br><span class="line">    // Merge the observers</span><br><span class="line">    observers = mapValues(stores,</span><br><span class="line">      (store, key) =&gt; observers[key] || []</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // Dispatch to initialize stores</span><br><span class="line">    if (currentTransaction) &#123;</span><br><span class="line">      updateState(committedState);</span><br><span class="line">      currentTransaction.forEach(dispatch);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      dispatch(BOOTSTRAP_STORE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>action 进行转化返回一个 dispatchAction 函数，如果 action 为函数，则先执行函数，把 dispatchInTransaction 作为参数传入，这样可以在 action 内部使用该函数了，否则使用 dispatchInTransaction 函数调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Bind action creator to the dispatcher</span><br><span class="line"> function wrapActionCreator(actionCreator) &#123;</span><br><span class="line">   return function dispatchAction(...args) &#123;</span><br><span class="line">     const action = actionCreator(...args);</span><br><span class="line">     if (typeof action === &apos;function&apos;) &#123;</span><br><span class="line">       // Async action creator</span><br><span class="line">       action(dispatchInTransaction);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       // Sync action creator</span><br><span class="line">       dispatchInTransaction(action);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>dispatchInTransaction ，执行 dispatch ，计算 nextState，执行 updateState 更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  // Dispatch in the context of current transaction</span><br><span class="line">  function dispatchInTransaction(action) &#123;</span><br><span class="line">    if (currentTransaction) &#123;</span><br><span class="line">      currentTransaction.push(action);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(action);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// Reassign the current state on each dispatch</span><br><span class="line">  function dispatch(action) &#123;</span><br><span class="line">    if (typeof action.type !== &apos;string&apos;) &#123;</span><br><span class="line">      throw new Error(&apos;Action type must be a string.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const nextState = computeNextState(currentState, action);</span><br><span class="line">    updateState(nextState);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>获取 store，也就是 CounterStore，把参数传入，获取新的 state</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// To compute the next state, combine the next states of every store</span><br><span class="line">function computeNextState(state, action) &#123;</span><br><span class="line">  return mapValues(stores,</span><br><span class="line">    (store, key) =&gt; store(state[key], action)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>updateState 实现，计算变化的 changedKeys，执行  emitChange 进行更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Update state and emit change if needed</span><br><span class="line">function updateState(nextState) &#123;</span><br><span class="line">  // Swap the state</span><br><span class="line">  const previousState = currentState;</span><br><span class="line">  currentState = nextState;</span><br><span class="line"></span><br><span class="line">  // Notify the observers</span><br><span class="line">  const changedKeys = Object.keys(currentState).filter(key =&gt;</span><br><span class="line">    currentState[key] !== previousState[key]</span><br><span class="line">  );</span><br><span class="line">  emitChange(changedKeys);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emitChange，获取需要通知的 observers，调用通知函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Notify observers about the changed stores</span><br><span class="line">  function emitChange(changedKeys) &#123;</span><br><span class="line">    if (!changedKeys.length) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Gather the affected observers</span><br><span class="line">    const notifyObservers = [];</span><br><span class="line">    changedKeys.forEach(key =&gt; &#123;</span><br><span class="line">      observers[key].forEach(o =&gt; &#123;</span><br><span class="line">        if (notifyObservers.indexOf(o) === -1) &#123;</span><br><span class="line">          notifyObservers.push(o);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Emit change</span><br><span class="line">    notifyObservers.forEach(o =&gt; o());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里可能有点疑问，obersevers 是什么，从哪来？往下看～</p><h4 id="observesjs"><a class="markdownIt-Anchor" href="#observesjs"></a> observes.js</h4><p>将 组件进行装饰，构造函数中有一个</p><blockquote><p>this.unobserve = this.context.observeStores(storeKeys, this.handleChange);<br>context 就是 dispatcher，</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;</span><br><span class="line">import pick from &apos;lodash/object/pick&apos;;</span><br><span class="line">import identity from &apos;lodash/utility/identity&apos;;</span><br><span class="line"></span><br><span class="line">const contextTypes = &#123;</span><br><span class="line">  observeStores: PropTypes.func.isRequired</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default function connect(...storeKeys) &#123;</span><br><span class="line">  let mapState = identity;</span><br><span class="line"></span><br><span class="line">  // Last argument may be a custom mapState function</span><br><span class="line">  const lastIndex = storeKeys.length - 1;</span><br><span class="line">  if (typeof storeKeys[lastIndex] === &apos;function&apos;) &#123;</span><br><span class="line">    [mapState] = storeKeys.splice(lastIndex, 1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return function (DecoratedComponent) &#123;</span><br><span class="line">    const wrappedDisplayName =</span><br><span class="line">      DecoratedComponent.displayName ||</span><br><span class="line">      DecoratedComponent.name ||</span><br><span class="line">      &apos;Component&apos;;</span><br><span class="line"></span><br><span class="line">    return class extends Component &#123;</span><br><span class="line">      static displayName = `ReduxObserves($&#123;wrappedDisplayName&#125;)`;</span><br><span class="line">      static contextTypes = contextTypes;</span><br><span class="line"></span><br><span class="line">      constructor(props, context) &#123;</span><br><span class="line">        super(props, context);</span><br><span class="line">        this.handleChange = this.handleChange.bind(this);</span><br><span class="line">        this.unobserve = this.context.observeStores(storeKeys, this.handleChange);</span><br><span class="line">      &#125;</span><br><span class="line">      ....</span><br><span class="line"></span><br><span class="line">      componentWillUnmount() &#123;</span><br><span class="line">        this.unobserve();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      render() &#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;DecoratedComponent &#123;...this.props&#125;</span><br><span class="line">                              &#123;...this.state&#125; /&gt;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatcher observeStores 方法，将需要监听的组件传入，以及 onChange 函数，作为回调使用。最后返回一个函数，移除监听，这个也太妙了吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Provide subscription and unsubscription</span><br><span class="line">  function observeStores(observedKeys, onChange) &#123;</span><br><span class="line">    // Emit the state update</span><br><span class="line">    function handleChange() &#123;</span><br><span class="line">      onChange(currentState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Synchronously emit the initial value</span><br><span class="line">    handleChange();</span><br><span class="line"></span><br><span class="line">    // Register the observer for each relevant key</span><br><span class="line">    observedKeys.forEach(key =&gt;</span><br><span class="line">      observers[key].push(handleChange)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // Let it unregister when the time comes</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      observedKeys.forEach(key =&gt; &#123;</span><br><span class="line">        const index = observers[key].indexOf(handleChange);</span><br><span class="line">        observers[key].splice(index, 1);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当计算好 nextState 后，就会调用 observe 的 onChange 方法， onChange 方法也就是 装饰器里面的方法。最后调用自身的 updateState，使用 setState 进行组件更新。而这些 state 作为 props 传入了我们自己的组件，也就可以通过 this.props  拿到。完美～～～</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">handleChange(stateFromStores) &#123;</span><br><span class="line">  this.currentStateFromStores = pick(stateFromStores, storeKeys);</span><br><span class="line">  this.updateState(stateFromStores, this.props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  this.updateState(this.currentStateFromStores, nextProps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updateState(stateFromStores, props) &#123;</span><br><span class="line">  if (storeKeys.length === 1) &#123;</span><br><span class="line">    // Just give it the particular store state for convenience</span><br><span class="line">    stateFromStores = stateFromStores[storeKeys[0]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const state = mapState(stateFromStores, props);</span><br><span class="line">  if (this.state) &#123;</span><br><span class="line">    this.setState(state);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    this.state = state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="performs-组件"><a class="markdownIt-Anchor" href="#performs-组件"></a> performs 组件</h4><p>action 绑定到组件，可以通过 this.props ，通过 this.context.getActions() 拿到 actions</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;</span><br><span class="line">import pick from &apos;lodash/object/pick&apos;;</span><br><span class="line">import identity from &apos;lodash/utility/identity&apos;;</span><br><span class="line"></span><br><span class="line">const contextTypes = &#123;</span><br><span class="line">  getActions: PropTypes.func.isRequired</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default function performs(...actionKeys) &#123;</span><br><span class="line">  let mapActions = identity;</span><br><span class="line"></span><br><span class="line">  // Last argument may be a custom mapState function</span><br><span class="line">  const lastIndex = actionKeys.length - 1;</span><br><span class="line">  if (typeof actionKeys[lastIndex] === &apos;function&apos;) &#123;</span><br><span class="line">    [mapActions] = actionKeys.splice(lastIndex, 1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return function (DecoratedComponent) &#123;</span><br><span class="line">    const wrappedDisplayName =</span><br><span class="line">      DecoratedComponent.displayName ||</span><br><span class="line">      DecoratedComponent.name ||</span><br><span class="line">      &apos;Component&apos;;</span><br><span class="line"></span><br><span class="line">    return class extends Component &#123;</span><br><span class="line">      static displayName = `ReduxPerforms($&#123;wrappedDisplayName&#125;)`;</span><br><span class="line">      static contextTypes = contextTypes;</span><br><span class="line"></span><br><span class="line">      constructor(props, context) &#123;</span><br><span class="line">        super(props, context);</span><br><span class="line">        this.updateActions(props);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">        this.updateActions(nextProps);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      updateActions(props) &#123;</span><br><span class="line">        this.actions = mapActions(</span><br><span class="line">          pick(this.context.getActions(), actionKeys),</span><br><span class="line">          props</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      render() &#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;DecoratedComponent &#123;...this.props&#125;</span><br><span class="line">                              &#123;...this.actions&#125; /&gt;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就差不多了～<br>额外收获</p><h4 id="lodash"><a class="markdownIt-Anchor" href="#lodash"></a> Lodash</h4><ul><li><p>pick</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var object = &#123; &apos;user&apos;: &apos;fred&apos;, &apos;age&apos;: 40 &#125;;</span><br><span class="line">_.pick(object, &apos;user&apos;);</span><br><span class="line">// =&gt; &#123; &apos;user&apos;: &apos;fred&apos; &#125;</span><br><span class="line">_.pick(object, _.isString);</span><br><span class="line">// =&gt; &#123; &apos;user&apos;: &apos;fred&apos; &#125;</span><br></pre></td></tr></table></figure></li><li><p>identity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function identity(value) &#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mapValues</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_.mapValues(&#123; &apos;a&apos;: 1, &apos;b&apos;: 2 &#125;, function(n) &#123;</span><br><span class="line"> return n * 3;</span><br><span class="line">&#125;);</span><br><span class="line">// =&gt; &#123; &apos;a&apos;: 3, &apos;b&apos;: 6 &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h3><p>麻雀虽小，却能看透精髓～</p>]]></content>
    
    <summary type="html">
    
      React Redux
    
    </summary>
    
      <category term="JavaScript" scheme="https://wzes.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://wzes.github.io/tags/JavaScript/"/>
    
      <category term="React" scheme="https://wzes.github.io/tags/React/"/>
    
      <category term="Redux" scheme="https://wzes.github.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>KoaJs 源码解析</title>
    <link href="https://wzes.github.io/2019/08/18/KoaJs/"/>
    <id>https://wzes.github.io/2019/08/18/KoaJs/</id>
    <published>2019-08-18T10:56:00.000Z</published>
    <updated>2019-09-01T14:30:02.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>又是一周过去了，常规学习不能断！但是选择什么主题呢？一时间不知道选什么好，于是又想起简单的 <strong>koajs</strong> 非常愉快的就选择他了 <a href="https://koajs.com/" target="_blank" rel="noopener">https://koajs.com/</a>，了解一下？</p><p>他是个什么东西呢？</p><blockquote><p>Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。</p></blockquote><h3 id="hello-world"><a class="markdownIt-Anchor" href="#hello-world"></a> hello world</h3><p>首先新建一个 node 项目，其实很简单，只需要一个 package.json 文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;koa-hello&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;node src/index.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;koa&quot;: &quot;^2.7.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i koa</span><br></pre></td></tr></table></figure><p>代码 index.js 文件，新建一个 koa 实例，使用 app.use 写一个 async 方法，设置 ctx.body 的值就可以了。最后使用 app.listen 启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">const app = new Koa();</span><br><span class="line"></span><br><span class="line">app.use(async ctx =&gt; &#123;</span><br><span class="line">    ctx.body = &apos;Hello World&apos;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure><p>这样的话，一个 web 服务器就搭建好了，访问 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 就会得到 hello world 返回结果了。你可以尝试更改字段从而得到不同的返回结果。</p><h3 id="源码解析"><a class="markdownIt-Anchor" href="#源码解析"></a> 源码解析</h3><p>koa 的源码只有四个文件，不包含其他引用的话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> .</span><br><span class="line">├── History.md</span><br><span class="line">├── LICENSE</span><br><span class="line">├── Readme.md</span><br><span class="line">├── lib</span><br><span class="line">│   ├── application.js</span><br><span class="line">│   ├── context.js</span><br><span class="line">│   ├── request.js</span><br><span class="line">│   └── response.js</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure><p>主入口可以在 package.json 的 main 中得到，是 application.js，暂时先知道 middleware 是中间接，通常一个请求过来就会依次执行中间件的方法。</p><h4 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">module.exports = class Application extends Emitter &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Initialize a new `Application`.</span><br><span class="line">   *</span><br><span class="line">   * @api public</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line"></span><br><span class="line">    this.proxy = false;</span><br><span class="line">    this.middleware = [];</span><br><span class="line">    this.subdomainOffset = 2;</span><br><span class="line">    this.env = process.env.NODE_ENV || &apos;development&apos;;</span><br><span class="line">    this.context = Object.create(context);</span><br><span class="line">    this.request = Object.create(request);</span><br><span class="line">    this.response = Object.create(response);</span><br><span class="line">    if (util.inspect.custom) &#123;</span><br><span class="line">      this[util.inspect.custom] = this.inspect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app.use 其实就是添加一个中间件，我们通常使用 async 的函数，generator 被抛弃了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use(fn) &#123;</span><br><span class="line">  if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;middleware must be a function!&apos;);</span><br><span class="line">  if (isGeneratorFunction(fn)) &#123;</span><br><span class="line">    deprecate(&apos;Support for generators will be removed in v3. &apos; +</span><br><span class="line">              &apos;See the documentation for examples of how to convert old middleware &apos; +</span><br><span class="line">              &apos;https://github.com/koajs/koa/blob/master/docs/migration.md&apos;);</span><br><span class="line">    fn = convert(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  debug(&apos;use %s&apos;, fn._name || fn.name || &apos;-&apos;);</span><br><span class="line">  this.middleware.push(fn);</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app.listen 创建一个服务器，监听 3000 端口，http.createServer 是 node 的服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listen(...args) &#123;</span><br><span class="line">  debug(&apos;listen&apos;);</span><br><span class="line">  const server = http.createServer(this.callback());</span><br><span class="line">  return server.listen(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>callback 是提供一个函数，所有请求都会走到这个函数里面进行处理。每次请求过来都会调用这个函数，所以，我们可以看到，每次请求都会创建一个 ctx 的对象。<br>compose 的作用就是将所有的中间件整合成一个函数，使用 next 函数继续调用下一个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">callback() &#123;</span><br><span class="line">  const fn = compose(this.middleware);</span><br><span class="line"></span><br><span class="line">  if (!this.listenerCount(&apos;error&apos;)) this.on(&apos;error&apos;, this.onerror);</span><br><span class="line"></span><br><span class="line">  const handleRequest = (req, res) =&gt; &#123;</span><br><span class="line">    const ctx = this.createContext(req, res);</span><br><span class="line">    return this.handleRequest(ctx, fn);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return handleRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化 ctx 对象，这里 this.request 将会把原生的 request 参数进行解析，方便我们进行相关参数获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Initialize a new context.</span><br><span class="line"> *</span><br><span class="line"> * @api private</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">createContext(req, res) &#123;</span><br><span class="line">  const context = Object.create(this.context);</span><br><span class="line">  const request = context.request = Object.create(this.request);</span><br><span class="line">  const response = context.response = Object.create(this.response);</span><br><span class="line">  context.app = request.app = response.app = this;</span><br><span class="line">  context.req = request.req = response.req = req;</span><br><span class="line">  context.res = request.res = response.res = res;</span><br><span class="line">  request.ctx = response.ctx = context;</span><br><span class="line">  request.response = response;</span><br><span class="line">  response.request = request;</span><br><span class="line">  context.originalUrl = request.originalUrl = req.url;</span><br><span class="line">  context.state = &#123;&#125;;</span><br><span class="line">  return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们之后就可以使用<br>** ctx.query.key ** 来获取 <a href="http://localhost:3000?key=value%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">http://localhost:3000?key=value，为什么可以使用</a> ctx.query 又可以获取参数呢，这个要靠 Object.create 的本事了，它相当于创造了一个对象，继承了原来的对象，而 this.request 有 query 的参数，而最为重要的是 this.context = Object.create(context); context 委托（使用了 Delegator）了这些 request 的相关属性和方法。【第一次体会到 js 委托，以前知识听说不知道是啥】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Request delegation.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">delegate(proto, &apos;request&apos;)</span><br><span class="line">  .access(&apos;method&apos;)</span><br><span class="line">  .access(&apos;query&apos;)</span><br><span class="line">  .access(&apos;path&apos;)</span><br><span class="line">  .access(&apos;url&apos;)</span><br><span class="line">  ....... // 省略</span><br></pre></td></tr></table></figure><p>handleRequest 请求处理，fnMiddleware 就是所有的中间件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">  const res = ctx.res;</span><br><span class="line">  res.statusCode = 404;</span><br><span class="line">  const onerror = err =&gt; ctx.onerror(err);</span><br><span class="line">  const handleResponse = () =&gt; respond(ctx);</span><br><span class="line">  onFinished(res, onerror);</span><br><span class="line">  return fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用完中间件以后，就执行 handleResponse 将数据返回，返回数据也就是将 ctx.body 拿出来，使用 response.end 返回数据，返回时，会对数据进行处理，在最后面可以体会到～</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Response helper.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">function respond(ctx) &#123;</span><br><span class="line">  // allow bypassing koa</span><br><span class="line">  if (false === ctx.respond) return;</span><br><span class="line"></span><br><span class="line">  if (!ctx.writable) return;</span><br><span class="line"></span><br><span class="line">  const res = ctx.res;</span><br><span class="line">  let body = ctx.body;</span><br><span class="line">  const code = ctx.status;</span><br><span class="line"></span><br><span class="line">  // ignore body</span><br><span class="line">  if (statuses.empty[code]) &#123;</span><br><span class="line">    // strip headers</span><br><span class="line">    ctx.body = null;</span><br><span class="line">    return res.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (&apos;HEAD&apos; == ctx.method) &#123;</span><br><span class="line">    if (!res.headersSent &amp;&amp; isJSON(body)) &#123;</span><br><span class="line">      ctx.length = Buffer.byteLength(JSON.stringify(body));</span><br><span class="line">    &#125;</span><br><span class="line">    return res.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // status body</span><br><span class="line">  if (null == body) &#123;</span><br><span class="line">    if (ctx.req.httpVersionMajor &gt;= 2) &#123;</span><br><span class="line">      body = String(code);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      body = ctx.message || String(code);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!res.headersSent) &#123;</span><br><span class="line">      ctx.type = &apos;text&apos;;</span><br><span class="line">      ctx.length = Buffer.byteLength(body);</span><br><span class="line">    &#125;</span><br><span class="line">    return res.end(body);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // responses</span><br><span class="line">  if (Buffer.isBuffer(body)) return res.end(body);</span><br><span class="line">  if (&apos;string&apos; == typeof body) return res.end(body);</span><br><span class="line">  if (body instanceof Stream) return body.pipe(res);</span><br><span class="line"></span><br><span class="line">  // body: json</span><br><span class="line">  body = JSON.stringify(body);</span><br><span class="line">  if (!res.headersSent) &#123;</span><br><span class="line">    ctx.length = Buffer.byteLength(body);</span><br><span class="line">  &#125;</span><br><span class="line">  res.end(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，基本的请求已经清楚了～～</p><h4 id="end"><a class="markdownIt-Anchor" href="#end"></a> End</h4><p>再来看一眼最简单的 http server 代码，对比一下，比 koa 代码的 hello world 相比并没有多复杂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">http.createServer(function (req, res) &#123;</span><br><span class="line">  res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;);</span><br><span class="line">  res.write(&apos;Hello World!&apos;);</span><br><span class="line">  res.end();</span><br><span class="line">&#125;).listen(8080);</span><br></pre></td></tr></table></figure><p>但是，获取参数，使用路由等等插件，koa 生态做了很多，非常方便，快来体验吧！</p>]]></content>
    
    <summary type="html">
    
      Node Server
    
    </summary>
    
      <category term="JavaScript" scheme="https://wzes.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://wzes.github.io/tags/JavaScript/"/>
    
      <category term="Node" scheme="https://wzes.github.io/tags/Node/"/>
    
      <category term="Koa" scheme="https://wzes.github.io/tags/Koa/"/>
    
  </entry>
  
  <entry>
    <title>Babel-Loader 自定义入门</title>
    <link href="https://wzes.github.io/2019/08/04/Babel%20Loader/"/>
    <id>https://wzes.github.io/2019/08/04/Babel Loader/</id>
    <published>2019-08-04T05:42:00.000Z</published>
    <updated>2019-09-01T14:30:22.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>突然觉得 babel-loader <a href="https://github.com/babel/babel-loader" target="_blank" rel="noopener">https://github.com/babel/babel-loader</a> 很好玩，比较贴近AST，然而编译原理一直是噩梦，没学懂，好在这东西不需要什么编译原理的知识。但还是涉及到语法解析等操作，所以拿过来学一学还是挺好的。</p><h3 id="什么是-babel"><a class="markdownIt-Anchor" href="#什么是-babel"></a> 什么是 Babel</h3><p>Babel 是一个工具链，主要用于将 ECMAScript 2015+ 代码转换为当前和旧版浏览器或环境中的向后兼容版本的 JavaScript。 以下是 Babel 可以为您做的主要事情：</p><ul><li>转换语法</li><li>目标环境中缺少Polyfill功能（通过@ babel / polyfill）源代码转换（codemods）</li><li>更多</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Babel Input: ES2015 arrow function</span><br><span class="line">[1, 2, 3].map((n) =&gt; n + 1);</span><br><span class="line"></span><br><span class="line">// Babel Output: ES5 equivalent</span><br><span class="line">[1, 2, 3].map(function(n) &#123;</span><br><span class="line">  return n + 1;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>代码转化就涉及到了语法解析，这便是我们的重点</p><h3 id="自定义"><a class="markdownIt-Anchor" href="#自定义"></a> 自定义</h3><p>首先新建一个项目 webpack 项目 <a href="https://github.com/wzes/babel-demo" target="_blank" rel="noopener">babel-demo</a><br>目录结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── babel-plugin-transform-class</span><br><span class="line">│   └── index.js</span><br><span class="line">├── dist</span><br><span class="line">│   └── bundle.js</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br><span class="line">│   └── index.js</span><br><span class="line">└── webpack.config.js</span><br></pre></td></tr></table></figure><p>新建 package.json 并使用 npm install 安装所需插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D babel-loader @babel/core @babel/preset-env webpack</span><br></pre></td></tr></table></figure><p><strong>package.json</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;&#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;@babel/core&quot;: &quot;^7.5.5&quot;,</span><br><span class="line">    &quot;@babel/preset-env&quot;: &quot;^7.5.5&quot;,</span><br><span class="line">    &quot;babel-loader&quot;: &quot;^8.0.6&quot;,</span><br><span class="line">    &quot;webpack&quot;: &quot;^4.39.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建 webpack 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;,</span><br><span class="line">  mode: &apos;development&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        loader: &apos;babel-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          plugins: [</span><br><span class="line">            &quot;transform-class&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>module 里面的 rule 便是配置我们自定义的 babel 插件，<strong>transform-class</strong> 是插件名。</p><h3 id="手写插件"><a class="markdownIt-Anchor" href="#手写插件"></a> 手写插件</h3><p>下面是一个简单的插件<br>babel-plugin-transform-class/index.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// A plugin is just a function</span><br><span class="line">module.exports = function (&#123; types: t &#125;) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">      visitor: &#123;</span><br><span class="line">          Identifier(path) &#123;</span><br><span class="line">            let name = path.node.name; // reverse the name: JavaScript -&gt; tpircSavaJ</span><br><span class="line">            path.node.name = name.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 babel-plugin-transform-class 文件夹移动到 node-modules 目录下即可。当运行 webpack 的时候，便会运行这个插件，这个插件会把 node 的 name 做反转。</p><p>我们的 demo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function babel() &#123;</span><br><span class="line">  let javascript = &apos;hello babel&apos;;</span><br><span class="line">  console.log(javascript);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(&quot;function lebab() &#123;\n  let tpircsavaj = &apos;hello babel&apos;;\n  elosnoc.gol(tpircsavaj);\n&#125;\n\n//# sourceURL=webpack:///./src/index.js?&quot;);</span><br></pre></td></tr></table></figure><p>我们看到变量名都反转了。</p><p>我们还可以实现更多·····更多属性，方法在这里 <a href="https://babeljs.io/docs/en/next/babel-types.html" target="_blank" rel="noopener">https://babeljs.io/docs/en/next/babel-types.html</a></p><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h3><p>AST <a href="https://astexplorer.net/" target="_blank" rel="noopener">https://astexplorer.net/</a></p>]]></content>
    
    <summary type="html">
    
      Babel
    
    </summary>
    
      <category term="JavaScript Node" scheme="https://wzes.github.io/categories/JavaScript-Node/"/>
    
    
      <category term="JavaScript Babel" scheme="https://wzes.github.io/tags/JavaScript-Babel/"/>
    
  </entry>
  
  <entry>
    <title>React Lazyload 源码解析</title>
    <link href="https://wzes.github.io/2019/07/28/React%20Lazyload/"/>
    <id>https://wzes.github.io/2019/07/28/React Lazyload/</id>
    <published>2019-07-28T03:59:00.000Z</published>
    <updated>2019-09-01T14:30:38.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>早在多年前，lazyload 已经出现了，懒加载在前端里边同样具有十分重要的意义。react-lazyload 的作用是当组件未出现在屏幕内时，不去挂载该组件，而是使用 placeholder 去渲染，让滚动使内容出现后，组件会被挂载。就是这么简单！例如，一个复杂的组件（非首屏内容），使用了懒加载后，渲染首屏就会节省很多资源，从而减少首屏渲染时间。</p><h3 id="demo"><a class="markdownIt-Anchor" href="#demo"></a> Demo</h3><p>源码地址 <a href="https://github.com/twobin/react-lazyload" target="_blank" rel="noopener">react-lazyload</a><br>Demo地址 <a href="https://twobin.github.io/react-lazyload/examples/" target="_blank" rel="noopener">Demo</a></p><h4 id="helloworld"><a class="markdownIt-Anchor" href="#helloworld"></a> HelloWorld</h4><p>将需要懒加载的组件使用 LazyLoad 包裹即可，最好使用 height 进行站位，否则该组件位置将会为 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;LazyLoad height=&#123;200&#125;&gt;</span><br><span class="line">    &lt;img src=&quot;tiger.jpg&quot; /&gt; /*</span><br><span class="line">                              Lazy loading images is supported out of box,</span><br><span class="line">                              no extra config needed, set `height` for better</span><br><span class="line">                              experience</span><br><span class="line">                             */</span><br><span class="line">  &lt;/LazyLoad&gt;</span><br></pre></td></tr></table></figure><h3 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h3><p>从源码角度分析～</p><h4 id="一览核心"><a class="markdownIt-Anchor" href="#一览核心"></a> 一览核心</h4><p>本小节摘取了最核心的代码，目的在于对 LazyLoad 组件有个最核心的认识，它的核心就是监听滚动事件，检查组件是否在屏幕内，如果在的话就显示，不在的话就不显示～</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class LazyLoad extends Component &#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">   on(scrollport, &apos;scroll&apos;, finalLazyLoadHandler, passiveEvent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return this.visible ?</span><br><span class="line">           this.props.children :</span><br><span class="line">             this.props.placeholder ?</span><br><span class="line">                this.props.placeholder :</span><br><span class="line">                &lt;div style=&#123;&#123; height: this.props.height &#125;&#125; className=&quot;lazyload-placeholder&quot; ref=&#123;this.setRef&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LazyLoad 的属性，透过属性，我们可以知道它大概有些什么功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">LazyLoad.propTypes = &#123;</span><br><span class="line">  once: PropTypes.bool,</span><br><span class="line">  height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),</span><br><span class="line">  offset: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),</span><br><span class="line">  overflow: PropTypes.bool, // 不是 window 滚动，而使用了 overflow: scroll </span><br><span class="line">  resize: PropTypes.bool, // 是否监听 resize</span><br><span class="line">  scroll: PropTypes.bool, // 是否监听滚动</span><br><span class="line">  children: PropTypes.node,</span><br><span class="line">  throttle: PropTypes.oneOfType([PropTypes.number, PropTypes.bool]),</span><br><span class="line">  debounce: PropTypes.oneOfType([PropTypes.number, PropTypes.bool]),</span><br><span class="line">  placeholder: PropTypes.node,</span><br><span class="line">  scrollContainer: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),</span><br><span class="line">  unmountIfInvisible: PropTypes.bool,</span><br><span class="line">  preventLoading: PropTypes.bool</span><br><span class="line">&#125;;</span><br><span class="line">// 默认值</span><br><span class="line">LazyLoad.defaultProps = &#123;</span><br><span class="line">  once: false,</span><br><span class="line">  offset: 0,</span><br><span class="line">  overflow: false,</span><br><span class="line">  resize: false,</span><br><span class="line">  scroll: true,</span><br><span class="line">  unmountIfInvisible: false,</span><br><span class="line">  preventLoading: false,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完整的 componentDidMount，scrollport 是滚动试图，默认是 window，如果 props 传入了 scrollContainer，那么滚动试图将是自定义的。needResetFinalLazyLoadHandler 是控制是否重置滚动监听。debounce 和 throttle 分别是用来控制滚动事件的监听触发频率，默认都是 undefine，needResetFinalLazyLoadHandler 初始值为 false。finalLazyLoadHandler 初始值也为 undefine，而 overflow 也为 false，scroll 为 true，listeners 是需要懒加载的组件集合，初始大小肯定为0，componentDidMount 最后才会进行添加，因此最终会走到 **on(scrollport, ‘scroll’, finalLazyLoadHandler, passiveEvent)，事件只需要一次绑定即可。<br>**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    // It&apos;s unlikely to change delay type on the fly, this is mainly</span><br><span class="line">    // designed for tests</span><br><span class="line">    let scrollport = window;</span><br><span class="line">    const &#123;</span><br><span class="line">      scrollContainer,</span><br><span class="line">    &#125; = this.props;</span><br><span class="line">    if (scrollContainer) &#123;</span><br><span class="line">      if (isString(scrollContainer)) &#123;</span><br><span class="line">        scrollport = scrollport.document.querySelector(scrollContainer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const needResetFinalLazyLoadHandler = (this.props.debounce !== undefined &amp;&amp; delayType === &apos;throttle&apos;)</span><br><span class="line">      || (delayType === &apos;debounce&apos; &amp;&amp; this.props.debounce === undefined);</span><br><span class="line"></span><br><span class="line">    if (needResetFinalLazyLoadHandler) &#123;</span><br><span class="line">      off(scrollport, &apos;scroll&apos;, finalLazyLoadHandler, passiveEvent);</span><br><span class="line">      off(window, &apos;resize&apos;, finalLazyLoadHandler, passiveEvent);</span><br><span class="line">      finalLazyLoadHandler = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!finalLazyLoadHandler) &#123;</span><br><span class="line">      if (this.props.debounce !== undefined) &#123;</span><br><span class="line">        finalLazyLoadHandler = debounce(lazyLoadHandler, typeof this.props.debounce === &apos;number&apos; ?</span><br><span class="line">                                                         this.props.debounce :</span><br><span class="line">                                                         300);</span><br><span class="line">        delayType = &apos;debounce&apos;;</span><br><span class="line">      &#125; else if (this.props.throttle !== undefined) &#123;</span><br><span class="line">        finalLazyLoadHandler = throttle(lazyLoadHandler, typeof this.props.throttle === &apos;number&apos; ?</span><br><span class="line">                                                         this.props.throttle :</span><br><span class="line">                                                         300);</span><br><span class="line">        delayType = &apos;throttle&apos;;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        finalLazyLoadHandler = lazyLoadHandler;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.props.overflow) &#123;</span><br><span class="line">      const parent = scrollParent(this.ref);</span><br><span class="line">      if (parent &amp;&amp; typeof parent.getAttribute === &apos;function&apos;) &#123;</span><br><span class="line">        const listenerCount = 1 + (+parent.getAttribute(LISTEN_FLAG));</span><br><span class="line">        if (listenerCount === 1) &#123;</span><br><span class="line">          parent.addEventListener(&apos;scroll&apos;, finalLazyLoadHandler, passiveEvent);</span><br><span class="line">        &#125;</span><br><span class="line">        parent.setAttribute(LISTEN_FLAG, listenerCount);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (listeners.length === 0 || needResetFinalLazyLoadHandler) &#123;</span><br><span class="line">      const &#123; scroll, resize &#125; = this.props;</span><br><span class="line"></span><br><span class="line">      if (scroll) &#123;</span><br><span class="line">        on(scrollport, &apos;scroll&apos;, finalLazyLoadHandler, passiveEvent);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (resize) &#123;</span><br><span class="line">        on(window, &apos;resize&apos;, finalLazyLoadHandler, passiveEvent);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listeners.push(this);</span><br><span class="line">    checkVisible(this);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通常 finalLazyLoadHandler 就是 lazyLoadHandler，不会对滚动事件进行 debounce 或 throttle，我们一般为了性能，会使用 throttle 进行处理。函数会对每一个懒加载组件进行 checkVisible，之后会移除 once component</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const lazyLoadHandler = () =&gt; &#123;</span><br><span class="line">  for (let i = 0; i &lt; listeners.length; ++i) &#123;</span><br><span class="line">    const listener = listeners[i];</span><br><span class="line">    checkVisible(listener);</span><br><span class="line">  &#125;</span><br><span class="line">  // Remove `once` component in listeners</span><br><span class="line">  purgePending();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>checkVisible，检查组件是否出现在 viewport 中，如果出现了就吧 visible 设置为 true，当然如果设置了 unmountIfInvisible = true，那么不可见时组件将被移除，如果之前已经渲染了，需要避免再次渲染。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const checkVisible = function checkVisible(component) &#123;</span><br><span class="line">  const node = component.ref;</span><br><span class="line">  if (!(node instanceof HTMLElement)) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const parent = scrollParent(node);</span><br><span class="line">  const isOverflow = component.props.overflow &amp;&amp;</span><br><span class="line">                     parent !== node.ownerDocument &amp;&amp;</span><br><span class="line">                     parent !== document &amp;&amp;</span><br><span class="line">                     parent !== document.documentElement;</span><br><span class="line">  const visible = isOverflow ?</span><br><span class="line">                  checkOverflowVisible(component, parent) :</span><br><span class="line">                  checkNormalVisible(component);</span><br><span class="line">  if (visible) &#123;</span><br><span class="line">    // Avoid extra render if previously is visible</span><br><span class="line">    if (!component.visible &amp;&amp; !component.preventLoading) &#123;</span><br><span class="line">      if (component.props.once) &#123;</span><br><span class="line">        pending.push(component);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      component.visible = true;</span><br><span class="line">      component.forceUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (!(component.props.once &amp;&amp; component.visible)) &#123;</span><br><span class="line">    component.visible = false;</span><br><span class="line">    if (component.props.unmountIfInvisible) &#123;</span><br><span class="line">      component.forceUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>checkNormalVisible 检查组件是否 visible 的函数，判断组件的getgetBoundingClientRect 的 top - offset（相对于屏幕顶部的距离） 与 window 的 height 之间的关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const checkNormalVisible = function checkNormalVisible(component) &#123;</span><br><span class="line">  const node = component.ref;</span><br><span class="line"></span><br><span class="line">  // If this element is hidden by css rules somehow, it&apos;s definitely invisible</span><br><span class="line">  if (!(node.offsetWidth || node.offsetHeight || node.getClientRects().length)) return false;</span><br><span class="line"></span><br><span class="line">  let top;</span><br><span class="line">  let elementHeight;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    // 这个语法 node 也是支持的</span><br><span class="line">    (&#123; top, height: elementHeight &#125; = node.getBoundingClientRect());</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    (&#123; top, height: elementHeight &#125; = defaultBoundingClientRect);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const windowInnerHeight = window.innerHeight || document.documentElement.clientHeight;</span><br><span class="line"></span><br><span class="line">  const offsets = Array.isArray(component.props.offset) ?</span><br><span class="line">                component.props.offset :</span><br><span class="line">                [component.props.offset, component.props.offset]; // Be compatible with previous API</span><br><span class="line"></span><br><span class="line">  return (top - offsets[0] &lt;= windowInnerHeight) &amp;&amp;</span><br><span class="line">         (top + elementHeight + offsets[1] &gt;= 0);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(top - offsets[0] &lt;= windowInnerHeight) &amp;&amp;</span><br><span class="line">         (top + elementHeight + offsets[1] &gt;= 0);</span><br></pre></td></tr></table></figure><p>一张图解析！<br><img src="https://upload-images.jianshu.io/upload_images/7117641-a10f694d96109cc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="check visible example"><br>到这里解析的差不多了</p><p>欣赏一下 throttle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">export default function throttle(fn, threshhold, scope) &#123;</span><br><span class="line">  threshhold || (threshhold = 250);</span><br><span class="line">  var last,</span><br><span class="line">      deferTimer;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    var context = scope || this;</span><br><span class="line"></span><br><span class="line">    var now = +new Date,</span><br><span class="line">        args = arguments;</span><br><span class="line">    if (last &amp;&amp; now &lt; last + threshhold) &#123;</span><br><span class="line">      // hold on to it</span><br><span class="line">      clearTimeout(deferTimer);</span><br><span class="line">      deferTimer = setTimeout(function () &#123;</span><br><span class="line">        last = now;</span><br><span class="line">        fn.apply(context, args);</span><br><span class="line">      &#125;, threshhold);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      last = now;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再欣赏一下 debounce</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">export default function debounce(func, wait, immediate) &#123;</span><br><span class="line">  let timeout;</span><br><span class="line">  let args;</span><br><span class="line">  let context;</span><br><span class="line">  let timestamp;</span><br><span class="line">  let result;</span><br><span class="line"></span><br><span class="line">  const later = function later() &#123;</span><br><span class="line">    const last = +(new Date()) - timestamp;</span><br><span class="line"></span><br><span class="line">    if (last &lt; wait &amp;&amp; last &gt;= 0) &#123;</span><br><span class="line">      timeout = setTimeout(later, wait - last);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      timeout = null;</span><br><span class="line">      if (!immediate) &#123;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        if (!timeout) &#123;</span><br><span class="line">          context = null;</span><br><span class="line">          args = null;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return function debounced() &#123;</span><br><span class="line">    context = this;</span><br><span class="line">    args = arguments;</span><br><span class="line">    timestamp = +(new Date());</span><br><span class="line"></span><br><span class="line">    const callNow = immediate &amp;&amp; !timeout;</span><br><span class="line">    if (!timeout) &#123;</span><br><span class="line">      timeout = setTimeout(later, wait);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (callNow) &#123;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      context = null;</span><br><span class="line">      args = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 scrollParent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">export default (node) =&gt; &#123;</span><br><span class="line">  if (!(node instanceof HTMLElement)) &#123;</span><br><span class="line">    return document.documentElement;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const excludeStaticParent = node.style.position === &apos;absolute&apos;;</span><br><span class="line">  const overflowRegex = /(scroll|auto)/;</span><br><span class="line">  let parent = node;</span><br><span class="line"></span><br><span class="line">  while (parent) &#123;</span><br><span class="line">    if (!parent.parentNode) &#123;</span><br><span class="line">      return node.ownerDocument || document.documentElement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const style = window.getComputedStyle(parent);</span><br><span class="line">    const position = style.position;</span><br><span class="line">    const overflow = style.overflow;</span><br><span class="line">    const overflowX = style[&apos;overflow-x&apos;];</span><br><span class="line">    const overflowY = style[&apos;overflow-y&apos;];</span><br><span class="line"></span><br><span class="line">    if (position === &apos;static&apos; &amp;&amp; excludeStaticParent) &#123;</span><br><span class="line">      parent = parent.parentNode;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (overflowRegex.test(overflow) &amp;&amp; overflowRegex.test(overflowX) &amp;&amp; overflowRegex.test(overflowY)) &#123;</span><br><span class="line">      return parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parent = parent.parentNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return node.ownerDocument || node.documentElement || document.documentElement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结思考"><a class="markdownIt-Anchor" href="#总结思考"></a> 总结思考</h3><p>我们可以看到，Lazyload 并不能实现类似客户端的图片懒加载，Lazyload 加载图片也会出现白屏时间，解决办法是使用 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL/Attribute/image.onload" target="_blank" rel="noopener">image.onload</a>，当图片资源请求关闭后，再显示图片，就可以做到类似客户端的效果。</p>]]></content>
    
    <summary type="html">
    
      React Lazyload
    
    </summary>
    
      <category term="JavaScript" scheme="https://wzes.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://wzes.github.io/tags/JavaScript/"/>
    
      <category term="React" scheme="https://wzes.github.io/tags/React/"/>
    
      <category term="Lazyload" scheme="https://wzes.github.io/tags/Lazyload/"/>
    
  </entry>
  
  <entry>
    <title>Swipe-js-ios 源码解析</title>
    <link href="https://wzes.github.io/2019/07/20/Swipe-js-ios/"/>
    <id>https://wzes.github.io/2019/07/20/Swipe-js-ios/</id>
    <published>2019-07-20T06:38:00.000Z</published>
    <updated>2019-09-01T14:30:49.232Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>Swipe，常用来做轮播图，需要翻页的场景，最经典的开源库 <a href="https://github.com/voronianski/swipe-js-iso" target="_blank" rel="noopener">swipe-js-iso</a> ，不过更推荐使用 React 组件 <a href="https://github.com/voronianski/react-swipe" target="_blank" rel="noopener">react-swipe</a>，它封装了 swipe-js-ios  组件，而 swipe-js-ios 组件则封装了 <a href="https://github.com/thebird/Swipe" target="_blank" rel="noopener">Swipe</a></p><h3 id="helloword"><a class="markdownIt-Anchor" href="#helloword"></a> HelloWord</h3><p><img src="https://upload-images.jianshu.io/upload_images/7117641-de83b4953b2ad82f.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="ReactSwipe"></p><p>如果单独使用的化，创建一个 swipe，dom 必须是三层结构，最里面一层是放 slide 的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;slider&quot; class=&quot;swipe&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;swipe-wrap&quot;&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>CSS 子元素 <strong>float: left;</strong> container 的宽度为自定义，swipe-wrap 的宽度为子页面数 * container 的 width，每一个 slide 的宽度为 container 的 width</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.swipe &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.swipe-wrap &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.swipe-wrap &gt; div &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 100%;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>load 以后，创建 Swipe 即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const mySwipe = Swipe(document.getElementById(&apos;slider&apos;));</span><br></pre></td></tr></table></figure><h3 id="源码解析"><a class="markdownIt-Anchor" href="#源码解析"></a> 源码解析</h3><p>swipe-js-ios 使用立即函数导出了一个 Swipe 模块，使用 <strong>typeof module !== ‘undefined’ &amp;&amp; module.exports</strong> 兼容 Node 和 浏览器环境，如果是 Node 环境，将会有 module.export 那么则使用 module.export 导出，否则使用 root.Swipe 全局变量导出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(function(root, factory) &#123;</span><br><span class="line">  if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123;</span><br><span class="line">    module.exports = factory();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    root.Swipe = factory();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(this, function() &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  return function Swipe(container, options) &#123;</span><br><span class="line">        ....</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>检查浏览器的环境，算是一种规范吧，风别检查触摸事件和 transition 的支持<br>⚠️在浏览器，手机模式下，触摸事件是存在的，而普通浏览器下是不存在的，所以该组件不能在普通浏览器中使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var browser = &#123;</span><br><span class="line">      addEventListener: !!window.addEventListener,</span><br><span class="line">      touch:</span><br><span class="line">        &apos;ontouchstart&apos; in window ||</span><br><span class="line">        (window.DocumentTouch &amp;&amp; document instanceof window.DocumentTouch),</span><br><span class="line">      transitions: (function(temp) &#123;</span><br><span class="line">        var props = [</span><br><span class="line">          &apos;transitionProperty&apos;,</span><br><span class="line">          &apos;WebkitTransition&apos;,</span><br><span class="line">          &apos;MozTransition&apos;,</span><br><span class="line">          &apos;OTransition&apos;,</span><br><span class="line">          &apos;msTransition&apos;</span><br><span class="line">        ];</span><br><span class="line">        for (var i in props)</span><br><span class="line">          if (temp.style[props[i]] !== undefined) return true;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;)(document.createElement(&apos;swipe&apos;))</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>创建时会调用 setup，继而添加事件，touch 触摸事件、transitionend 移动事件，resize 重新布局事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// trigger setup</span><br><span class="line">setup();</span><br><span class="line"></span><br><span class="line">// start auto slideshow if applicable</span><br><span class="line">if (delay) begin();</span><br><span class="line"></span><br><span class="line">// add event listeners</span><br><span class="line">if (browser.addEventListener) &#123;</span><br><span class="line">  // set touchstart event on element</span><br><span class="line">  if (browser.touch) &#123;</span><br><span class="line">    element.addEventListener(&apos;touchstart&apos;, events, false);</span><br><span class="line">    element.addEventListener(&apos;touchforcechange&apos;, function() &#123;&#125;, false);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (browser.transitions) &#123;</span><br><span class="line">    element.addEventListener(&apos;webkitTransitionEnd&apos;, events, false);</span><br><span class="line">    element.addEventListener(&apos;msTransitionEnd&apos;, events, false);</span><br><span class="line">    element.addEventListener(&apos;oTransitionEnd&apos;, events, false);</span><br><span class="line">    element.addEventListener(&apos;otransitionend&apos;, events, false);</span><br><span class="line">    element.addEventListener(&apos;transitionend&apos;, events, false);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // set resize event on window</span><br><span class="line">  window.addEventListener(&apos;resize&apos;, events, false);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  window.onresize = function() &#123;</span><br><span class="line">    setup();</span><br><span class="line">  &#125;; // to play nice with old IE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setup 函数的实现，slides 就是容器里面的页面，continuous 是否自动轮播，slidePos 记录了每一个页面的位置，width 是每一个页面的宽度，此处需要剪掉widthOfSiblingSlidePreview 的大小，可以预览前后页。element 的宽度是 **页数 * width **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function setup() &#123;</span><br><span class="line">      // cache slides</span><br><span class="line">      slides = element.children;</span><br><span class="line">      length = slides.length;</span><br><span class="line"></span><br><span class="line">      // set continuous to false if only one slide</span><br><span class="line">      continuous = slides.length &lt; 2 ? false : options.continuous;</span><br><span class="line"></span><br><span class="line">      // create an array to store current positions of each slide</span><br><span class="line">      slidePos = new Array(slides.length);</span><br><span class="line"></span><br><span class="line">      // determine width of each slide</span><br><span class="line">      width =</span><br><span class="line">        Math.round(</span><br><span class="line">          container.getBoundingClientRect().width || container.offsetWidth</span><br><span class="line">        ) -</span><br><span class="line">        widthOfSiblingSlidePreview * 2;</span><br><span class="line"></span><br><span class="line">      element.style.width = slides.length * width + &apos;px&apos;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>初始化时，需要更新页面的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var pos = slides.length;</span><br><span class="line">while (pos--) &#123;</span><br><span class="line">  var slide = slides[pos];</span><br><span class="line"></span><br><span class="line">  slide.style.width = width + &apos;px&apos;;</span><br><span class="line">  slide.setAttribute(&apos;data-index&apos;, pos);</span><br><span class="line"></span><br><span class="line">  if (browser.transitions) &#123;</span><br><span class="line">    slide.style.left = pos * -width + widthOfSiblingSlidePreview + &apos;px&apos;;</span><br><span class="line">    move(pos, index &gt; pos ? -width : index &lt; pos ? width : 0, 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果支持轮播的化，需要把左边和右边也填充，然后把 container.style.visibility 设置为 visible，如果不支持 transition 的话，只需要设置 element.style.left 即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// reposition elements before and after index</span><br><span class="line">    if (continuous &amp;&amp; browser.transitions) &#123;</span><br><span class="line">      move(circle(index - 1), -width, 0);</span><br><span class="line">      move(circle(index + 1), width, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!browser.transitions)</span><br><span class="line">      element.style.left = index * -width + widthOfSiblingSlidePreview + &apos;px&apos;;</span><br><span class="line"></span><br><span class="line">    container.style.visibility = &apos;visible&apos;;</span><br></pre></td></tr></table></figure><p>move 的实现，translate，更新 slidePos 的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function move(index, dist, speed) &#123;</span><br><span class="line">  translate(index, dist, speed);</span><br><span class="line">  slidePos[index] = dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>translate 三个参数，index：需要移动的页，dist：移动的位置，speed：移动速度，移动只需要给 页面设置 style 的 transform 就OK了，之后就会以动画移动过去了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function translate(index, dist, speed) &#123;</span><br><span class="line">      var slide = slides[index];</span><br><span class="line">      var style = slide &amp;&amp; slide.style;</span><br><span class="line"></span><br><span class="line">      if (!style) return;</span><br><span class="line"></span><br><span class="line">      style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration =</span><br><span class="line">        speed + &apos;ms&apos;;</span><br><span class="line"></span><br><span class="line">      style.webkitTransform = &apos;translate(&apos; + dist + &apos;px,0)&apos; + &apos;translateZ(0)&apos;;</span><br><span class="line">      style.msTransform = style.MozTransform = style.OTransform =</span><br><span class="line">        &apos;translateX(&apos; + dist + &apos;px)&apos;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>prev 对外提供接口，手动翻页使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function prev() &#123;</span><br><span class="line">   if (continuous) slide(index - 1);</span><br><span class="line">   else if (index) slide(index - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slide 移动函数，指定移动的页 index 和速度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function slide(to, slideSpeed) &#123;</span><br><span class="line">      // do nothing if already on requested slide</span><br><span class="line">      if (index == to) return;</span><br><span class="line"></span><br><span class="line">      if (browser.transitions) &#123;</span><br><span class="line">        var direction = Math.abs(index - to) / (index - to); // 1: backward, -1: forward</span><br><span class="line"></span><br><span class="line">        // get the actual position of the slide</span><br><span class="line">        if (continuous) &#123;</span><br><span class="line">          var natural_direction = direction;</span><br><span class="line">          direction = -slidePos[circle(to)] / width;</span><br><span class="line"></span><br><span class="line">          // if going forward but to &lt; index, use to = slides.length + to</span><br><span class="line">          // if going backward but to &gt; index, use to = -slides.length + to</span><br><span class="line">          if (direction !== natural_direction)</span><br><span class="line">            to = -direction * slides.length + to;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var diff = Math.abs(index - to) - 1;</span><br><span class="line"></span><br><span class="line">        // move all the slides between index and to in the right direction</span><br><span class="line">        while (diff--)</span><br><span class="line">          move(</span><br><span class="line">            circle((to &gt; index ? to : index) - diff - 1),</span><br><span class="line">            width * direction,</span><br><span class="line">            0</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">        to = circle(to);</span><br><span class="line"></span><br><span class="line">        move(index, width * direction, slideSpeed || speed);</span><br><span class="line">        move(to, 0, slideSpeed || speed);</span><br><span class="line"></span><br><span class="line">        if (continuous) move(circle(to - direction), -(width * direction), 0); // we need to get the next in place</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        to = circle(to); </span><br><span class="line">        animate(index * -width, to * -width, slideSpeed || speed);</span><br><span class="line">        //no fallback for a circular continuous if the browser does not accept transitions</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      index = to;</span><br><span class="line">      offloadFn(options.callback &amp;&amp; options.callback(index, slides[index]));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果浏览器不支持 transition，那么则使用 setInterval 实现渐进移动， animation 是对整个页面进行移动，而 move 是移动每一个子页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function animate(from, to, speed) &#123;</span><br><span class="line">      // if not an animation, just reposition</span><br><span class="line">      if (!speed) &#123;</span><br><span class="line">        element.style.left = to + &apos;px&apos;;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var start = +new Date();</span><br><span class="line"></span><br><span class="line">      var timer = setInterval(function() &#123;</span><br><span class="line">        var timeElap = +new Date() - start;</span><br><span class="line"></span><br><span class="line">        if (timeElap &gt; speed) &#123;</span><br><span class="line">          element.style.left = to + &apos;px&apos;;</span><br><span class="line"></span><br><span class="line">          if (delay) begin();</span><br><span class="line"></span><br><span class="line">          options.transitionEnd &amp;&amp;</span><br><span class="line">            options.transitionEnd.call(event, index, slides[index]);</span><br><span class="line"></span><br><span class="line">          clearInterval(timer);</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        element.style.left =</span><br><span class="line">          (to - from) * (Math.floor((timeElap / speed) * 100) / 100) +</span><br><span class="line">          from +</span><br><span class="line">          &apos;px&apos;;</span><br><span class="line">      &#125;, 4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接下来研究一下触摸事件的处理，首先是 start，start 事件会记录起始触摸位置以及时间，并且添加 touchmove 和 touchend 事件，如果没有 start 事件，触摸事件是不存在的， end 的时候会被移除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">start: function(event) &#123;</span><br><span class="line">        var touches = event.touches[0];</span><br><span class="line"></span><br><span class="line">        // measure start values</span><br><span class="line">        start = &#123;</span><br><span class="line">          // get initial touch coords</span><br><span class="line">          x: touches.pageX,</span><br><span class="line">          y: touches.pageY,</span><br><span class="line"></span><br><span class="line">          // store time to determine touch duration</span><br><span class="line">          time: +new Date()</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // used for testing first move event</span><br><span class="line">        isScrolling = undefined;</span><br><span class="line"></span><br><span class="line">        // reset delta and end measurements</span><br><span class="line">        delta = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        // attach touchmove and touchend listeners</span><br><span class="line">        element.addEventListener(&apos;touchmove&apos;, this, false);</span><br><span class="line">        element.addEventListener(&apos;touchend&apos;, this, false);</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure><p>move 事件，delta 将手指移动距离记下，最后视同 translate 移动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">move: function(event) &#123;</span><br><span class="line">       // ensure swiping with one touch and not pinching</span><br><span class="line">       if (event.touches.length &gt; 1 || (event.scale &amp;&amp; event.scale !== 1))</span><br><span class="line">         return;</span><br><span class="line"></span><br><span class="line">       if (options.disableScroll) return;</span><br><span class="line"></span><br><span class="line">       var touches = event.touches[0];</span><br><span class="line"></span><br><span class="line">       // measure change in x and y</span><br><span class="line">       delta = &#123;</span><br><span class="line">         x: touches.pageX - start.x,</span><br><span class="line">         y: touches.pageY - start.y</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       // determine if scrolling test has run - one time test</span><br><span class="line">       if (typeof isScrolling == &apos;undefined&apos;) &#123;</span><br><span class="line">         isScrolling = !!(</span><br><span class="line">           isScrolling || Math.abs(delta.x) &lt; Math.abs(delta.y)</span><br><span class="line">         );</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // if user is not trying to scroll vertically</span><br><span class="line">       if (!isScrolling) &#123;</span><br><span class="line">         // prevent native scrolling</span><br><span class="line">         event.preventDefault();</span><br><span class="line"></span><br><span class="line">         // stop slideshow</span><br><span class="line">         stop();</span><br><span class="line"></span><br><span class="line">         // increase resistance if first or last slide</span><br><span class="line">         if (continuous) &#123;</span><br><span class="line">           // we don&apos;t add resistance at the end</span><br><span class="line"></span><br><span class="line">           translate(</span><br><span class="line">             circle(index - 1),</span><br><span class="line">             delta.x + slidePos[circle(index - 1)],</span><br><span class="line">             0</span><br><span class="line">           );</span><br><span class="line">           translate(index, delta.x + slidePos[index], 0);</span><br><span class="line">           translate(</span><br><span class="line">             circle(index + 1),</span><br><span class="line">             delta.x + slidePos[circle(index + 1)],</span><br><span class="line">             0</span><br><span class="line">           );</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">           delta.x =</span><br><span class="line">             delta.x /</span><br><span class="line">             ((!index &amp;&amp; delta.x &gt; 0) || // if first slide and sliding left</span><br><span class="line">             (index == slides.length - 1 &amp;&amp; // or if last slide and sliding right</span><br><span class="line">               delta.x &lt; 0) // and if sliding at all</span><br><span class="line">               ? Math.abs(delta.x) / width + 1 // determine resistance level</span><br><span class="line">               : 1); // no resistance if false</span><br><span class="line"></span><br><span class="line">           // translate 1:1</span><br><span class="line">           translate(index - 1, delta.x + slidePos[index - 1], 0);</span><br><span class="line">           translate(index, delta.x + slidePos[index], 0);</span><br><span class="line">           translate(index + 1, delta.x + slidePos[index + 1], 0);</span><br><span class="line">         &#125;</span><br><span class="line">         options.swiping &amp;&amp; options.swiping(-delta.x / width);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure><p>end 事件，主要判断本次触摸滑动是否有效，并持续接下来的操作，最后将会 remove 掉监听事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">end: function(event) &#123;</span><br><span class="line">        // measure duration</span><br><span class="line">        var duration = +new Date() - start.time;</span><br><span class="line"></span><br><span class="line">        // determine if slide attempt triggers next/prev slide</span><br><span class="line">        var isValidSlide =</span><br><span class="line">          (Number(duration) &lt; 250 &amp;&amp; // if slide duration is less than 250ms</span><br><span class="line">            Math.abs(delta.x) &gt; 20) || // and if slide amt is greater than 20px</span><br><span class="line">          Math.abs(delta.x) &gt; width / 2; // or if slide amt is greater than half the width</span><br><span class="line"></span><br><span class="line">        // determine if slide attempt is past start and end</span><br><span class="line">        var isPastBounds =</span><br><span class="line">          (!index &amp;&amp; delta.x &gt; 0) || // if first slide and slide amt is greater than 0</span><br><span class="line">          (index == slides.length - 1 &amp;&amp; delta.x &lt; 0); // or if last slide and slide amt is less than 0</span><br><span class="line"></span><br><span class="line">        if (continuous) isPastBounds = false;</span><br><span class="line"></span><br><span class="line">        // determine direction of swipe (true:right, false:left)</span><br><span class="line">        var direction = delta.x &lt; 0;</span><br><span class="line"></span><br><span class="line">        // if not scrolling vertically</span><br><span class="line">        if (!isScrolling) &#123;</span><br><span class="line">          if (isValidSlide &amp;&amp; !isPastBounds) &#123;</span><br><span class="line">            if (direction) &#123;</span><br><span class="line">              if (continuous) &#123;</span><br><span class="line">                // we need to get the next in this direction in place</span><br><span class="line"></span><br><span class="line">                move(circle(index - 1), -width, 0);</span><br><span class="line">                move(circle(index + 2), width, 0);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                move(index - 1, -width, 0);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              move(index, slidePos[index] - width, speed);</span><br><span class="line">              move(</span><br><span class="line">                circle(index + 1),</span><br><span class="line">                slidePos[circle(index + 1)] - width,</span><br><span class="line">                speed</span><br><span class="line">              );</span><br><span class="line">              index = circle(index + 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              if (continuous) &#123;</span><br><span class="line">                // we need to get the next in this direction in place</span><br><span class="line"></span><br><span class="line">                move(circle(index + 1), width, 0);</span><br><span class="line">                move(circle(index - 2), -width, 0);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                move(index + 1, width, 0);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              move(index, slidePos[index] + width, speed);</span><br><span class="line">              move(</span><br><span class="line">                circle(index - 1),</span><br><span class="line">                slidePos[circle(index - 1)] + width,</span><br><span class="line">                speed</span><br><span class="line">              );</span><br><span class="line">              index = circle(index - 1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            options.callback &amp;&amp; options.callback(index, slides[index]);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            if (continuous) &#123;</span><br><span class="line">              move(circle(index - 1), -width, speed);</span><br><span class="line">              move(index, 0, speed);</span><br><span class="line">              move(circle(index + 1), width, speed);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              move(index - 1, -width, speed);</span><br><span class="line">              move(index, 0, speed);</span><br><span class="line">              move(index + 1, width, speed);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // kill touchmove and touchend event listeners until touchstart called again</span><br><span class="line">        element.removeEventListener(&apos;touchmove&apos;, events, false);</span><br><span class="line">        element.removeEventListener(&apos;touchend&apos;, events, false);</span><br><span class="line">        element.removeEventListener(&apos;touchforcechange&apos;, function() &#123;&#125;, false);</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>总的来说，swipe-js-ios 充分利用了 transition，来实现移动动画，搞清楚触摸事件就比较容易能写出来可滑动的 swipe</p>]]></content>
    
    <summary type="html">
    
      JavaScript
    
    </summary>
    
      <category term="JavaScript" scheme="https://wzes.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://wzes.github.io/tags/JavaScript/"/>
    
      <category term="HTML" scheme="https://wzes.github.io/tags/HTML/"/>
    
      <category term="DOM" scheme="https://wzes.github.io/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 源码解析</title>
    <link href="https://wzes.github.io/2019/07/13/Webpack/"/>
    <id>https://wzes.github.io/2019/07/13/Webpack/</id>
    <published>2019-07-13T11:59:16.000Z</published>
    <updated>2019-09-01T14:31:00.690Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>算是一个h5开发了，虽然没写过什么完整的前端页面，但接触前端也有段时间了，对于一个合格的前端开发者而言，搞懂 webpack 打包原理还是比较重要的。</p><h3 id="hello-world"><a class="markdownIt-Anchor" href="#hello-world"></a> hello world</h3><p>使用 commonjs 规范，lib.js 只导出一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// lib.js</span><br><span class="line">module.exports = function () &#123;</span><br><span class="line">    return &quot;hello webpack!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.js 使用 require 引入，代码很简单，输入方法返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line">const func = require(&quot;./lib&quot;)</span><br><span class="line"></span><br><span class="line">const result = func()</span><br><span class="line">// print hello</span><br><span class="line">console.log(result)</span><br></pre></td></tr></table></figure><h5 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── dist</span><br><span class="line">│   └── main.js</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── node_modules</span><br><span class="line">├── src</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   └── lib.js</span><br><span class="line">└── webpack.config.js</span><br></pre></td></tr></table></figure><h5 id="webpackconfigjs"><a class="markdownIt-Anchor" href="#webpackconfigjs"></a> webpack.config.js</h5><p>为了方便看生成的源码，我们将 mode 设置为 development，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    context: path.resolve(__dirname, &apos;./&apos;),</span><br><span class="line">    mode: &apos;development&apos;,</span><br><span class="line">    entry: &apos;./src/index.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">        filename: &apos;main.js&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="packagejson"><a class="markdownIt-Anchor" href="#packagejson"></a> package.json</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;webpack-demo&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;^4.35.2&quot;,</span><br><span class="line">    &quot;webpack-cli&quot;: &quot;^3.3.5&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="编译运行"><a class="markdownIt-Anchor" href="#编译运行"></a> 编译运行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br><span class="line">node dist/main.js</span><br></pre></td></tr></table></figure><h5 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node dist/main.js </span><br><span class="line">hello webpack!</span><br></pre></td></tr></table></figure><h4 id="起源"><a class="markdownIt-Anchor" href="#起源"></a> 起源</h4><p>浏览器，node 并不支持模块化，我们在项目中使用的 require、export 将会经过 webpack 后，这些 js 就会被打包整合成一个 js 文件，只需要运行 js 文件，整个模块将会运行起来了。</p><h4 id="mainjs-解析"><a class="markdownIt-Anchor" href="#mainjs-解析"></a> main.js 解析</h4><p>整个文件只有 111 行，这是未经过压缩的版本，生产环境下的输出文件比这还要精简，只需要在 webpack.config.js 中将 mode 值等于 production 即可改变打包环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">/******/ (function(modules) &#123; // webpackBootstrap</span><br><span class="line">/******/ // The module cache</span><br><span class="line">/******/ var installedModules = &#123;&#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ // The require function</span><br><span class="line">/******/ function __webpack_require__(moduleId) &#123;</span><br><span class="line">/******/</span><br><span class="line">/******/ // Check if module is in cache</span><br><span class="line">/******/ if(installedModules[moduleId]) &#123;</span><br><span class="line">/******/ return installedModules[moduleId].exports;</span><br><span class="line">/******/ &#125;</span><br><span class="line">/******/ // Create a new module (and put it into the cache)</span><br><span class="line">/******/ var module = installedModules[moduleId] = &#123;</span><br><span class="line">/******/ i: moduleId,</span><br><span class="line">/******/ l: false,</span><br><span class="line">/******/ exports: &#123;&#125;</span><br><span class="line">/******/ &#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ // Execute the module function</span><br><span class="line">/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><br><span class="line">/******/</span><br><span class="line">/******/ // Flag the module as loaded</span><br><span class="line">/******/ module.l = true;</span><br><span class="line">/******/</span><br><span class="line">/******/ // Return the exports of the module</span><br><span class="line">/******/ return module.exports;</span><br><span class="line">/******/ &#125;</span><br><span class="line">/******/</span><br><span class="line">/******/</span><br><span class="line">/******/ // expose the modules object (__webpack_modules__)</span><br><span class="line">/******/ __webpack_require__.m = modules;</span><br><span class="line">/******/</span><br><span class="line">/******/ // expose the module cache</span><br><span class="line">/******/ __webpack_require__.c = installedModules;</span><br><span class="line">/******/</span><br><span class="line">/******/ // define getter function for harmony exports</span><br><span class="line">/******/ __webpack_require__.d = function(exports, name, getter) &#123;</span><br><span class="line">/******/ if(!__webpack_require__.o(exports, name)) &#123;</span><br><span class="line">/******/ Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;);</span><br><span class="line">/******/ &#125;</span><br><span class="line">/******/ &#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ // define __esModule on exports</span><br><span class="line">/******/ __webpack_require__.r = function(exports) &#123;</span><br><span class="line">/******/ if(typeof Symbol !== &apos;undefined&apos; &amp;&amp; Symbol.toStringTag) &#123;</span><br><span class="line">/******/ Object.defineProperty(exports, Symbol.toStringTag, &#123; value: &apos;Module&apos; &#125;);</span><br><span class="line">/******/ &#125;</span><br><span class="line">/******/ Object.defineProperty(exports, &apos;__esModule&apos;, &#123; value: true &#125;);</span><br><span class="line">/******/ &#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ // create a fake namespace object</span><br><span class="line">/******/ // mode &amp; 1: value is a module id, require it</span><br><span class="line">/******/ // mode &amp; 2: merge all properties of value into the ns</span><br><span class="line">/******/ // mode &amp; 4: return value when already ns object</span><br><span class="line">/******/ // mode &amp; 8|1: behave like require</span><br><span class="line">/******/ __webpack_require__.t = function(value, mode) &#123;</span><br><span class="line">/******/ if(mode &amp; 1) value = __webpack_require__(value);</span><br><span class="line">/******/ if(mode &amp; 8) return value;</span><br><span class="line">/******/ if((mode &amp; 4) &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; value &amp;&amp; value.__esModule) return value;</span><br><span class="line">/******/ var ns = Object.create(null);</span><br><span class="line">/******/ __webpack_require__.r(ns);</span><br><span class="line">/******/ Object.defineProperty(ns, &apos;default&apos;, &#123; enumerable: true, value: value &#125;);</span><br><span class="line">/******/ if(mode &amp; 2 &amp;&amp; typeof value != &apos;string&apos;) for(var key in value) __webpack_require__.d(ns, key, function(key) &#123; return value[key]; &#125;.bind(null, key));</span><br><span class="line">/******/ return ns;</span><br><span class="line">/******/ &#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ // getDefaultExport function for compatibility with non-harmony modules</span><br><span class="line">/******/ __webpack_require__.n = function(module) &#123;</span><br><span class="line">/******/ var getter = module &amp;&amp; module.__esModule ?</span><br><span class="line">/******/ function getDefault() &#123; return module[&apos;default&apos;]; &#125; :</span><br><span class="line">/******/ function getModuleExports() &#123; return module; &#125;;</span><br><span class="line">/******/ __webpack_require__.d(getter, &apos;a&apos;, getter);</span><br><span class="line">/******/ return getter;</span><br><span class="line">/******/ &#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ // Object.prototype.hasOwnProperty.call</span><br><span class="line">/******/ __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ // __webpack_public_path__</span><br><span class="line">/******/ __webpack_require__.p = &quot;&quot;;</span><br><span class="line">/******/</span><br><span class="line">/******/</span><br><span class="line">/******/ // Load entry module and return exports</span><br><span class="line">/******/ return __webpack_require__(__webpack_require__.s = &quot;./src/index.js&quot;);</span><br><span class="line">/******/ &#125;)</span><br><span class="line">/************************************************************************/</span><br><span class="line">/******/ (&#123;</span><br><span class="line"></span><br><span class="line">/***/ &quot;./src/index.js&quot;:</span><br><span class="line">/*!**********************!*\</span><br><span class="line">  !*** ./src/index.js ***!</span><br><span class="line">  \**********************/</span><br><span class="line">/*! no static exports found */</span><br><span class="line">/***/ (function(module, exports, __webpack_require__) &#123;</span><br><span class="line"></span><br><span class="line">eval(&quot;// index.js\nconst func = __webpack_require__(/*! ./lib */ \&quot;./src/lib.js\&quot;)\n\nconst result = func()\n// print hello\nconsole.log(result)\n\n//# sourceURL=webpack:///./src/index.js?&quot;);</span><br><span class="line"></span><br><span class="line">/***/ &#125;),</span><br><span class="line"></span><br><span class="line">/***/ &quot;./src/lib.js&quot;:</span><br><span class="line">/*!********************!*\</span><br><span class="line">  !*** ./src/lib.js ***!</span><br><span class="line">  \********************/</span><br><span class="line">/*! no static exports found */</span><br><span class="line">/***/ (function(module, exports) &#123;</span><br><span class="line"></span><br><span class="line">eval(&quot;module.exports = function () &#123;\n    return \&quot;hello webpack!\&quot;\n&#125;\n\n//# sourceURL=webpack:///./src/lib.js?&quot;);</span><br><span class="line"></span><br><span class="line">/***/ &#125;)</span><br><span class="line"></span><br><span class="line">/******/ &#125;);</span><br></pre></td></tr></table></figure><p>我们先将此文件的主要部分拿出来看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/******/</span><br><span class="line">(function (modules) &#123;</span><br><span class="line">    var installedModules = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function __webpack_require__ (moduleId) &#123;</span><br><span class="line">        if (installedModules[moduleId]) &#123;</span><br><span class="line">            return installedModules[moduleId].exports</span><br><span class="line">        &#125;</span><br><span class="line">        var module = installedModules[moduleId] = &#123;</span><br><span class="line">            i: moduleId,</span><br><span class="line">            l: false,</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__)</span><br><span class="line">        module.l = true</span><br><span class="line">        return module.exports</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return __webpack_require__(__webpack_require__.s = &apos;./src/index.js&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">(&#123;</span><br><span class="line">    &apos;./src/index.js&apos;:</span><br><span class="line">        (function (module, exports, __webpack_require__) &#123;</span><br><span class="line">            eval(</span><br><span class="line">                &apos;// index.js\nconst func = __webpack_require__(/*! ./lib */ &quot;./src/lib.js&quot;)\n\nconst result = func()\n// print hello\nconsole.log(result)\n\n//# sourceURL=webpack:///./src/index.js?&apos;)</span><br><span class="line">        &#125;),</span><br><span class="line">    &apos;./src/lib.js&apos;:</span><br><span class="line">        (function (module, exports) &#123;</span><br><span class="line">            eval(</span><br><span class="line">                &apos;module.exports = function () &#123;\n    return &quot;hello webpack!&quot;\n&#125;\n\n//# sourceURL=webpack:///./src/lib.js?&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这是一个立即执行函数，首先申明了 installedModules 对象，这是已安装的模块集合，之后定义了一个函数 <strong>webpack_require</strong> ，此函数用来获取模块的引用，最后 return 了此函数，参数为入口，moduleId = ‘./src/index.js’<br>modules 即为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &apos;./src/index.js&apos;:</span><br><span class="line">        (function (module, exports, __webpack_require__) &#123;</span><br><span class="line">            eval(</span><br><span class="line">                &apos;// index.js\nconst func = __webpack_require__(/*! ./lib */ &quot;./src/lib.js&quot;)\n\nconst result = func()\n// print hello\nconsole.log(result)\n\n//# sourceURL=webpack:///./src/index.js?&apos;)</span><br><span class="line">        &#125;),</span><br><span class="line">    &apos;./src/lib.js&apos;:</span><br><span class="line">        (function (module, exports) &#123;</span><br><span class="line">            eval(</span><br><span class="line">                &apos;module.exports = function () &#123;\n    return &quot;hello webpack!&quot;\n&#125;\n\n//# sourceURL=webpack:///./src/lib.js?&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modules[moduleId].call(module.exports, module, module.exports, __webpack_require__)</span><br></pre></td></tr></table></figure><p>module 即模块，modules[moduleId] 即为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function (module, exports, __webpack_require__) &#123;</span><br><span class="line">           eval(</span><br><span class="line">               &apos;// index.js\nconst func = __webpack_require__(/*! ./lib */ &quot;./src/lib.js&quot;)\n\nconst result = func()\n// print hello\nconsole.log(result)\n\n//# sourceURL=webpack:///./src/index.js?&apos;)</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure><p>module.exports 为 this 上下文环境，该函数执行中，第一行即调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const func = __webpack_require__(&quot;./src/lib.js&quot;)</span><br></pre></td></tr></table></figure><p><strong>webpack_require</strong>(&quot;./src/lib.js&quot;) 即调用了此函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function (module, exports) &#123;</span><br><span class="line">            eval(</span><br><span class="line">                &apos;module.exports = function () &#123;\n    return &quot;hello webpack!&quot;\n&#125;\n\n//# sourceURL=webpack:///./src/lib.js?&apos;)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>最后返回 module.exports 即 lib 里面的导出函数。再往后执行便是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const result = func()</span><br><span class="line">// print hello</span><br><span class="line">console.log(result)</span><br></pre></td></tr></table></figure><p>此刻基本已经将关系理顺了，此后如果在调用模块，则世界从 installedModules 中直接返回。</p><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>此文只是分析了简单的模块引用，需要仔细分析才能融会贯通。</p>]]></content>
    
    <summary type="html">
    
      Webpack
    
    </summary>
    
      <category term="JavaScript" scheme="https://wzes.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://wzes.github.io/tags/JavaScript/"/>
    
      <category term="Webpack" scheme="https://wzes.github.io/tags/Webpack/"/>
    
  </entry>
  
</feed>
