<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wzes.github.io/"/>
  <updated>2019-09-01T14:33:14.144Z</updated>
  <id>https://wzes.github.io/</id>
  
  <author>
    <name>Xuantang Cun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript Array 的 1 个属性，35 个方法</title>
    <link href="https://wzes.github.io/2019/09/01/JavaScript/JavaScript%20Array/"/>
    <id>https://wzes.github.io/2019/09/01/JavaScript/JavaScript Array/</id>
    <published>2019-09-01T07:30:16.000Z</published>
    <updated>2019-09-01T14:33:14.144Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>这周呢，彻底学习一下 Array 的所有方法。学习地址 MDN，里面还有各个函数实现的源码！数组作为 JavaScript 的一种类型，与 Number，Boolean，Null，Undefined，Object，Symbol  齐驱并驾。了解 Array 的所有方法，能帮助我们最快找到适合自己的函数。</p><h4 id="create-an-array"><a class="markdownIt-Anchor" href="#create-an-array"></a> Create an Array</h4><p>创建一个数组很简单，直接赋值，或者使用 <code>[]</code> 创建空数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var fruits = [&apos;Apple&apos;, &apos;Banana&apos;];</span><br><span class="line">console.log(fruits.length); // 2</span><br></pre></td></tr></table></figure><h4 id><a class="markdownIt-Anchor" href="#"></a> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length#" target="_blank" rel="noopener"><strong>Properties</strong></a></h4><h5 id="arraylength"><a class="markdownIt-Anchor" href="#arraylength"></a> Array.length</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var clothing = [&apos;shoes&apos;, &apos;shirts&apos;, &apos;socks&apos;, &apos;sweaters&apos;];</span><br><span class="line"></span><br><span class="line">console.log(clothing.length);</span><br><span class="line">// expected output: 4</span><br><span class="line"></span><br><span class="line">var array = new Array(2)</span><br></pre></td></tr></table></figure><h4 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype#" target="_blank" rel="noopener"><strong>Methods</strong></a></h4><p>首先看一下 Array 的三个静态方法<br>#####1. Array.from()<br><strong>Array.from()</strong> 方法从类似数组或可迭代的对象创建一个新的，浅拷贝的 Array 实例，或者从 {length: 3} 对象中创建固定长度的 undefined 数组</p><blockquote><p>Array.from(arrayLike[, mapFn[, thisArg]])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(Array.from(&apos;foo&apos;));</span><br><span class="line">// expected output: Array [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]</span><br><span class="line"></span><br><span class="line">console.log(Array.from([1, 2, 3], x =&gt; x + x));</span><br><span class="line">// expected output: Array [2, 4, 6]</span><br><span class="line"></span><br><span class="line">console.log(Array.from(&#123;length: 3&#125;));</span><br><span class="line">// expected output: Array [undefined, undefined, undefined]</span><br></pre></td></tr></table></figure><h5 id="2-arrayisarray"><a class="markdownIt-Anchor" href="#2-arrayisarray"></a> 2. Array.isArray()</h5><p><strong>Array.isArray()</strong> 方法确定传递的值是否为 Array，由于 typeof Array = ‘object’ ，所以判断是否是一个数组使用 isArray 才可以</p><blockquote><p>Array.isArray(value)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray([1, 2, 3]);  // true</span><br><span class="line">Array.isArray(&#123;foo: 123&#125;); // false</span><br><span class="line">Array.isArray(&apos;foobar&apos;);   // false</span><br><span class="line">Array.isArray(undefined);  // false</span><br></pre></td></tr></table></figure><h5 id="3-arrayof"><a class="markdownIt-Anchor" href="#3-arrayof"></a> 3. Array.of()</h5><p><strong>Array.of()</strong> 方法从可变数量的参数创建一个新的Array实例，无论参数的数量或类型如何<br>注意它与构造函数的不同之处</p><blockquote><p>Array.of(element0[, element1[, …[, elementN]]])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.of(7);       // [7] </span><br><span class="line">Array.of(1, 2, 3); // [1, 2, 3]</span><br><span class="line"></span><br><span class="line">Array(7);          // array of 7 empty slots</span><br><span class="line">Array(1, 2, 3);    // [1, 2, 3]</span><br></pre></td></tr></table></figure><p>接下来看 Array 的对象方法</p><h5 id="4-arrayprototypeconcat"><a class="markdownIt-Anchor" href="#4-arrayprototypeconcat"></a> 4. Array.prototype.concat()</h5><p><strong>concat()</strong> 方法用于合并两个或多个数组。 此方法不会更改现有数组，而是返回一个新数组</p><blockquote><p>var new_array = old_array.concat([value1[, value2[, …[, valueN]]]])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">var array2 = [&apos;d&apos;, &apos;e&apos;, &apos;f&apos;];</span><br><span class="line"></span><br><span class="line">console.log(array1.concat(array2));</span><br><span class="line">// expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span><br></pre></td></tr></table></figure><h5 id="5-arrayprototypecopywithin"><a class="markdownIt-Anchor" href="#5-arrayprototypecopywithin"></a> 5. Array.prototype.copyWithin()</h5><p><strong>copyWithin()</strong> 方法浅析将数组的一部分复制到同一数组中的另一个位置，并返回它而不修改其长度</p><blockquote><p>arr.copyWithin(target[, start[, end]])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];</span><br><span class="line"></span><br><span class="line">// copy to index 0 the element at index 3</span><br><span class="line">console.log(array1.copyWithin(0, 3, 4));</span><br><span class="line">// expected output: Array [&quot;d&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br><span class="line"></span><br><span class="line">// copy to index 1 all elements from index 3 to the end</span><br><span class="line">console.log(array1.copyWithin(1, 3));</span><br><span class="line">// expected output: Array [&quot;d&quot;, &quot;d&quot;, &quot;e&quot;, &quot;d&quot;, &quot;e&quot;]</span><br></pre></td></tr></table></figure><h5 id="6-arrayprototypeentries"><a class="markdownIt-Anchor" href="#6-arrayprototypeentries"></a> 6. Array.prototype.entries()</h5><p><strong>entries()</strong> 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。</p><blockquote><p>array.entries()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">var iterator1 = array1.entries();</span><br><span class="line"></span><br><span class="line">console.log(iterator1.next().value);</span><br><span class="line">// expected output: Array [0, &quot;a&quot;]</span><br><span class="line"></span><br><span class="line">console.log(iterator1.next().value);</span><br><span class="line">// expected output: Array [1, &quot;b&quot;]</span><br><span class="line"></span><br><span class="line">// 使用 for of 遍历</span><br><span class="line">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">var iterator = a.entries();</span><br><span class="line"></span><br><span class="line">for (let e of iterator) &#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;</span><br><span class="line">// [0, &apos;a&apos;]</span><br><span class="line">// [1, &apos;b&apos;]</span><br><span class="line">// [2, &apos;c&apos;]</span><br></pre></td></tr></table></figure><h5 id="7-arrayprototypeevery"><a class="markdownIt-Anchor" href="#7-arrayprototypeevery"></a> 7. Array.prototype.every()</h5><p><strong>every()</strong> 方法测试数组中的所有元素是否都通过了由提供的函数实现的测试。 它返回一个布尔值</p><blockquote><p>arr.every(callback(element[, index[, array]])[, thisArg])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function isBelowThreshold(currentValue) &#123;</span><br><span class="line">  return currentValue &lt; 40;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var array1 = [1, 30, 39, 29, 10, 13];</span><br><span class="line"></span><br><span class="line">console.log(array1.every(isBelowThreshold));</span><br><span class="line">// expected output: true</span><br></pre></td></tr></table></figure><h5 id="8-arrayprototypefill"><a class="markdownIt-Anchor" href="#8-arrayprototypefill"></a> 8. Array.prototype.fill()</h5><p><strong>fill()</strong> 方法使用静态值从开始索引（默认为零）到结束索引（默认数组长度）填充（修改）数组的所有元素。 它返回修改后的数组，原数组会改变～</p><blockquote><p>arr.fill(value[, start[, end]])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> var array1 = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">// fill with 0 from position 2 until position 4</span><br><span class="line">console.log(array1.fill(0, 2, 4));</span><br><span class="line">// expected output: [1, 2, 0, 0]</span><br><span class="line"></span><br><span class="line">// fill with 5 from position 1</span><br><span class="line">console.log(array1.fill(5, 1));</span><br><span class="line">// expected output: [1, 5, 5, 5]</span><br><span class="line"></span><br><span class="line">console.log(array1.fill(6));</span><br><span class="line">// expected output: [6, 6, 6, 6]</span><br></pre></td></tr></table></figure><h5 id="9-arrayprototypefilter"><a class="markdownIt-Anchor" href="#9-arrayprototypefilter"></a> 9.  Array.prototype.filter()</h5><p><strong>filter()</strong> 方法创建一个新数组，其中包含所有传递由提供的函数实现的测试的元素</p><blockquote><p>var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var words = [&apos;spray&apos;, &apos;limit&apos;, &apos;elite&apos;, &apos;exuberant&apos;, &apos;destruction&apos;, &apos;present&apos;];</span><br><span class="line"></span><br><span class="line">const result = words.filter(word =&gt; word.length &gt; 6);</span><br><span class="line"></span><br><span class="line">console.log(result);</span><br><span class="line">// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]</span><br></pre></td></tr></table></figure><h5 id="10-arrayprototypefind"><a class="markdownIt-Anchor" href="#10-arrayprototypefind"></a> 10. Array.prototype.find()</h5><p><strong>find()</strong> 方法返回数组中第一个满足提供的测试函数的元素的值。 否则返回undefined</p><blockquote><p>arr.find(callback(element[, index[, array]])[, thisArg])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [5, 12, 8, 130, 44];</span><br><span class="line"></span><br><span class="line">var found = array1.find(function(element) &#123;</span><br><span class="line">  return element &gt; 10;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(found);</span><br><span class="line">// expected output: 12</span><br></pre></td></tr></table></figure><h5 id="11-arrayprototypefindindex"><a class="markdownIt-Anchor" href="#11-arrayprototypefindindex"></a> 11. Array.prototype.findIndex()</h5><p><strong>findIndex()</strong> 方法返回数组中第一个满足提供的测试函数的元素的索引。 否则，它返回-1，表示没有元素通过测试</p><blockquote><p>arr.findIndex(callback(element[, index[, array]])[, thisArg])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [5, 12, 8, 130, 44];</span><br><span class="line"></span><br><span class="line">function isLargeNumber(element) &#123;</span><br><span class="line">  return element &gt; 13;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(array1.findIndex(isLargeNumber));</span><br></pre></td></tr></table></figure><h5 id="12-arrayprototypeflat"><a class="markdownIt-Anchor" href="#12-arrayprototypeflat"></a> 12. Array.prototype.flat()</h5><p><strong>flat()</strong> 方法创建一个新数组，所有子数组元素以递归方式连接到指定的深度。</p><blockquote><p>var newArray = arr.flat([depth]);</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1, 2, [3, 4]];</span><br><span class="line">arr1.flat(); </span><br><span class="line">// [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">var arr2 = [1, 2, [3, 4, [5, 6]]];</span><br><span class="line">arr2.flat();</span><br><span class="line">// [1, 2, 3, 4, [5, 6]]</span><br><span class="line"></span><br><span class="line">var arr3 = [1, 2, [3, 4, [5, 6]]];</span><br><span class="line">arr3.flat(2);</span><br><span class="line">// [1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];</span><br><span class="line">arr4.flat(Infinity);</span><br><span class="line">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure><h5 id="13-arrayprototypeflatmap"><a class="markdownIt-Anchor" href="#13-arrayprototypeflatmap"></a> 13. Array.prototype.flatMap()</h5><p><strong>flatMap()</strong> 方法首先使用映射函数映射每个元素，然后将结果展平为新数组。 它与map（）后跟深度为1的flat（）相同，但flatMap（）通常非常有用，因为将两者合并到一个方法中效率稍高</p><blockquote><p>var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) {<br>// return element for new_array<br>}[, thisArg])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [&quot;it&apos;s Sunny in&quot;, &quot;&quot;, &quot;California&quot;];</span><br><span class="line"></span><br><span class="line">arr1.map(x =&gt; x.split(&quot; &quot;));</span><br><span class="line">// [[&quot;it&apos;s&quot;,&quot;Sunny&quot;,&quot;in&quot;],[&quot;&quot;],[&quot;California&quot;]]</span><br><span class="line"></span><br><span class="line">arr1.flatMap(x =&gt; x.split(&quot; &quot;));</span><br><span class="line">// [&quot;it&apos;s&quot;,&quot;Sunny&quot;,&quot;in&quot;, &quot;&quot;, &quot;California&quot;]</span><br></pre></td></tr></table></figure><h5 id="14-arrayprototypeforeach"><a class="markdownIt-Anchor" href="#14-arrayprototypeforeach"></a> 14. Array.prototype.forEach()</h5><p><strong>forEach()</strong> 方法为每个数组元素执行一次提供的函数</p><blockquote><p>arr.forEach(callback(currentValue [, index [, array]])[, thisArg]);</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">array1.forEach(function(element) &#123;</span><br><span class="line">  console.log(element);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// expected output: &quot;a&quot;</span><br><span class="line">// expected output: &quot;b&quot;</span><br><span class="line">// expected output: &quot;c&quot;</span><br></pre></td></tr></table></figure><h5 id="15-arrayprototypeincludes"><a class="markdownIt-Anchor" href="#15-arrayprototypeincludes"></a> 15. Array.prototype.includes()</h5><p><strong>includes()</strong> 方法确定数组是否在其条目中包含某个值，并在适当时返回true或false</p><blockquote><p>arr.includes(valueToFind[, fromIndex])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">console.log(array1.includes(2));</span><br><span class="line">// expected output: true</span><br><span class="line"></span><br><span class="line">var pets = [&apos;cat&apos;, &apos;dog&apos;, &apos;bat&apos;];</span><br><span class="line"></span><br><span class="line">console.log(pets.includes(&apos;cat&apos;));</span><br><span class="line">// expected output: true</span><br><span class="line"></span><br><span class="line">console.log(pets.includes(&apos;at&apos;));</span><br><span class="line">// expected output: false</span><br></pre></td></tr></table></figure><h5 id="16-arrayprototypeindexof"><a class="markdownIt-Anchor" href="#16-arrayprototypeindexof"></a> 16. Array.prototype.indexOf()</h5><p><strong>indexOf()</strong> 方法返回可在数组中找到给定元素的第一个索引，如果不存在则返回-1</p><blockquote><p>arr.indexOf(searchElement[, fromIndex])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var beasts = [&apos;ant&apos;, &apos;bison&apos;, &apos;camel&apos;, &apos;duck&apos;, &apos;bison&apos;];</span><br><span class="line"></span><br><span class="line">console.log(beasts.indexOf(&apos;bison&apos;));</span><br><span class="line">// expected output: 1</span><br><span class="line"></span><br><span class="line">// start from index 2</span><br><span class="line">console.log(beasts.indexOf(&apos;bison&apos;, 2));</span><br><span class="line">// expected output: 4</span><br><span class="line"></span><br><span class="line">console.log(beasts.indexOf(&apos;giraffe&apos;));</span><br><span class="line">// expected output: -1</span><br></pre></td></tr></table></figure><h5 id="17-arrayprototypejoin"><a class="markdownIt-Anchor" href="#17-arrayprototypejoin"></a> 17. Array.prototype.join()</h5><p><strong>join()</strong> 方法通过连接数组（或类数组对象）中的所有元素（用逗号或指定的分隔符字符串分隔）来创建并返回一个新字符串。 如果数组只有一个项目，那么将返回该项目而不使用分隔符</p><blockquote><p>arr.join([separator])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ar elements = [&apos;Fire&apos;, &apos;Air&apos;, &apos;Water&apos;];</span><br><span class="line"></span><br><span class="line">console.log(elements.join());</span><br><span class="line">// expected output: &quot;Fire,Air,Water&quot;</span><br><span class="line"></span><br><span class="line">console.log(elements.join(&apos;&apos;));</span><br><span class="line">// expected output: &quot;FireAirWater&quot;</span><br><span class="line"></span><br><span class="line">console.log(elements.join(&apos;-&apos;));</span><br><span class="line">// expected output: &quot;Fire-Air-Water&quot;</span><br></pre></td></tr></table></figure><h5 id="18-arrayprototypekeys"><a class="markdownIt-Anchor" href="#18-arrayprototypekeys"></a> 18. Array.prototype.keys()</h5><p><strong>keys()</strong> 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键</p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">var iterator = array1.keys(); </span><br><span class="line">  </span><br><span class="line">for (let key of iterator) &#123;</span><br><span class="line">  console.log(key); // expected output: 0 1 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="19-arrayprototypelastindexof"><a class="markdownIt-Anchor" href="#19-arrayprototypelastindexof"></a> 19. Array.prototype.lastIndexOf()</h5><p><strong>lastIndexOf()</strong> 方法返回可在数组中找到给定元素的最后一个索引，如果不存在则返回-1。 从fromIndex开始向后搜索数组</p><blockquote><p>arr.lastIndexOf(searchElement[, fromIndex])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var animals = [&apos;Dodo&apos;, &apos;Tiger&apos;, &apos;Penguin&apos;, &apos;Dodo&apos;];</span><br><span class="line"></span><br><span class="line">console.log(animals.lastIndexOf(&apos;Dodo&apos;));</span><br><span class="line">// expected output: 3</span><br><span class="line"></span><br><span class="line">console.log(animals.lastIndexOf(&apos;Penguin&apos;, 1));</span><br><span class="line">// expected output: -1</span><br></pre></td></tr></table></figure><h5 id="20-arrayprototypemap"><a class="markdownIt-Anchor" href="#20-arrayprototypemap"></a> 20. Array.prototype.map()</h5><p><strong>map()</strong> 方法创建一个新数组，其结果是在调用数组中的每个元素上调用提供的函数</p><blockquote><p>var new_array = arr.map(function callback(currentValue[, index[, array]]) {<br>// Return element for new_array<br>}[, thisArg])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [1, 4, 9, 16];</span><br><span class="line"></span><br><span class="line">// pass a function to map</span><br><span class="line">const map1 = array1.map(x =&gt; x * 2);</span><br><span class="line"></span><br><span class="line">console.log(map1);</span><br><span class="line">// expected output: Array [2, 8, 18, 32]</span><br></pre></td></tr></table></figure><h5 id="21-arrayprototypepop"><a class="markdownIt-Anchor" href="#21-arrayprototypepop"></a> 21. Array.prototype.pop()</h5><p><strong>pop()</strong> 方法从数组中删除最后一个元素并返回该元素。 此方法更改数组的长度。</p><blockquote><p>arr.pop()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var plants = [&apos;broccoli&apos;, &apos;cauliflower&apos;, &apos;cabbage&apos;, &apos;kale&apos;, &apos;tomato&apos;];</span><br><span class="line"></span><br><span class="line">console.log(plants.pop());</span><br><span class="line">// expected output: &quot;tomato&quot;</span><br><span class="line"></span><br><span class="line">console.log(plants);</span><br><span class="line">// expected output: Array [&quot;broccoli&quot;, &quot;cauliflower&quot;, &quot;cabbage&quot;, &quot;kale&quot;]</span><br><span class="line"></span><br><span class="line">plants.pop();</span><br><span class="line"></span><br><span class="line">console.log(plants);</span><br><span class="line">// expected output: Array [&quot;broccoli&quot;, &quot;cauliflower&quot;, &quot;cabbage&quot;]</span><br></pre></td></tr></table></figure><h5 id="22-arrayprototypepush"><a class="markdownIt-Anchor" href="#22-arrayprototypepush"></a> 22. Array.prototype.push()</h5><p><strong>push()</strong> 方法将一个或多个元素添加到数组的末尾，并返回数组的新长度</p><blockquote><p>arr.push(element1[, …[, elementN]])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var animals = [&apos;pigs&apos;, &apos;goats&apos;, &apos;sheep&apos;];</span><br><span class="line"></span><br><span class="line">console.log(animals.push(&apos;cows&apos;));</span><br><span class="line">// expected output: 4</span><br><span class="line"></span><br><span class="line">console.log(animals);</span><br><span class="line">// expected output: Array [&quot;pigs&quot;, &quot;goats&quot;, &quot;sheep&quot;, &quot;cows&quot;]</span><br><span class="line"></span><br><span class="line">animals.push(&apos;chickens&apos;);</span><br><span class="line"></span><br><span class="line">console.log(animals);</span><br><span class="line">// expected output: Array [&quot;pigs&quot;, &quot;goats&quot;, &quot;sheep&quot;, &quot;cows&quot;, &quot;chickens&quot;]</span><br></pre></td></tr></table></figure><h5 id="23-arrayprototypereduce"><a class="markdownIt-Anchor" href="#23-arrayprototypereduce"></a> 23. Array.prototype.reduce()</h5><p><strong>reduce()</strong> 方法在数组的每个元素上执行reducer函数（您提供），从而产生单个输出值</p><blockquote><p>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const array1 = [1, 2, 3, 4];</span><br><span class="line">const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;</span><br><span class="line"></span><br><span class="line">// 1 + 2 + 3 + 4</span><br><span class="line">console.log(array1.reduce(reducer));</span><br><span class="line">// expected output: 10</span><br><span class="line"></span><br><span class="line">// 5 + 1 + 2 + 3 + 4</span><br><span class="line">console.log(array1.reduce(reducer, 5));</span><br><span class="line">// expected output: 15</span><br></pre></td></tr></table></figure><h5 id="24-arrayprototypereduceright"><a class="markdownIt-Anchor" href="#24-arrayprototypereduceright"></a> 24. Array.prototype.reduceRight()</h5><p><strong>reduceRight()</strong> 方法对累加器和数组的每个值（从右到左）应用函数以将其减少为单个值</p><blockquote><p>arr.reduceRight(callback(accumulator, currentValue[, index[, array]])[, initialValue])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const array1 = [[0, 1], [2, 3], [4, 5]].reduceRight(</span><br><span class="line">  (accumulator, currentValue) =&gt; accumulator.concat(currentValue)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(array1);</span><br><span class="line">// expected output: Array [4, 5, 2, 3, 0, 1]</span><br></pre></td></tr></table></figure><h5 id="25-arrayprototypereverse"><a class="markdownIt-Anchor" href="#25-arrayprototypereverse"></a> 25. Array.prototype.reverse()</h5><p><strong>reverse()</strong> 方法将数组反转到位。 第一个数组元素成为最后一个，最后一个数组元素成为第一个</p><blockquote><p>a.reverse()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;];</span><br><span class="line">console.log(&apos;array1: &apos;, array1);</span><br><span class="line">// expected output: Array [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]</span><br><span class="line"></span><br><span class="line">var reversed = array1.reverse(); </span><br><span class="line">console.log(&apos;reversed: &apos;, reversed);</span><br><span class="line">// expected output: Array [&apos;three&apos;, &apos;two&apos;, &apos;one&apos;]</span><br><span class="line"></span><br><span class="line">/* Careful: reverse is destructive. It also changes</span><br><span class="line">the original array */ </span><br><span class="line">console.log(&apos;array1: &apos;, array1);</span><br><span class="line">// expected output: Array [&apos;three&apos;, &apos;two&apos;, &apos;one&apos;]</span><br></pre></td></tr></table></figure><h5 id="26-arrayprototypeshift"><a class="markdownIt-Anchor" href="#26-arrayprototypeshift"></a> 26. Array.prototype.shift()</h5><p><strong>shift()</strong> 方法从数组中删除第一个元素并返回已删除的元素。 此方法更改数组的长度</p><blockquote><p>arr.shift()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">var firstElement = array1.shift();</span><br><span class="line"></span><br><span class="line">console.log(array1);</span><br><span class="line">// expected output: Array [2, 3]</span><br><span class="line"></span><br><span class="line">console.log(firstElement);</span><br><span class="line">// expected output: 1</span><br></pre></td></tr></table></figure><h5 id="27-arrayprototypeslice"><a class="markdownIt-Anchor" href="#27-arrayprototypeslice"></a> 27. Array.prototype.slice()</h5><p><strong>slice()</strong> 方法将数组的一部分的浅表副本返回到从头到尾选择的新数组对象（不包括结尾），其中begin和end表示该数组中项的索引。 原始数组不会被修改</p><blockquote><p>arr.slice([begin[, end]])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var animals = [&apos;ant&apos;, &apos;bison&apos;, &apos;camel&apos;, &apos;duck&apos;, &apos;elephant&apos;];</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(2));</span><br><span class="line">// expected output: Array [&quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(2, 4));</span><br><span class="line">// expected output: Array [&quot;camel&quot;, &quot;duck&quot;]</span><br><span class="line"></span><br><span class="line">console.log(animals.slice(1, 5));</span><br><span class="line">// expected output: Array [&quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</span><br></pre></td></tr></table></figure><h5 id="28-arrayprototypesome"><a class="markdownIt-Anchor" href="#28-arrayprototypesome"></a> 28. # Array.prototype.some()</h5><p><strong>some()</strong> 方法测试数组中是否至少有一个元素通过了由提供的函数实现的测试。 它返回一个布尔值</p><blockquote><p>arr.some(callback(element[, index[, array]])[, thisArg])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var array = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">var even = function(element) &#123;</span><br><span class="line">  // checks whether an element is even</span><br><span class="line">  return element % 2 === 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(array.some(even));</span><br><span class="line">// expected output: true</span><br></pre></td></tr></table></figure><h5 id="29-arrayprototypesort"><a class="markdownIt-Anchor" href="#29-arrayprototypesort"></a> 29. Array.prototype.sort()</h5><p><strong>sort()</strong> 方法对数组中的元素进行排序并返回已排序的数组。 默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的。</p><p>由于取决于实现，因此无法保证排序的时间和空间复杂性。</p><blockquote><p>arr.sort([compareFunction])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var months = [&apos;March&apos;, &apos;Jan&apos;, &apos;Feb&apos;, &apos;Dec&apos;];</span><br><span class="line">months.sort();</span><br><span class="line">console.log(months);</span><br><span class="line">// expected output: Array [&quot;Dec&quot;, &quot;Feb&quot;, &quot;Jan&quot;, &quot;March&quot;]</span><br><span class="line"></span><br><span class="line">var array1 = [1, 30, 4, 21, 100000];</span><br><span class="line">array1.sort();</span><br><span class="line">console.log(array1);</span><br><span class="line">// expected output: Array [1, 100000, 21, 30, 4]</span><br></pre></td></tr></table></figure><h5 id="30-arrayprototypesplice"><a class="markdownIt-Anchor" href="#30-arrayprototypesplice"></a> 30. Array.prototype.splice()</h5><p><strong>splice()</strong> 方法通过删除或替换现有元素和/或在适当位置添加新元素来更改数组的内容</p><blockquote><p>var arrDeletedItems = array.splice(start[, deleteCount[, item1[, item2[, …]]]])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var months = [&apos;Jan&apos;, &apos;March&apos;, &apos;April&apos;, &apos;June&apos;];</span><br><span class="line">months.splice(1, 0, &apos;Feb&apos;);</span><br><span class="line">// inserts at index 1</span><br><span class="line">console.log(months);</span><br><span class="line">// expected output: Array [&apos;Jan&apos;, &apos;Feb&apos;, &apos;March&apos;, &apos;April&apos;, &apos;June&apos;]</span><br><span class="line"></span><br><span class="line">months.splice(4, 1, &apos;May&apos;);</span><br><span class="line">// replaces 1 element at index 4</span><br><span class="line">console.log(months);</span><br><span class="line">// expected output: Array [&apos;Jan&apos;, &apos;Feb&apos;, &apos;March&apos;, &apos;April&apos;, &apos;May&apos;]</span><br></pre></td></tr></table></figure><h5 id="31-arrayprototypeunshift"><a class="markdownIt-Anchor" href="#31-arrayprototypeunshift"></a> 31. Array.prototype.unshift()</h5><p><strong>unshift()</strong> 方法将一个或多个元素添加到数组的开头并返回数组的新长度</p><blockquote><p>arr.unshift(element1[, …[, elementN]])</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">console.log(array1.unshift(4, 5));</span><br><span class="line">// expected output: 5</span><br><span class="line"></span><br><span class="line">console.log(array1);</span><br><span class="line">// expected output: Array [4, 5, 1, 2, 3]</span><br></pre></td></tr></table></figure><h5 id="32-arrayprototypevalues"><a class="markdownIt-Anchor" href="#32-arrayprototypevalues"></a> 32. Array.prototype.values()</h5><p><strong>values()</strong> 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的值</p><blockquote><p>arr.values()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">const iterator = array1.values();</span><br><span class="line"></span><br><span class="line">for (const value of iterator) &#123;</span><br><span class="line">  console.log(value); // expected output: &quot;a&quot; &quot;b&quot; &quot;c&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="33-arrayprototypetolocalestring"><a class="markdownIt-Anchor" href="#33-arrayprototypetolocalestring"></a> 33. Array.prototype.toLocaleString()</h5><p><strong>toLocaleString()</strong> 方法返回表示数组元素的字符串。 使用toLocaleString方法将元素转换为字符串，并且这些字符串由特定于语言环境的字符串（例如逗号“，”）分隔</p><blockquote><p>arr.toLocaleString([locales[, options]]);</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [1, &apos;a&apos;, new Date(&apos;21 Dec 1997 14:12:00 UTC&apos;)];</span><br><span class="line">var localeString = array1.toLocaleString(&apos;en&apos;, &#123;timeZone: &quot;UTC&quot;&#125;);</span><br><span class="line"></span><br><span class="line">console.log(localeString);</span><br><span class="line">// expected output: &quot;1,a,12/21/1997, 2:12:00 PM&quot;,</span><br><span class="line">// This assumes &quot;en&quot; locale and UTC timezone - your results may vary</span><br></pre></td></tr></table></figure><h5 id="34-arrayprototypetostring"><a class="markdownIt-Anchor" href="#34-arrayprototypetostring"></a> 34. Array.prototype.toString()</h5><p><strong>toString()</strong> 方法返回表示指定数组及其元素的字符串</p><blockquote><p>arr.toString()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array1 = [1, 2, &apos;a&apos;, &apos;1a&apos;];</span><br><span class="line"></span><br><span class="line">console.log(array1.toString());</span><br><span class="line">// expected output: &quot;1,2,a,1a&quot;</span><br></pre></td></tr></table></figure><h5 id="35-arrayprototypeiterator"><a class="markdownIt-Anchor" href="#35-arrayprototypeiterator"></a> 35. Array.prototype<a href>@@iterator</a></h5><p><strong>@@iterator</strong> 属性的初始值与values（）属性的初始值是相同的函数对象。</p><blockquote><p>arr<a href>Symbol.iterator</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];</span><br><span class="line">var eArr = arr[Symbol.iterator]();</span><br><span class="line">// your browser must support for..of loop</span><br><span class="line">// and let-scoped variables in for loops</span><br><span class="line">// const and var could also be used</span><br><span class="line">for (let letter of eArr) &#123;</span><br><span class="line">  console.log(letter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Array
    
    </summary>
    
      <category term="JavaScript" scheme="https://wzes.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://wzes.github.io/tags/JavaScript/"/>
    
      <category term="Array" scheme="https://wzes.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>React Redux v0.2.1 源码学习</title>
    <link href="https://wzes.github.io/2019/08/25/JavaScript/Redux%20V0.2.1/"/>
    <id>https://wzes.github.io/2019/08/25/JavaScript/Redux V0.2.1/</id>
    <published>2019-08-25T11:30:16.000Z</published>
    <updated>2019-09-01T15:01:10.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>这周突然想学习一下状态管理的写法。看看业界是怎么实现的，之前使用过 redux，那就先从 redux 下手吧，但是，一上来就看最新版本的代码，不太适合新手学习，一方面最新版本已经发展n多年了，功能已经非常完善（代码多难懂），另一方面直接看最新的不了解这个工具是怎么设计出来的。于是就打算学习最早的发布版本 v0.2.1</p><p>先来说下我认识的一般的状态管理的基本路子：</p><blockquote><p>全局只存在 <strong>唯一state</strong>，而前端不直接改变 state，而是通过 <strong>action</strong> 去改变 state</p></blockquote><h3 id="helloworld"><a class="markdownIt-Anchor" href="#helloworld"></a> HelloWorld</h3><p>一个计数器的栗子，目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">counter</span><br><span class="line">├── App.js</span><br><span class="line">├── Counter.js</span><br><span class="line">├── actions</span><br><span class="line">│   ├── CounterActions.js</span><br><span class="line">│   └── index.js</span><br><span class="line">├── constants</span><br><span class="line">│   └── ActionTypes.js</span><br><span class="line">├── dispatcher.js</span><br><span class="line">└── stores</span><br><span class="line">    ├── CounterStore.js</span><br><span class="line">    └── index.js</span><br></pre></td></tr></table></figure><h4 id="actions"><a class="markdownIt-Anchor" href="#actions"></a> actions</h4><p>函数，返回一个带 type 的对象，或者返回一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  INCREMENT_COUNTER,</span><br><span class="line">  DECREMENT_COUNTER</span><br><span class="line">&#125; from &apos;../constants/ActionTypes&apos;;</span><br><span class="line"></span><br><span class="line">export function increment() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: INCREMENT_COUNTER</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function incrementAsync() &#123;</span><br><span class="line">  return dispatch =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      dispatch(increment());</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function decrement() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: DECREMENT_COUNTER</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="store"><a class="markdownIt-Anchor" href="#store"></a> store</h4><p>返回一个函数，参数 state 和 action，当 state 为空时返回初始值，表示初始化。根据 action 的 type 值，进行相应的做法，返回一个新的 state。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  INCREMENT_COUNTER,</span><br><span class="line">  DECREMENT_COUNTER</span><br><span class="line">&#125; from &apos;../constants/ActionTypes&apos;;</span><br><span class="line"></span><br><span class="line">const initialState = &#123; counter: 0 &#125;;</span><br><span class="line"></span><br><span class="line">function incremenent(&#123; counter &#125;) &#123;</span><br><span class="line">  return &#123; counter: counter + 1 &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decremenent(&#123; counter &#125;) &#123;</span><br><span class="line">  return &#123; counter: counter - 1 &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function CounterStore(state, action) &#123;</span><br><span class="line">  if (!state) &#123;</span><br><span class="line">    return initialState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">  case INCREMENT_COUNTER:</span><br><span class="line">    return incremenent(state, action);</span><br><span class="line">  case DECREMENT_COUNTER:</span><br><span class="line">    return decremenent(state, action);</span><br><span class="line">  default:</span><br><span class="line">    return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入口 App.js 你会发现 @provides(dispatcher) 这个奇怪的东西，在 React 里面还经常出现，装饰器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import Counter from &apos;./Counter&apos;;</span><br><span class="line">import &#123; provides &#125; from &apos;redux&apos;;</span><br><span class="line">import dispatcher from &apos;./dispatcher&apos;;</span><br><span class="line"></span><br><span class="line">@provides(dispatcher)</span><br><span class="line">export default class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Counter /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Couter.js，同样，也出现 performs（方法），observes（观察者）等关键字。使用 state 直接使用 this.props 解构赋值即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123; performs, observes &#125; from &apos;redux&apos;;</span><br><span class="line"></span><br><span class="line">@performs(&apos;increment&apos;, &apos;decrement&apos;)</span><br><span class="line">@observes(&apos;CounterStore&apos;)</span><br><span class="line">export default class Counter &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; increment, decrement &#125; = this.props;</span><br><span class="line">    return (</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        Clicked: &#123;this.props.counter&#125; times</span><br><span class="line">        &#123;&apos; &apos;&#125;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; increment()&#125;&gt;+&lt;/button&gt;</span><br><span class="line">        &#123;&apos; &apos;&#125;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; decrement()&#125;&gt;-&lt;/button&gt;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些关键字是早起 Redux 状态管理的关键，现在的版本应该已经不使用这种方式了。</p><h3 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h3><h4 id="dispatcher"><a class="markdownIt-Anchor" href="#dispatcher"></a> dispatcher</h4><p>通过 provides 将 dispatcher 注入到 App 中，其中，dispatcher 是通过 createDispatcher 创建，并调用了 dispatcher.receive(stores, actions) 进行绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import * as stores from &apos;./stores/index&apos;;</span><br><span class="line">import * as actions from &apos;./actions/index&apos;;</span><br><span class="line">import &#123; createDispatcher &#125; from &apos;redux&apos;;</span><br><span class="line"></span><br><span class="line">const dispatcher =</span><br><span class="line">  module.hot &amp;&amp; module.hot.data &amp;&amp; module.hot.data.dispatcher ||</span><br><span class="line">  createDispatcher();</span><br><span class="line"></span><br><span class="line">dispatcher.receive(stores, actions);</span><br><span class="line"></span><br><span class="line">module.hot.dispose(data =&gt; &#123;</span><br><span class="line">  data.dispatcher = dispatcher;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default dispatcher;</span><br></pre></td></tr></table></figure><p>receive 方法，actionCreator 将 action 进行封装，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Provide a way to receive new stores and actions</span><br><span class="line">  function receive(nextStores, nextActionCreators) &#123;</span><br><span class="line">    stores = nextStores;</span><br><span class="line">    actionCreators = mapValues(nextActionCreators, wrapActionCreator);</span><br><span class="line"></span><br><span class="line">    // Merge the observers</span><br><span class="line">    observers = mapValues(stores,</span><br><span class="line">      (store, key) =&gt; observers[key] || []</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // Dispatch to initialize stores</span><br><span class="line">    if (currentTransaction) &#123;</span><br><span class="line">      updateState(committedState);</span><br><span class="line">      currentTransaction.forEach(dispatch);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      dispatch(BOOTSTRAP_STORE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>action 进行转化返回一个 dispatchAction 函数，如果 action 为函数，则先执行函数，把 dispatchInTransaction 作为参数传入，这样可以在 action 内部使用该函数了，否则使用 dispatchInTransaction 函数调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Bind action creator to the dispatcher</span><br><span class="line"> function wrapActionCreator(actionCreator) &#123;</span><br><span class="line">   return function dispatchAction(...args) &#123;</span><br><span class="line">     const action = actionCreator(...args);</span><br><span class="line">     if (typeof action === &apos;function&apos;) &#123;</span><br><span class="line">       // Async action creator</span><br><span class="line">       action(dispatchInTransaction);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       // Sync action creator</span><br><span class="line">       dispatchInTransaction(action);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>dispatchInTransaction ，执行 dispatch ，计算 nextState，执行 updateState 更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  // Dispatch in the context of current transaction</span><br><span class="line">  function dispatchInTransaction(action) &#123;</span><br><span class="line">    if (currentTransaction) &#123;</span><br><span class="line">      currentTransaction.push(action);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(action);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// Reassign the current state on each dispatch</span><br><span class="line">  function dispatch(action) &#123;</span><br><span class="line">    if (typeof action.type !== &apos;string&apos;) &#123;</span><br><span class="line">      throw new Error(&apos;Action type must be a string.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const nextState = computeNextState(currentState, action);</span><br><span class="line">    updateState(nextState);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>获取 store，也就是 CounterStore，把参数传入，获取新的 state</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// To compute the next state, combine the next states of every store</span><br><span class="line">function computeNextState(state, action) &#123;</span><br><span class="line">  return mapValues(stores,</span><br><span class="line">    (store, key) =&gt; store(state[key], action)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>updateState 实现，计算变化的 changedKeys，执行  emitChange 进行更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Update state and emit change if needed</span><br><span class="line">function updateState(nextState) &#123;</span><br><span class="line">  // Swap the state</span><br><span class="line">  const previousState = currentState;</span><br><span class="line">  currentState = nextState;</span><br><span class="line"></span><br><span class="line">  // Notify the observers</span><br><span class="line">  const changedKeys = Object.keys(currentState).filter(key =&gt;</span><br><span class="line">    currentState[key] !== previousState[key]</span><br><span class="line">  );</span><br><span class="line">  emitChange(changedKeys);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emitChange，获取需要通知的 observers，调用通知函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Notify observers about the changed stores</span><br><span class="line">  function emitChange(changedKeys) &#123;</span><br><span class="line">    if (!changedKeys.length) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Gather the affected observers</span><br><span class="line">    const notifyObservers = [];</span><br><span class="line">    changedKeys.forEach(key =&gt; &#123;</span><br><span class="line">      observers[key].forEach(o =&gt; &#123;</span><br><span class="line">        if (notifyObservers.indexOf(o) === -1) &#123;</span><br><span class="line">          notifyObservers.push(o);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Emit change</span><br><span class="line">    notifyObservers.forEach(o =&gt; o());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里可能有点疑问，obersevers 是什么，从哪来？往下看～</p><h4 id="observesjs"><a class="markdownIt-Anchor" href="#observesjs"></a> observes.js</h4><p>将 组件进行装饰，构造函数中有一个</p><blockquote><p>this.unobserve = this.context.observeStores(storeKeys, this.handleChange);<br>context 就是 dispatcher，</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;</span><br><span class="line">import pick from &apos;lodash/object/pick&apos;;</span><br><span class="line">import identity from &apos;lodash/utility/identity&apos;;</span><br><span class="line"></span><br><span class="line">const contextTypes = &#123;</span><br><span class="line">  observeStores: PropTypes.func.isRequired</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default function connect(...storeKeys) &#123;</span><br><span class="line">  let mapState = identity;</span><br><span class="line"></span><br><span class="line">  // Last argument may be a custom mapState function</span><br><span class="line">  const lastIndex = storeKeys.length - 1;</span><br><span class="line">  if (typeof storeKeys[lastIndex] === &apos;function&apos;) &#123;</span><br><span class="line">    [mapState] = storeKeys.splice(lastIndex, 1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return function (DecoratedComponent) &#123;</span><br><span class="line">    const wrappedDisplayName =</span><br><span class="line">      DecoratedComponent.displayName ||</span><br><span class="line">      DecoratedComponent.name ||</span><br><span class="line">      &apos;Component&apos;;</span><br><span class="line"></span><br><span class="line">    return class extends Component &#123;</span><br><span class="line">      static displayName = `ReduxObserves($&#123;wrappedDisplayName&#125;)`;</span><br><span class="line">      static contextTypes = contextTypes;</span><br><span class="line"></span><br><span class="line">      constructor(props, context) &#123;</span><br><span class="line">        super(props, context);</span><br><span class="line">        this.handleChange = this.handleChange.bind(this);</span><br><span class="line">        this.unobserve = this.context.observeStores(storeKeys, this.handleChange);</span><br><span class="line">      &#125;</span><br><span class="line">      ....</span><br><span class="line"></span><br><span class="line">      componentWillUnmount() &#123;</span><br><span class="line">        this.unobserve();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      render() &#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;DecoratedComponent &#123;...this.props&#125;</span><br><span class="line">                              &#123;...this.state&#125; /&gt;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatcher observeStores 方法，将需要监听的组件传入，以及 onChange 函数，作为回调使用。最后返回一个函数，移除监听，这个也太妙了吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Provide subscription and unsubscription</span><br><span class="line">  function observeStores(observedKeys, onChange) &#123;</span><br><span class="line">    // Emit the state update</span><br><span class="line">    function handleChange() &#123;</span><br><span class="line">      onChange(currentState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Synchronously emit the initial value</span><br><span class="line">    handleChange();</span><br><span class="line"></span><br><span class="line">    // Register the observer for each relevant key</span><br><span class="line">    observedKeys.forEach(key =&gt;</span><br><span class="line">      observers[key].push(handleChange)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // Let it unregister when the time comes</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">      observedKeys.forEach(key =&gt; &#123;</span><br><span class="line">        const index = observers[key].indexOf(handleChange);</span><br><span class="line">        observers[key].splice(index, 1);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当计算好 nextState 后，就会调用 observe 的 onChange 方法， onChange 方法也就是 装饰器里面的方法。最后调用自身的 updateState，使用 setState 进行组件更新。而这些 state 作为 props 传入了我们自己的组件，也就可以通过 this.props  拿到。完美～～～</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">handleChange(stateFromStores) &#123;</span><br><span class="line">  this.currentStateFromStores = pick(stateFromStores, storeKeys);</span><br><span class="line">  this.updateState(stateFromStores, this.props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  this.updateState(this.currentStateFromStores, nextProps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updateState(stateFromStores, props) &#123;</span><br><span class="line">  if (storeKeys.length === 1) &#123;</span><br><span class="line">    // Just give it the particular store state for convenience</span><br><span class="line">    stateFromStores = stateFromStores[storeKeys[0]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const state = mapState(stateFromStores, props);</span><br><span class="line">  if (this.state) &#123;</span><br><span class="line">    this.setState(state);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    this.state = state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="performs-组件"><a class="markdownIt-Anchor" href="#performs-组件"></a> performs 组件</h4><p>action 绑定到组件，可以通过 this.props ，通过 this.context.getActions() 拿到 actions</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;</span><br><span class="line">import pick from &apos;lodash/object/pick&apos;;</span><br><span class="line">import identity from &apos;lodash/utility/identity&apos;;</span><br><span class="line"></span><br><span class="line">const contextTypes = &#123;</span><br><span class="line">  getActions: PropTypes.func.isRequired</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default function performs(...actionKeys) &#123;</span><br><span class="line">  let mapActions = identity;</span><br><span class="line"></span><br><span class="line">  // Last argument may be a custom mapState function</span><br><span class="line">  const lastIndex = actionKeys.length - 1;</span><br><span class="line">  if (typeof actionKeys[lastIndex] === &apos;function&apos;) &#123;</span><br><span class="line">    [mapActions] = actionKeys.splice(lastIndex, 1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return function (DecoratedComponent) &#123;</span><br><span class="line">    const wrappedDisplayName =</span><br><span class="line">      DecoratedComponent.displayName ||</span><br><span class="line">      DecoratedComponent.name ||</span><br><span class="line">      &apos;Component&apos;;</span><br><span class="line"></span><br><span class="line">    return class extends Component &#123;</span><br><span class="line">      static displayName = `ReduxPerforms($&#123;wrappedDisplayName&#125;)`;</span><br><span class="line">      static contextTypes = contextTypes;</span><br><span class="line"></span><br><span class="line">      constructor(props, context) &#123;</span><br><span class="line">        super(props, context);</span><br><span class="line">        this.updateActions(props);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">        this.updateActions(nextProps);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      updateActions(props) &#123;</span><br><span class="line">        this.actions = mapActions(</span><br><span class="line">          pick(this.context.getActions(), actionKeys),</span><br><span class="line">          props</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      render() &#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;DecoratedComponent &#123;...this.props&#125;</span><br><span class="line">                              &#123;...this.actions&#125; /&gt;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就差不多了～<br>额外收获</p><h4 id="lodash"><a class="markdownIt-Anchor" href="#lodash"></a> Lodash</h4><ul><li><p>pick</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var object = &#123; &apos;user&apos;: &apos;fred&apos;, &apos;age&apos;: 40 &#125;;</span><br><span class="line">_.pick(object, &apos;user&apos;);</span><br><span class="line">// =&gt; &#123; &apos;user&apos;: &apos;fred&apos; &#125;</span><br><span class="line">_.pick(object, _.isString);</span><br><span class="line">// =&gt; &#123; &apos;user&apos;: &apos;fred&apos; &#125;</span><br></pre></td></tr></table></figure></li><li><p>identity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function identity(value) &#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mapValues</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_.mapValues(&#123; &apos;a&apos;: 1, &apos;b&apos;: 2 &#125;, function(n) &#123;</span><br><span class="line"> return n * 3;</span><br><span class="line">&#125;);</span><br><span class="line">// =&gt; &#123; &apos;a&apos;: 3, &apos;b&apos;: 6 &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h3><p>麻雀虽小，却能看透精髓～</p>]]></content>
    
    <summary type="html">
    
      React Redux
    
    </summary>
    
      <category term="JavaScript" scheme="https://wzes.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://wzes.github.io/tags/JavaScript/"/>
    
      <category term="React" scheme="https://wzes.github.io/tags/React/"/>
    
      <category term="Redux" scheme="https://wzes.github.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Node KoaJs 源码解析</title>
    <link href="https://wzes.github.io/2019/08/18/JavaScript/KoaJs/"/>
    <id>https://wzes.github.io/2019/08/18/JavaScript/KoaJs/</id>
    <published>2019-08-18T10:56:00.000Z</published>
    <updated>2019-09-01T15:01:02.864Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>又是一周过去了，常规学习不能断！但是选择什么主题呢？一时间不知道选什么好，于是又想起简单的 <strong>koajs</strong> 非常愉快的就选择他了 <a href="https://koajs.com/" target="_blank" rel="noopener">https://koajs.com/</a>，了解一下？</p><p>他是个什么东西呢？</p><blockquote><p>Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。</p></blockquote><h3 id="hello-world"><a class="markdownIt-Anchor" href="#hello-world"></a> hello world</h3><p>首先新建一个 node 项目，其实很简单，只需要一个 package.json 文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;koa-hello&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;node src/index.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;koa&quot;: &quot;^2.7.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i koa</span><br></pre></td></tr></table></figure><p>代码 index.js 文件，新建一个 koa 实例，使用 app.use 写一个 async 方法，设置 ctx.body 的值就可以了。最后使用 app.listen 启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;);</span><br><span class="line">const app = new Koa();</span><br><span class="line"></span><br><span class="line">app.use(async ctx =&gt; &#123;</span><br><span class="line">    ctx.body = &apos;Hello World&apos;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure><p>这样的话，一个 web 服务器就搭建好了，访问 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 就会得到 hello world 返回结果了。你可以尝试更改字段从而得到不同的返回结果。</p><h3 id="源码解析"><a class="markdownIt-Anchor" href="#源码解析"></a> 源码解析</h3><p>koa 的源码只有四个文件，不包含其他引用的话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> .</span><br><span class="line">├── History.md</span><br><span class="line">├── LICENSE</span><br><span class="line">├── Readme.md</span><br><span class="line">├── lib</span><br><span class="line">│   ├── application.js</span><br><span class="line">│   ├── context.js</span><br><span class="line">│   ├── request.js</span><br><span class="line">│   └── response.js</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure><p>主入口可以在 package.json 的 main 中得到，是 application.js，暂时先知道 middleware 是中间接，通常一个请求过来就会依次执行中间件的方法。</p><h4 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">module.exports = class Application extends Emitter &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Initialize a new `Application`.</span><br><span class="line">   *</span><br><span class="line">   * @api public</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line"></span><br><span class="line">    this.proxy = false;</span><br><span class="line">    this.middleware = [];</span><br><span class="line">    this.subdomainOffset = 2;</span><br><span class="line">    this.env = process.env.NODE_ENV || &apos;development&apos;;</span><br><span class="line">    this.context = Object.create(context);</span><br><span class="line">    this.request = Object.create(request);</span><br><span class="line">    this.response = Object.create(response);</span><br><span class="line">    if (util.inspect.custom) &#123;</span><br><span class="line">      this[util.inspect.custom] = this.inspect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app.use 其实就是添加一个中间件，我们通常使用 async 的函数，generator 被抛弃了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use(fn) &#123;</span><br><span class="line">  if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;middleware must be a function!&apos;);</span><br><span class="line">  if (isGeneratorFunction(fn)) &#123;</span><br><span class="line">    deprecate(&apos;Support for generators will be removed in v3. &apos; +</span><br><span class="line">              &apos;See the documentation for examples of how to convert old middleware &apos; +</span><br><span class="line">              &apos;https://github.com/koajs/koa/blob/master/docs/migration.md&apos;);</span><br><span class="line">    fn = convert(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  debug(&apos;use %s&apos;, fn._name || fn.name || &apos;-&apos;);</span><br><span class="line">  this.middleware.push(fn);</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app.listen 创建一个服务器，监听 3000 端口，http.createServer 是 node 的服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listen(...args) &#123;</span><br><span class="line">  debug(&apos;listen&apos;);</span><br><span class="line">  const server = http.createServer(this.callback());</span><br><span class="line">  return server.listen(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>callback 是提供一个函数，所有请求都会走到这个函数里面进行处理。每次请求过来都会调用这个函数，所以，我们可以看到，每次请求都会创建一个 ctx 的对象。<br>compose 的作用就是将所有的中间件整合成一个函数，使用 next 函数继续调用下一个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">callback() &#123;</span><br><span class="line">  const fn = compose(this.middleware);</span><br><span class="line"></span><br><span class="line">  if (!this.listenerCount(&apos;error&apos;)) this.on(&apos;error&apos;, this.onerror);</span><br><span class="line"></span><br><span class="line">  const handleRequest = (req, res) =&gt; &#123;</span><br><span class="line">    const ctx = this.createContext(req, res);</span><br><span class="line">    return this.handleRequest(ctx, fn);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return handleRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化 ctx 对象，这里 this.request 将会把原生的 request 参数进行解析，方便我们进行相关参数获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Initialize a new context.</span><br><span class="line"> *</span><br><span class="line"> * @api private</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">createContext(req, res) &#123;</span><br><span class="line">  const context = Object.create(this.context);</span><br><span class="line">  const request = context.request = Object.create(this.request);</span><br><span class="line">  const response = context.response = Object.create(this.response);</span><br><span class="line">  context.app = request.app = response.app = this;</span><br><span class="line">  context.req = request.req = response.req = req;</span><br><span class="line">  context.res = request.res = response.res = res;</span><br><span class="line">  request.ctx = response.ctx = context;</span><br><span class="line">  request.response = response;</span><br><span class="line">  response.request = request;</span><br><span class="line">  context.originalUrl = request.originalUrl = req.url;</span><br><span class="line">  context.state = &#123;&#125;;</span><br><span class="line">  return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们之后就可以使用<br>** ctx.query.key ** 来获取 <a href="http://localhost:3000?key=value%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">http://localhost:3000?key=value，为什么可以使用</a> ctx.query 又可以获取参数呢，这个要靠 Object.create 的本事了，它相当于创造了一个对象，继承了原来的对象，而 this.request 有 query 的参数，而最为重要的是 this.context = Object.create(context); context 委托（使用了 Delegator）了这些 request 的相关属性和方法。【第一次体会到 js 委托，以前知识听说不知道是啥】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Request delegation.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">delegate(proto, &apos;request&apos;)</span><br><span class="line">  .access(&apos;method&apos;)</span><br><span class="line">  .access(&apos;query&apos;)</span><br><span class="line">  .access(&apos;path&apos;)</span><br><span class="line">  .access(&apos;url&apos;)</span><br><span class="line">  ....... // 省略</span><br></pre></td></tr></table></figure><p>handleRequest 请求处理，fnMiddleware 就是所有的中间件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">  const res = ctx.res;</span><br><span class="line">  res.statusCode = 404;</span><br><span class="line">  const onerror = err =&gt; ctx.onerror(err);</span><br><span class="line">  const handleResponse = () =&gt; respond(ctx);</span><br><span class="line">  onFinished(res, onerror);</span><br><span class="line">  return fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用完中间件以后，就执行 handleResponse 将数据返回，返回数据也就是将 ctx.body 拿出来，使用 response.end 返回数据，返回时，会对数据进行处理，在最后面可以体会到～</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Response helper.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">function respond(ctx) &#123;</span><br><span class="line">  // allow bypassing koa</span><br><span class="line">  if (false === ctx.respond) return;</span><br><span class="line"></span><br><span class="line">  if (!ctx.writable) return;</span><br><span class="line"></span><br><span class="line">  const res = ctx.res;</span><br><span class="line">  let body = ctx.body;</span><br><span class="line">  const code = ctx.status;</span><br><span class="line"></span><br><span class="line">  // ignore body</span><br><span class="line">  if (statuses.empty[code]) &#123;</span><br><span class="line">    // strip headers</span><br><span class="line">    ctx.body = null;</span><br><span class="line">    return res.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (&apos;HEAD&apos; == ctx.method) &#123;</span><br><span class="line">    if (!res.headersSent &amp;&amp; isJSON(body)) &#123;</span><br><span class="line">      ctx.length = Buffer.byteLength(JSON.stringify(body));</span><br><span class="line">    &#125;</span><br><span class="line">    return res.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // status body</span><br><span class="line">  if (null == body) &#123;</span><br><span class="line">    if (ctx.req.httpVersionMajor &gt;= 2) &#123;</span><br><span class="line">      body = String(code);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      body = ctx.message || String(code);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!res.headersSent) &#123;</span><br><span class="line">      ctx.type = &apos;text&apos;;</span><br><span class="line">      ctx.length = Buffer.byteLength(body);</span><br><span class="line">    &#125;</span><br><span class="line">    return res.end(body);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // responses</span><br><span class="line">  if (Buffer.isBuffer(body)) return res.end(body);</span><br><span class="line">  if (&apos;string&apos; == typeof body) return res.end(body);</span><br><span class="line">  if (body instanceof Stream) return body.pipe(res);</span><br><span class="line"></span><br><span class="line">  // body: json</span><br><span class="line">  body = JSON.stringify(body);</span><br><span class="line">  if (!res.headersSent) &#123;</span><br><span class="line">    ctx.length = Buffer.byteLength(body);</span><br><span class="line">  &#125;</span><br><span class="line">  res.end(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，基本的请求已经清楚了～～</p><h4 id="end"><a class="markdownIt-Anchor" href="#end"></a> End</h4><p>再来看一眼最简单的 http server 代码，对比一下，比 koa 代码的 hello world 相比并没有多复杂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">http.createServer(function (req, res) &#123;</span><br><span class="line">  res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;);</span><br><span class="line">  res.write(&apos;Hello World!&apos;);</span><br><span class="line">  res.end();</span><br><span class="line">&#125;).listen(8080);</span><br></pre></td></tr></table></figure><p>但是，获取参数，使用路由等等插件，koa 生态做了很多，非常方便，快来体验吧！</p>]]></content>
    
    <summary type="html">
    
      Node Server
    
    </summary>
    
      <category term="JavaScript" scheme="https://wzes.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://wzes.github.io/tags/JavaScript/"/>
    
      <category term="Node" scheme="https://wzes.github.io/tags/Node/"/>
    
      <category term="Koa" scheme="https://wzes.github.io/tags/Koa/"/>
    
  </entry>
  
  <entry>
    <title>Android 一个滑动组件的原理浅析</title>
    <link href="https://wzes.github.io/2019/08/11/Android/%E4%B8%80%E4%B8%AA%E6%BB%91%E5%8A%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <id>https://wzes.github.io/2019/08/11/Android/一个滑动组件的原理浅析/</id>
    <published>2019-08-11T06:47:16.000Z</published>
    <updated>2019-09-01T15:02:02.986Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>一个好的滑动不止能够响应手指的移动，而且还能响应 Fling（抛） 事件，响应手指的移动比较简单，手指移动多少距离，布局就移动多少距离；当快速滑动时，手指离开后，不能马上停止滑动，而是应该计算手指的移动速度，产生一个【抛】（Fling ）的动作，让内容继续滚动一段距离。这才是好的滑动组件。那么其中具体的设计究竟是如何呢，今天就来分析一波，借鉴 Android OverScroller 的实现。</p><h3 id="demo"><a class="markdownIt-Anchor" href="#demo"></a> Demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (mOverScroller.computeScrollOffset()) &#123;</span><br><span class="line">      // 获取 scrollY</span><br><span class="line">     int y = mOverScroller.getCurrY();</span><br><span class="line">     // 此处省略一堆控制滚动的代码</span><br><span class="line">     .....</span><br><span class="line">     // 更新</span><br><span class="line">    postInvalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h3><p>总体逻辑先梳理下，首先内容跟随手指移动而【移动】，手指离开时产生一个 【速度】，根据这个速度计算一个，此次滑动的【总时间】和【总距离】，之后可以计算每一个【时刻】对应的【位置】。那其中时刻与距离的对应关系是如何呢？看了一下 Android 的源码，计算关系之复杂，惨绝人寰，欲研又止！但这不重要，重要的是掌握全局。<br>一起来欣赏一下代码吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">         * Update the current position and velocity for current time. Returns</span><br><span class="line">         * true if update has been done and false if animation duration has been</span><br><span class="line">         * reached.</span><br><span class="line">         */</span><br><span class="line">        boolean update() &#123;</span><br><span class="line">            final long time = AnimationUtils.currentAnimationTimeMillis();</span><br><span class="line">            final long currentTime = time - mStartTime;</span><br><span class="line"></span><br><span class="line">            if (currentTime == 0) &#123;</span><br><span class="line">                // Skip work but report that we&apos;re still going if we have a nonzero duration.</span><br><span class="line">                return mDuration &gt; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (currentTime &gt; mDuration) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            double distance = 0.0;</span><br><span class="line">            switch (mState) &#123;</span><br><span class="line">                case SPLINE: &#123;</span><br><span class="line">                    final float t = (float) currentTime / mSplineDuration;</span><br><span class="line">                    final int index = (int) (NB_SAMPLES * t);</span><br><span class="line">                    float distanceCoef = 1.f;</span><br><span class="line">                    float velocityCoef = 0.f;</span><br><span class="line">                    if (index &lt; NB_SAMPLES) &#123;</span><br><span class="line">                        final float t_inf = (float) index / NB_SAMPLES;</span><br><span class="line">                        final float t_sup = (float) (index + 1) / NB_SAMPLES;</span><br><span class="line">                        final float d_inf = SPLINE_POSITION[index];</span><br><span class="line">                        final float d_sup = SPLINE_POSITION[index + 1];</span><br><span class="line">                        velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);</span><br><span class="line">                        distanceCoef = d_inf + (t - t_inf) * velocityCoef;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    distance = distanceCoef * mSplineDistance;</span><br><span class="line">                    mCurrVelocity = velocityCoef * mSplineDistance / mSplineDuration * 1000.0f;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                case BALLISTIC: &#123;</span><br><span class="line">                    final float t = currentTime / 1000.0f;</span><br><span class="line">                    mCurrVelocity = mVelocity + mDeceleration * t;</span><br><span class="line">                    distance = mVelocity * t + mDeceleration * t * t / 2.0f;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                .....</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mCurrentPosition = mStart + (int) Math.round(distance);</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>mCurrentPosition 就是某个时刻对应的位置，有趣的是 BALLISTIC 模式，还记得高中物理的重力加速度时间与距离的公式吗？是不是似曾相识？这算比较简单的公式，但我们今天但主角是 <strong>SPLINE</strong> 模式，ScrollView 但滑动正是使用了这个模式进行滑动，体验非常好！！！！公式有点复杂，就不洗洗研究了，喜欢的同学自行研究吧</p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>简单一个滚动，蕴藏的道理生不可测，一不小心就出现了物理知识点…学习还是挺有用的吧</p>]]></content>
    
    <summary type="html">
    
      Android
    
    </summary>
    
      <category term="Android" scheme="https://wzes.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://wzes.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Babel-Loader 自定义入门</title>
    <link href="https://wzes.github.io/2019/08/04/JavaScript/Babel%20Loader/"/>
    <id>https://wzes.github.io/2019/08/04/JavaScript/Babel Loader/</id>
    <published>2019-08-04T05:42:00.000Z</published>
    <updated>2019-09-01T15:00:46.690Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>突然觉得 babel-loader <a href="https://github.com/babel/babel-loader" target="_blank" rel="noopener">https://github.com/babel/babel-loader</a> 很好玩，比较贴近AST，然而编译原理一直是噩梦，没学懂，好在这东西不需要什么编译原理的知识。但还是涉及到语法解析等操作，所以拿过来学一学还是挺好的。</p><h3 id="什么是-babel"><a class="markdownIt-Anchor" href="#什么是-babel"></a> 什么是 Babel</h3><p>Babel 是一个工具链，主要用于将 ECMAScript 2015+ 代码转换为当前和旧版浏览器或环境中的向后兼容版本的 JavaScript。 以下是 Babel 可以为您做的主要事情：</p><ul><li>转换语法</li><li>目标环境中缺少Polyfill功能（通过@ babel / polyfill）源代码转换（codemods）</li><li>更多</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Babel Input: ES2015 arrow function</span><br><span class="line">[1, 2, 3].map((n) =&gt; n + 1);</span><br><span class="line"></span><br><span class="line">// Babel Output: ES5 equivalent</span><br><span class="line">[1, 2, 3].map(function(n) &#123;</span><br><span class="line">  return n + 1;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>代码转化就涉及到了语法解析，这便是我们的重点</p><h3 id="自定义"><a class="markdownIt-Anchor" href="#自定义"></a> 自定义</h3><p>首先新建一个项目 webpack 项目 <a href="https://github.com/wzes/babel-demo" target="_blank" rel="noopener">babel-demo</a><br>目录结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── babel-plugin-transform-class</span><br><span class="line">│   └── index.js</span><br><span class="line">├── dist</span><br><span class="line">│   └── bundle.js</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br><span class="line">│   └── index.js</span><br><span class="line">└── webpack.config.js</span><br></pre></td></tr></table></figure><p>新建 package.json 并使用 npm install 安装所需插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D babel-loader @babel/core @babel/preset-env webpack</span><br></pre></td></tr></table></figure><p><strong>package.json</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;&#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;@babel/core&quot;: &quot;^7.5.5&quot;,</span><br><span class="line">    &quot;@babel/preset-env&quot;: &quot;^7.5.5&quot;,</span><br><span class="line">    &quot;babel-loader&quot;: &quot;^8.0.6&quot;,</span><br><span class="line">    &quot;webpack&quot;: &quot;^4.39.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建 webpack 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;,</span><br><span class="line">  mode: &apos;development&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, &apos;dist&apos;),</span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        loader: &apos;babel-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          plugins: [</span><br><span class="line">            &quot;transform-class&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>module 里面的 rule 便是配置我们自定义的 babel 插件，<strong>transform-class</strong> 是插件名。</p><h3 id="手写插件"><a class="markdownIt-Anchor" href="#手写插件"></a> 手写插件</h3><p>下面是一个简单的插件<br>babel-plugin-transform-class/index.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// A plugin is just a function</span><br><span class="line">module.exports = function (&#123; types: t &#125;) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">      visitor: &#123;</span><br><span class="line">          Identifier(path) &#123;</span><br><span class="line">            let name = path.node.name; // reverse the name: JavaScript -&gt; tpircSavaJ</span><br><span class="line">            path.node.name = name.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 babel-plugin-transform-class 文件夹移动到 node-modules 目录下即可。当运行 webpack 的时候，便会运行这个插件，这个插件会把 node 的 name 做反转。</p><p>我们的 demo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function babel() &#123;</span><br><span class="line">  let javascript = &apos;hello babel&apos;;</span><br><span class="line">  console.log(javascript);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(&quot;function lebab() &#123;\n  let tpircsavaj = &apos;hello babel&apos;;\n  elosnoc.gol(tpircsavaj);\n&#125;\n\n//# sourceURL=webpack:///./src/index.js?&quot;);</span><br></pre></td></tr></table></figure><p>我们看到变量名都反转了。</p><p>我们还可以实现更多·····更多属性，方法在这里 <a href="https://babeljs.io/docs/en/next/babel-types.html" target="_blank" rel="noopener">https://babeljs.io/docs/en/next/babel-types.html</a></p><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h3><p>AST <a href="https://astexplorer.net/" target="_blank" rel="noopener">https://astexplorer.net/</a></p>]]></content>
    
    <summary type="html">
    
      Babel
    
    </summary>
    
      <category term="JavaScript" scheme="https://wzes.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://wzes.github.io/tags/JavaScript/"/>
    
      <category term="Node" scheme="https://wzes.github.io/tags/Node/"/>
    
      <category term="Babel" scheme="https://wzes.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>React Lazyload 源码解析</title>
    <link href="https://wzes.github.io/2019/07/28/JavaScript/React%20Lazyload/"/>
    <id>https://wzes.github.io/2019/07/28/JavaScript/React Lazyload/</id>
    <published>2019-07-28T03:59:00.000Z</published>
    <updated>2019-09-01T14:30:38.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>早在多年前，lazyload 已经出现了，懒加载在前端里边同样具有十分重要的意义。react-lazyload 的作用是当组件未出现在屏幕内时，不去挂载该组件，而是使用 placeholder 去渲染，让滚动使内容出现后，组件会被挂载。就是这么简单！例如，一个复杂的组件（非首屏内容），使用了懒加载后，渲染首屏就会节省很多资源，从而减少首屏渲染时间。</p><h3 id="demo"><a class="markdownIt-Anchor" href="#demo"></a> Demo</h3><p>源码地址 <a href="https://github.com/twobin/react-lazyload" target="_blank" rel="noopener">react-lazyload</a><br>Demo地址 <a href="https://twobin.github.io/react-lazyload/examples/" target="_blank" rel="noopener">Demo</a></p><h4 id="helloworld"><a class="markdownIt-Anchor" href="#helloworld"></a> HelloWorld</h4><p>将需要懒加载的组件使用 LazyLoad 包裹即可，最好使用 height 进行站位，否则该组件位置将会为 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;LazyLoad height=&#123;200&#125;&gt;</span><br><span class="line">    &lt;img src=&quot;tiger.jpg&quot; /&gt; /*</span><br><span class="line">                              Lazy loading images is supported out of box,</span><br><span class="line">                              no extra config needed, set `height` for better</span><br><span class="line">                              experience</span><br><span class="line">                             */</span><br><span class="line">  &lt;/LazyLoad&gt;</span><br></pre></td></tr></table></figure><h3 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h3><p>从源码角度分析～</p><h4 id="一览核心"><a class="markdownIt-Anchor" href="#一览核心"></a> 一览核心</h4><p>本小节摘取了最核心的代码，目的在于对 LazyLoad 组件有个最核心的认识，它的核心就是监听滚动事件，检查组件是否在屏幕内，如果在的话就显示，不在的话就不显示～</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class LazyLoad extends Component &#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">   on(scrollport, &apos;scroll&apos;, finalLazyLoadHandler, passiveEvent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return this.visible ?</span><br><span class="line">           this.props.children :</span><br><span class="line">             this.props.placeholder ?</span><br><span class="line">                this.props.placeholder :</span><br><span class="line">                &lt;div style=&#123;&#123; height: this.props.height &#125;&#125; className=&quot;lazyload-placeholder&quot; ref=&#123;this.setRef&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LazyLoad 的属性，透过属性，我们可以知道它大概有些什么功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">LazyLoad.propTypes = &#123;</span><br><span class="line">  once: PropTypes.bool,</span><br><span class="line">  height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),</span><br><span class="line">  offset: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),</span><br><span class="line">  overflow: PropTypes.bool, // 不是 window 滚动，而使用了 overflow: scroll </span><br><span class="line">  resize: PropTypes.bool, // 是否监听 resize</span><br><span class="line">  scroll: PropTypes.bool, // 是否监听滚动</span><br><span class="line">  children: PropTypes.node,</span><br><span class="line">  throttle: PropTypes.oneOfType([PropTypes.number, PropTypes.bool]),</span><br><span class="line">  debounce: PropTypes.oneOfType([PropTypes.number, PropTypes.bool]),</span><br><span class="line">  placeholder: PropTypes.node,</span><br><span class="line">  scrollContainer: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),</span><br><span class="line">  unmountIfInvisible: PropTypes.bool,</span><br><span class="line">  preventLoading: PropTypes.bool</span><br><span class="line">&#125;;</span><br><span class="line">// 默认值</span><br><span class="line">LazyLoad.defaultProps = &#123;</span><br><span class="line">  once: false,</span><br><span class="line">  offset: 0,</span><br><span class="line">  overflow: false,</span><br><span class="line">  resize: false,</span><br><span class="line">  scroll: true,</span><br><span class="line">  unmountIfInvisible: false,</span><br><span class="line">  preventLoading: false,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完整的 componentDidMount，scrollport 是滚动试图，默认是 window，如果 props 传入了 scrollContainer，那么滚动试图将是自定义的。needResetFinalLazyLoadHandler 是控制是否重置滚动监听。debounce 和 throttle 分别是用来控制滚动事件的监听触发频率，默认都是 undefine，needResetFinalLazyLoadHandler 初始值为 false。finalLazyLoadHandler 初始值也为 undefine，而 overflow 也为 false，scroll 为 true，listeners 是需要懒加载的组件集合，初始大小肯定为0，componentDidMount 最后才会进行添加，因此最终会走到 **on(scrollport, ‘scroll’, finalLazyLoadHandler, passiveEvent)，事件只需要一次绑定即可。<br>**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    // It&apos;s unlikely to change delay type on the fly, this is mainly</span><br><span class="line">    // designed for tests</span><br><span class="line">    let scrollport = window;</span><br><span class="line">    const &#123;</span><br><span class="line">      scrollContainer,</span><br><span class="line">    &#125; = this.props;</span><br><span class="line">    if (scrollContainer) &#123;</span><br><span class="line">      if (isString(scrollContainer)) &#123;</span><br><span class="line">        scrollport = scrollport.document.querySelector(scrollContainer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const needResetFinalLazyLoadHandler = (this.props.debounce !== undefined &amp;&amp; delayType === &apos;throttle&apos;)</span><br><span class="line">      || (delayType === &apos;debounce&apos; &amp;&amp; this.props.debounce === undefined);</span><br><span class="line"></span><br><span class="line">    if (needResetFinalLazyLoadHandler) &#123;</span><br><span class="line">      off(scrollport, &apos;scroll&apos;, finalLazyLoadHandler, passiveEvent);</span><br><span class="line">      off(window, &apos;resize&apos;, finalLazyLoadHandler, passiveEvent);</span><br><span class="line">      finalLazyLoadHandler = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!finalLazyLoadHandler) &#123;</span><br><span class="line">      if (this.props.debounce !== undefined) &#123;</span><br><span class="line">        finalLazyLoadHandler = debounce(lazyLoadHandler, typeof this.props.debounce === &apos;number&apos; ?</span><br><span class="line">                                                         this.props.debounce :</span><br><span class="line">                                                         300);</span><br><span class="line">        delayType = &apos;debounce&apos;;</span><br><span class="line">      &#125; else if (this.props.throttle !== undefined) &#123;</span><br><span class="line">        finalLazyLoadHandler = throttle(lazyLoadHandler, typeof this.props.throttle === &apos;number&apos; ?</span><br><span class="line">                                                         this.props.throttle :</span><br><span class="line">                                                         300);</span><br><span class="line">        delayType = &apos;throttle&apos;;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        finalLazyLoadHandler = lazyLoadHandler;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.props.overflow) &#123;</span><br><span class="line">      const parent = scrollParent(this.ref);</span><br><span class="line">      if (parent &amp;&amp; typeof parent.getAttribute === &apos;function&apos;) &#123;</span><br><span class="line">        const listenerCount = 1 + (+parent.getAttribute(LISTEN_FLAG));</span><br><span class="line">        if (listenerCount === 1) &#123;</span><br><span class="line">          parent.addEventListener(&apos;scroll&apos;, finalLazyLoadHandler, passiveEvent);</span><br><span class="line">        &#125;</span><br><span class="line">        parent.setAttribute(LISTEN_FLAG, listenerCount);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (listeners.length === 0 || needResetFinalLazyLoadHandler) &#123;</span><br><span class="line">      const &#123; scroll, resize &#125; = this.props;</span><br><span class="line"></span><br><span class="line">      if (scroll) &#123;</span><br><span class="line">        on(scrollport, &apos;scroll&apos;, finalLazyLoadHandler, passiveEvent);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (resize) &#123;</span><br><span class="line">        on(window, &apos;resize&apos;, finalLazyLoadHandler, passiveEvent);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listeners.push(this);</span><br><span class="line">    checkVisible(this);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通常 finalLazyLoadHandler 就是 lazyLoadHandler，不会对滚动事件进行 debounce 或 throttle，我们一般为了性能，会使用 throttle 进行处理。函数会对每一个懒加载组件进行 checkVisible，之后会移除 once component</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const lazyLoadHandler = () =&gt; &#123;</span><br><span class="line">  for (let i = 0; i &lt; listeners.length; ++i) &#123;</span><br><span class="line">    const listener = listeners[i];</span><br><span class="line">    checkVisible(listener);</span><br><span class="line">  &#125;</span><br><span class="line">  // Remove `once` component in listeners</span><br><span class="line">  purgePending();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>checkVisible，检查组件是否出现在 viewport 中，如果出现了就吧 visible 设置为 true，当然如果设置了 unmountIfInvisible = true，那么不可见时组件将被移除，如果之前已经渲染了，需要避免再次渲染。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const checkVisible = function checkVisible(component) &#123;</span><br><span class="line">  const node = component.ref;</span><br><span class="line">  if (!(node instanceof HTMLElement)) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const parent = scrollParent(node);</span><br><span class="line">  const isOverflow = component.props.overflow &amp;&amp;</span><br><span class="line">                     parent !== node.ownerDocument &amp;&amp;</span><br><span class="line">                     parent !== document &amp;&amp;</span><br><span class="line">                     parent !== document.documentElement;</span><br><span class="line">  const visible = isOverflow ?</span><br><span class="line">                  checkOverflowVisible(component, parent) :</span><br><span class="line">                  checkNormalVisible(component);</span><br><span class="line">  if (visible) &#123;</span><br><span class="line">    // Avoid extra render if previously is visible</span><br><span class="line">    if (!component.visible &amp;&amp; !component.preventLoading) &#123;</span><br><span class="line">      if (component.props.once) &#123;</span><br><span class="line">        pending.push(component);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      component.visible = true;</span><br><span class="line">      component.forceUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (!(component.props.once &amp;&amp; component.visible)) &#123;</span><br><span class="line">    component.visible = false;</span><br><span class="line">    if (component.props.unmountIfInvisible) &#123;</span><br><span class="line">      component.forceUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>checkNormalVisible 检查组件是否 visible 的函数，判断组件的getgetBoundingClientRect 的 top - offset（相对于屏幕顶部的距离） 与 window 的 height 之间的关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const checkNormalVisible = function checkNormalVisible(component) &#123;</span><br><span class="line">  const node = component.ref;</span><br><span class="line"></span><br><span class="line">  // If this element is hidden by css rules somehow, it&apos;s definitely invisible</span><br><span class="line">  if (!(node.offsetWidth || node.offsetHeight || node.getClientRects().length)) return false;</span><br><span class="line"></span><br><span class="line">  let top;</span><br><span class="line">  let elementHeight;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    // 这个语法 node 也是支持的</span><br><span class="line">    (&#123; top, height: elementHeight &#125; = node.getBoundingClientRect());</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    (&#123; top, height: elementHeight &#125; = defaultBoundingClientRect);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const windowInnerHeight = window.innerHeight || document.documentElement.clientHeight;</span><br><span class="line"></span><br><span class="line">  const offsets = Array.isArray(component.props.offset) ?</span><br><span class="line">                component.props.offset :</span><br><span class="line">                [component.props.offset, component.props.offset]; // Be compatible with previous API</span><br><span class="line"></span><br><span class="line">  return (top - offsets[0] &lt;= windowInnerHeight) &amp;&amp;</span><br><span class="line">         (top + elementHeight + offsets[1] &gt;= 0);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(top - offsets[0] &lt;= windowInnerHeight) &amp;&amp;</span><br><span class="line">         (top + elementHeight + offsets[1] &gt;= 0);</span><br></pre></td></tr></table></figure><p>一张图解析！<br><img src="https://upload-images.jianshu.io/upload_images/7117641-a10f694d96109cc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="check visible example"><br>到这里解析的差不多了</p><p>欣赏一下 throttle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">export default function throttle(fn, threshhold, scope) &#123;</span><br><span class="line">  threshhold || (threshhold = 250);</span><br><span class="line">  var last,</span><br><span class="line">      deferTimer;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    var context = scope || this;</span><br><span class="line"></span><br><span class="line">    var now = +new Date,</span><br><span class="line">        args = arguments;</span><br><span class="line">    if (last &amp;&amp; now &lt; last + threshhold) &#123;</span><br><span class="line">      // hold on to it</span><br><span class="line">      clearTimeout(deferTimer);</span><br><span class="line">      deferTimer = setTimeout(function () &#123;</span><br><span class="line">        last = now;</span><br><span class="line">        fn.apply(context, args);</span><br><span class="line">      &#125;, threshhold);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      last = now;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再欣赏一下 debounce</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">export default function debounce(func, wait, immediate) &#123;</span><br><span class="line">  let timeout;</span><br><span class="line">  let args;</span><br><span class="line">  let context;</span><br><span class="line">  let timestamp;</span><br><span class="line">  let result;</span><br><span class="line"></span><br><span class="line">  const later = function later() &#123;</span><br><span class="line">    const last = +(new Date()) - timestamp;</span><br><span class="line"></span><br><span class="line">    if (last &lt; wait &amp;&amp; last &gt;= 0) &#123;</span><br><span class="line">      timeout = setTimeout(later, wait - last);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      timeout = null;</span><br><span class="line">      if (!immediate) &#123;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        if (!timeout) &#123;</span><br><span class="line">          context = null;</span><br><span class="line">          args = null;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return function debounced() &#123;</span><br><span class="line">    context = this;</span><br><span class="line">    args = arguments;</span><br><span class="line">    timestamp = +(new Date());</span><br><span class="line"></span><br><span class="line">    const callNow = immediate &amp;&amp; !timeout;</span><br><span class="line">    if (!timeout) &#123;</span><br><span class="line">      timeout = setTimeout(later, wait);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (callNow) &#123;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      context = null;</span><br><span class="line">      args = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 scrollParent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">export default (node) =&gt; &#123;</span><br><span class="line">  if (!(node instanceof HTMLElement)) &#123;</span><br><span class="line">    return document.documentElement;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const excludeStaticParent = node.style.position === &apos;absolute&apos;;</span><br><span class="line">  const overflowRegex = /(scroll|auto)/;</span><br><span class="line">  let parent = node;</span><br><span class="line"></span><br><span class="line">  while (parent) &#123;</span><br><span class="line">    if (!parent.parentNode) &#123;</span><br><span class="line">      return node.ownerDocument || document.documentElement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const style = window.getComputedStyle(parent);</span><br><span class="line">    const position = style.position;</span><br><span class="line">    const overflow = style.overflow;</span><br><span class="line">    const overflowX = style[&apos;overflow-x&apos;];</span><br><span class="line">    const overflowY = style[&apos;overflow-y&apos;];</span><br><span class="line"></span><br><span class="line">    if (position === &apos;static&apos; &amp;&amp; excludeStaticParent) &#123;</span><br><span class="line">      parent = parent.parentNode;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (overflowRegex.test(overflow) &amp;&amp; overflowRegex.test(overflowX) &amp;&amp; overflowRegex.test(overflowY)) &#123;</span><br><span class="line">      return parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parent = parent.parentNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return node.ownerDocument || node.documentElement || document.documentElement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结思考"><a class="markdownIt-Anchor" href="#总结思考"></a> 总结思考</h3><p>我们可以看到，Lazyload 并不能实现类似客户端的图片懒加载，Lazyload 加载图片也会出现白屏时间，解决办法是使用 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL/Attribute/image.onload" target="_blank" rel="noopener">image.onload</a>，当图片资源请求关闭后，再显示图片，就可以做到类似客户端的效果。</p>]]></content>
    
    <summary type="html">
    
      React Lazyload
    
    </summary>
    
      <category term="JavaScript" scheme="https://wzes.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://wzes.github.io/tags/JavaScript/"/>
    
      <category term="React" scheme="https://wzes.github.io/tags/React/"/>
    
      <category term="Lazyload" scheme="https://wzes.github.io/tags/Lazyload/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Swipe-js-ios 源码解析</title>
    <link href="https://wzes.github.io/2019/07/20/JavaScript/Swipe-js-ios/"/>
    <id>https://wzes.github.io/2019/07/20/JavaScript/Swipe-js-ios/</id>
    <published>2019-07-20T06:38:00.000Z</published>
    <updated>2019-09-01T15:01:15.858Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>Swipe，常用来做轮播图，需要翻页的场景，最经典的开源库 <a href="https://github.com/voronianski/swipe-js-iso" target="_blank" rel="noopener">swipe-js-iso</a> ，不过更推荐使用 React 组件 <a href="https://github.com/voronianski/react-swipe" target="_blank" rel="noopener">react-swipe</a>，它封装了 swipe-js-ios  组件，而 swipe-js-ios 组件则封装了 <a href="https://github.com/thebird/Swipe" target="_blank" rel="noopener">Swipe</a></p><h3 id="helloword"><a class="markdownIt-Anchor" href="#helloword"></a> HelloWord</h3><p><img src="https://upload-images.jianshu.io/upload_images/7117641-de83b4953b2ad82f.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt="ReactSwipe"></p><p>如果单独使用的化，创建一个 swipe，dom 必须是三层结构，最里面一层是放 slide 的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;slider&quot; class=&quot;swipe&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;swipe-wrap&quot;&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>CSS 子元素 <strong>float: left;</strong> container 的宽度为自定义，swipe-wrap 的宽度为子页面数 * container 的 width，每一个 slide 的宽度为 container 的 width</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.swipe &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.swipe-wrap &#123;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.swipe-wrap &gt; div &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 100%;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>load 以后，创建 Swipe 即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const mySwipe = Swipe(document.getElementById(&apos;slider&apos;));</span><br></pre></td></tr></table></figure><h3 id="源码解析"><a class="markdownIt-Anchor" href="#源码解析"></a> 源码解析</h3><p>swipe-js-ios 使用立即函数导出了一个 Swipe 模块，使用 <strong>typeof module !== ‘undefined’ &amp;&amp; module.exports</strong> 兼容 Node 和 浏览器环境，如果是 Node 环境，将会有 module.export 那么则使用 module.export 导出，否则使用 root.Swipe 全局变量导出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(function(root, factory) &#123;</span><br><span class="line">  if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123;</span><br><span class="line">    module.exports = factory();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    root.Swipe = factory();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(this, function() &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  return function Swipe(container, options) &#123;</span><br><span class="line">        ....</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>检查浏览器的环境，算是一种规范吧，风别检查触摸事件和 transition 的支持<br>⚠️在浏览器，手机模式下，触摸事件是存在的，而普通浏览器下是不存在的，所以该组件不能在普通浏览器中使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var browser = &#123;</span><br><span class="line">      addEventListener: !!window.addEventListener,</span><br><span class="line">      touch:</span><br><span class="line">        &apos;ontouchstart&apos; in window ||</span><br><span class="line">        (window.DocumentTouch &amp;&amp; document instanceof window.DocumentTouch),</span><br><span class="line">      transitions: (function(temp) &#123;</span><br><span class="line">        var props = [</span><br><span class="line">          &apos;transitionProperty&apos;,</span><br><span class="line">          &apos;WebkitTransition&apos;,</span><br><span class="line">          &apos;MozTransition&apos;,</span><br><span class="line">          &apos;OTransition&apos;,</span><br><span class="line">          &apos;msTransition&apos;</span><br><span class="line">        ];</span><br><span class="line">        for (var i in props)</span><br><span class="line">          if (temp.style[props[i]] !== undefined) return true;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;)(document.createElement(&apos;swipe&apos;))</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>创建时会调用 setup，继而添加事件，touch 触摸事件、transitionend 移动事件，resize 重新布局事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// trigger setup</span><br><span class="line">setup();</span><br><span class="line"></span><br><span class="line">// start auto slideshow if applicable</span><br><span class="line">if (delay) begin();</span><br><span class="line"></span><br><span class="line">// add event listeners</span><br><span class="line">if (browser.addEventListener) &#123;</span><br><span class="line">  // set touchstart event on element</span><br><span class="line">  if (browser.touch) &#123;</span><br><span class="line">    element.addEventListener(&apos;touchstart&apos;, events, false);</span><br><span class="line">    element.addEventListener(&apos;touchforcechange&apos;, function() &#123;&#125;, false);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (browser.transitions) &#123;</span><br><span class="line">    element.addEventListener(&apos;webkitTransitionEnd&apos;, events, false);</span><br><span class="line">    element.addEventListener(&apos;msTransitionEnd&apos;, events, false);</span><br><span class="line">    element.addEventListener(&apos;oTransitionEnd&apos;, events, false);</span><br><span class="line">    element.addEventListener(&apos;otransitionend&apos;, events, false);</span><br><span class="line">    element.addEventListener(&apos;transitionend&apos;, events, false);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // set resize event on window</span><br><span class="line">  window.addEventListener(&apos;resize&apos;, events, false);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  window.onresize = function() &#123;</span><br><span class="line">    setup();</span><br><span class="line">  &#125;; // to play nice with old IE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setup 函数的实现，slides 就是容器里面的页面，continuous 是否自动轮播，slidePos 记录了每一个页面的位置，width 是每一个页面的宽度，此处需要剪掉widthOfSiblingSlidePreview 的大小，可以预览前后页。element 的宽度是 **页数 * width **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function setup() &#123;</span><br><span class="line">      // cache slides</span><br><span class="line">      slides = element.children;</span><br><span class="line">      length = slides.length;</span><br><span class="line"></span><br><span class="line">      // set continuous to false if only one slide</span><br><span class="line">      continuous = slides.length &lt; 2 ? false : options.continuous;</span><br><span class="line"></span><br><span class="line">      // create an array to store current positions of each slide</span><br><span class="line">      slidePos = new Array(slides.length);</span><br><span class="line"></span><br><span class="line">      // determine width of each slide</span><br><span class="line">      width =</span><br><span class="line">        Math.round(</span><br><span class="line">          container.getBoundingClientRect().width || container.offsetWidth</span><br><span class="line">        ) -</span><br><span class="line">        widthOfSiblingSlidePreview * 2;</span><br><span class="line"></span><br><span class="line">      element.style.width = slides.length * width + &apos;px&apos;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>初始化时，需要更新页面的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var pos = slides.length;</span><br><span class="line">while (pos--) &#123;</span><br><span class="line">  var slide = slides[pos];</span><br><span class="line"></span><br><span class="line">  slide.style.width = width + &apos;px&apos;;</span><br><span class="line">  slide.setAttribute(&apos;data-index&apos;, pos);</span><br><span class="line"></span><br><span class="line">  if (browser.transitions) &#123;</span><br><span class="line">    slide.style.left = pos * -width + widthOfSiblingSlidePreview + &apos;px&apos;;</span><br><span class="line">    move(pos, index &gt; pos ? -width : index &lt; pos ? width : 0, 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果支持轮播的化，需要把左边和右边也填充，然后把 container.style.visibility 设置为 visible，如果不支持 transition 的话，只需要设置 element.style.left 即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// reposition elements before and after index</span><br><span class="line">    if (continuous &amp;&amp; browser.transitions) &#123;</span><br><span class="line">      move(circle(index - 1), -width, 0);</span><br><span class="line">      move(circle(index + 1), width, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!browser.transitions)</span><br><span class="line">      element.style.left = index * -width + widthOfSiblingSlidePreview + &apos;px&apos;;</span><br><span class="line"></span><br><span class="line">    container.style.visibility = &apos;visible&apos;;</span><br></pre></td></tr></table></figure><p>move 的实现，translate，更新 slidePos 的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function move(index, dist, speed) &#123;</span><br><span class="line">  translate(index, dist, speed);</span><br><span class="line">  slidePos[index] = dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>translate 三个参数，index：需要移动的页，dist：移动的位置，speed：移动速度，移动只需要给 页面设置 style 的 transform 就OK了，之后就会以动画移动过去了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function translate(index, dist, speed) &#123;</span><br><span class="line">      var slide = slides[index];</span><br><span class="line">      var style = slide &amp;&amp; slide.style;</span><br><span class="line"></span><br><span class="line">      if (!style) return;</span><br><span class="line"></span><br><span class="line">      style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration =</span><br><span class="line">        speed + &apos;ms&apos;;</span><br><span class="line"></span><br><span class="line">      style.webkitTransform = &apos;translate(&apos; + dist + &apos;px,0)&apos; + &apos;translateZ(0)&apos;;</span><br><span class="line">      style.msTransform = style.MozTransform = style.OTransform =</span><br><span class="line">        &apos;translateX(&apos; + dist + &apos;px)&apos;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>prev 对外提供接口，手动翻页使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function prev() &#123;</span><br><span class="line">   if (continuous) slide(index - 1);</span><br><span class="line">   else if (index) slide(index - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slide 移动函数，指定移动的页 index 和速度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function slide(to, slideSpeed) &#123;</span><br><span class="line">      // do nothing if already on requested slide</span><br><span class="line">      if (index == to) return;</span><br><span class="line"></span><br><span class="line">      if (browser.transitions) &#123;</span><br><span class="line">        var direction = Math.abs(index - to) / (index - to); // 1: backward, -1: forward</span><br><span class="line"></span><br><span class="line">        // get the actual position of the slide</span><br><span class="line">        if (continuous) &#123;</span><br><span class="line">          var natural_direction = direction;</span><br><span class="line">          direction = -slidePos[circle(to)] / width;</span><br><span class="line"></span><br><span class="line">          // if going forward but to &lt; index, use to = slides.length + to</span><br><span class="line">          // if going backward but to &gt; index, use to = -slides.length + to</span><br><span class="line">          if (direction !== natural_direction)</span><br><span class="line">            to = -direction * slides.length + to;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var diff = Math.abs(index - to) - 1;</span><br><span class="line"></span><br><span class="line">        // move all the slides between index and to in the right direction</span><br><span class="line">        while (diff--)</span><br><span class="line">          move(</span><br><span class="line">            circle((to &gt; index ? to : index) - diff - 1),</span><br><span class="line">            width * direction,</span><br><span class="line">            0</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">        to = circle(to);</span><br><span class="line"></span><br><span class="line">        move(index, width * direction, slideSpeed || speed);</span><br><span class="line">        move(to, 0, slideSpeed || speed);</span><br><span class="line"></span><br><span class="line">        if (continuous) move(circle(to - direction), -(width * direction), 0); // we need to get the next in place</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        to = circle(to); </span><br><span class="line">        animate(index * -width, to * -width, slideSpeed || speed);</span><br><span class="line">        //no fallback for a circular continuous if the browser does not accept transitions</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      index = to;</span><br><span class="line">      offloadFn(options.callback &amp;&amp; options.callback(index, slides[index]));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果浏览器不支持 transition，那么则使用 setInterval 实现渐进移动， animation 是对整个页面进行移动，而 move 是移动每一个子页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function animate(from, to, speed) &#123;</span><br><span class="line">      // if not an animation, just reposition</span><br><span class="line">      if (!speed) &#123;</span><br><span class="line">        element.style.left = to + &apos;px&apos;;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var start = +new Date();</span><br><span class="line"></span><br><span class="line">      var timer = setInterval(function() &#123;</span><br><span class="line">        var timeElap = +new Date() - start;</span><br><span class="line"></span><br><span class="line">        if (timeElap &gt; speed) &#123;</span><br><span class="line">          element.style.left = to + &apos;px&apos;;</span><br><span class="line"></span><br><span class="line">          if (delay) begin();</span><br><span class="line"></span><br><span class="line">          options.transitionEnd &amp;&amp;</span><br><span class="line">            options.transitionEnd.call(event, index, slides[index]);</span><br><span class="line"></span><br><span class="line">          clearInterval(timer);</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        element.style.left =</span><br><span class="line">          (to - from) * (Math.floor((timeElap / speed) * 100) / 100) +</span><br><span class="line">          from +</span><br><span class="line">          &apos;px&apos;;</span><br><span class="line">      &#125;, 4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接下来研究一下触摸事件的处理，首先是 start，start 事件会记录起始触摸位置以及时间，并且添加 touchmove 和 touchend 事件，如果没有 start 事件，触摸事件是不存在的， end 的时候会被移除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">start: function(event) &#123;</span><br><span class="line">        var touches = event.touches[0];</span><br><span class="line"></span><br><span class="line">        // measure start values</span><br><span class="line">        start = &#123;</span><br><span class="line">          // get initial touch coords</span><br><span class="line">          x: touches.pageX,</span><br><span class="line">          y: touches.pageY,</span><br><span class="line"></span><br><span class="line">          // store time to determine touch duration</span><br><span class="line">          time: +new Date()</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // used for testing first move event</span><br><span class="line">        isScrolling = undefined;</span><br><span class="line"></span><br><span class="line">        // reset delta and end measurements</span><br><span class="line">        delta = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        // attach touchmove and touchend listeners</span><br><span class="line">        element.addEventListener(&apos;touchmove&apos;, this, false);</span><br><span class="line">        element.addEventListener(&apos;touchend&apos;, this, false);</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure><p>move 事件，delta 将手指移动距离记下，最后视同 translate 移动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">move: function(event) &#123;</span><br><span class="line">       // ensure swiping with one touch and not pinching</span><br><span class="line">       if (event.touches.length &gt; 1 || (event.scale &amp;&amp; event.scale !== 1))</span><br><span class="line">         return;</span><br><span class="line"></span><br><span class="line">       if (options.disableScroll) return;</span><br><span class="line"></span><br><span class="line">       var touches = event.touches[0];</span><br><span class="line"></span><br><span class="line">       // measure change in x and y</span><br><span class="line">       delta = &#123;</span><br><span class="line">         x: touches.pageX - start.x,</span><br><span class="line">         y: touches.pageY - start.y</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       // determine if scrolling test has run - one time test</span><br><span class="line">       if (typeof isScrolling == &apos;undefined&apos;) &#123;</span><br><span class="line">         isScrolling = !!(</span><br><span class="line">           isScrolling || Math.abs(delta.x) &lt; Math.abs(delta.y)</span><br><span class="line">         );</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // if user is not trying to scroll vertically</span><br><span class="line">       if (!isScrolling) &#123;</span><br><span class="line">         // prevent native scrolling</span><br><span class="line">         event.preventDefault();</span><br><span class="line"></span><br><span class="line">         // stop slideshow</span><br><span class="line">         stop();</span><br><span class="line"></span><br><span class="line">         // increase resistance if first or last slide</span><br><span class="line">         if (continuous) &#123;</span><br><span class="line">           // we don&apos;t add resistance at the end</span><br><span class="line"></span><br><span class="line">           translate(</span><br><span class="line">             circle(index - 1),</span><br><span class="line">             delta.x + slidePos[circle(index - 1)],</span><br><span class="line">             0</span><br><span class="line">           );</span><br><span class="line">           translate(index, delta.x + slidePos[index], 0);</span><br><span class="line">           translate(</span><br><span class="line">             circle(index + 1),</span><br><span class="line">             delta.x + slidePos[circle(index + 1)],</span><br><span class="line">             0</span><br><span class="line">           );</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">           delta.x =</span><br><span class="line">             delta.x /</span><br><span class="line">             ((!index &amp;&amp; delta.x &gt; 0) || // if first slide and sliding left</span><br><span class="line">             (index == slides.length - 1 &amp;&amp; // or if last slide and sliding right</span><br><span class="line">               delta.x &lt; 0) // and if sliding at all</span><br><span class="line">               ? Math.abs(delta.x) / width + 1 // determine resistance level</span><br><span class="line">               : 1); // no resistance if false</span><br><span class="line"></span><br><span class="line">           // translate 1:1</span><br><span class="line">           translate(index - 1, delta.x + slidePos[index - 1], 0);</span><br><span class="line">           translate(index, delta.x + slidePos[index], 0);</span><br><span class="line">           translate(index + 1, delta.x + slidePos[index + 1], 0);</span><br><span class="line">         &#125;</span><br><span class="line">         options.swiping &amp;&amp; options.swiping(-delta.x / width);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure><p>end 事件，主要判断本次触摸滑动是否有效，并持续接下来的操作，最后将会 remove 掉监听事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">end: function(event) &#123;</span><br><span class="line">        // measure duration</span><br><span class="line">        var duration = +new Date() - start.time;</span><br><span class="line"></span><br><span class="line">        // determine if slide attempt triggers next/prev slide</span><br><span class="line">        var isValidSlide =</span><br><span class="line">          (Number(duration) &lt; 250 &amp;&amp; // if slide duration is less than 250ms</span><br><span class="line">            Math.abs(delta.x) &gt; 20) || // and if slide amt is greater than 20px</span><br><span class="line">          Math.abs(delta.x) &gt; width / 2; // or if slide amt is greater than half the width</span><br><span class="line"></span><br><span class="line">        // determine if slide attempt is past start and end</span><br><span class="line">        var isPastBounds =</span><br><span class="line">          (!index &amp;&amp; delta.x &gt; 0) || // if first slide and slide amt is greater than 0</span><br><span class="line">          (index == slides.length - 1 &amp;&amp; delta.x &lt; 0); // or if last slide and slide amt is less than 0</span><br><span class="line"></span><br><span class="line">        if (continuous) isPastBounds = false;</span><br><span class="line"></span><br><span class="line">        // determine direction of swipe (true:right, false:left)</span><br><span class="line">        var direction = delta.x &lt; 0;</span><br><span class="line"></span><br><span class="line">        // if not scrolling vertically</span><br><span class="line">        if (!isScrolling) &#123;</span><br><span class="line">          if (isValidSlide &amp;&amp; !isPastBounds) &#123;</span><br><span class="line">            if (direction) &#123;</span><br><span class="line">              if (continuous) &#123;</span><br><span class="line">                // we need to get the next in this direction in place</span><br><span class="line"></span><br><span class="line">                move(circle(index - 1), -width, 0);</span><br><span class="line">                move(circle(index + 2), width, 0);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                move(index - 1, -width, 0);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              move(index, slidePos[index] - width, speed);</span><br><span class="line">              move(</span><br><span class="line">                circle(index + 1),</span><br><span class="line">                slidePos[circle(index + 1)] - width,</span><br><span class="line">                speed</span><br><span class="line">              );</span><br><span class="line">              index = circle(index + 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              if (continuous) &#123;</span><br><span class="line">                // we need to get the next in this direction in place</span><br><span class="line"></span><br><span class="line">                move(circle(index + 1), width, 0);</span><br><span class="line">                move(circle(index - 2), -width, 0);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                move(index + 1, width, 0);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              move(index, slidePos[index] + width, speed);</span><br><span class="line">              move(</span><br><span class="line">                circle(index - 1),</span><br><span class="line">                slidePos[circle(index - 1)] + width,</span><br><span class="line">                speed</span><br><span class="line">              );</span><br><span class="line">              index = circle(index - 1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            options.callback &amp;&amp; options.callback(index, slides[index]);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            if (continuous) &#123;</span><br><span class="line">              move(circle(index - 1), -width, speed);</span><br><span class="line">              move(index, 0, speed);</span><br><span class="line">              move(circle(index + 1), width, speed);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              move(index - 1, -width, speed);</span><br><span class="line">              move(index, 0, speed);</span><br><span class="line">              move(index + 1, width, speed);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // kill touchmove and touchend event listeners until touchstart called again</span><br><span class="line">        element.removeEventListener(&apos;touchmove&apos;, events, false);</span><br><span class="line">        element.removeEventListener(&apos;touchend&apos;, events, false);</span><br><span class="line">        element.removeEventListener(&apos;touchforcechange&apos;, function() &#123;&#125;, false);</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>总的来说，swipe-js-ios 充分利用了 transition，来实现移动动画，搞清楚触摸事件就比较容易能写出来可滑动的 swipe</p>]]></content>
    
    <summary type="html">
    
      JavaScript
    
    </summary>
    
      <category term="JavaScript" scheme="https://wzes.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://wzes.github.io/tags/JavaScript/"/>
    
      <category term="HTML" scheme="https://wzes.github.io/tags/HTML/"/>
    
      <category term="DOM" scheme="https://wzes.github.io/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Webpack 源码解析</title>
    <link href="https://wzes.github.io/2019/07/13/JavaScript/Webpack/"/>
    <id>https://wzes.github.io/2019/07/13/JavaScript/Webpack/</id>
    <published>2019-07-13T11:59:16.000Z</published>
    <updated>2019-09-01T15:01:24.357Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>算是一个h5开发了，虽然没写过什么完整的前端页面，但接触前端也有段时间了，对于一个合格的前端开发者而言，搞懂 webpack 打包原理还是比较重要的。</p><h3 id="hello-world"><a class="markdownIt-Anchor" href="#hello-world"></a> hello world</h3><p>使用 commonjs 规范，lib.js 只导出一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// lib.js</span><br><span class="line">module.exports = function () &#123;</span><br><span class="line">    return &quot;hello webpack!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.js 使用 require 引入，代码很简单，输入方法返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line">const func = require(&quot;./lib&quot;)</span><br><span class="line"></span><br><span class="line">const result = func()</span><br><span class="line">// print hello</span><br><span class="line">console.log(result)</span><br></pre></td></tr></table></figure><h5 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── dist</span><br><span class="line">│   └── main.js</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── node_modules</span><br><span class="line">├── src</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   └── lib.js</span><br><span class="line">└── webpack.config.js</span><br></pre></td></tr></table></figure><h5 id="webpackconfigjs"><a class="markdownIt-Anchor" href="#webpackconfigjs"></a> webpack.config.js</h5><p>为了方便看生成的源码，我们将 mode 设置为 development，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    context: path.resolve(__dirname, &apos;./&apos;),</span><br><span class="line">    mode: &apos;development&apos;,</span><br><span class="line">    entry: &apos;./src/index.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">        filename: &apos;main.js&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="packagejson"><a class="markdownIt-Anchor" href="#packagejson"></a> package.json</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;webpack-demo&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;^4.35.2&quot;,</span><br><span class="line">    &quot;webpack-cli&quot;: &quot;^3.3.5&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="编译运行"><a class="markdownIt-Anchor" href="#编译运行"></a> 编译运行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br><span class="line">node dist/main.js</span><br></pre></td></tr></table></figure><h5 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node dist/main.js </span><br><span class="line">hello webpack!</span><br></pre></td></tr></table></figure><h4 id="起源"><a class="markdownIt-Anchor" href="#起源"></a> 起源</h4><p>浏览器，node 并不支持模块化，我们在项目中使用的 require、export 将会经过 webpack 后，这些 js 就会被打包整合成一个 js 文件，只需要运行 js 文件，整个模块将会运行起来了。</p><h4 id="mainjs-解析"><a class="markdownIt-Anchor" href="#mainjs-解析"></a> main.js 解析</h4><p>整个文件只有 111 行，这是未经过压缩的版本，生产环境下的输出文件比这还要精简，只需要在 webpack.config.js 中将 mode 值等于 production 即可改变打包环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">/******/ (function(modules) &#123; // webpackBootstrap</span><br><span class="line">/******/ // The module cache</span><br><span class="line">/******/ var installedModules = &#123;&#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ // The require function</span><br><span class="line">/******/ function __webpack_require__(moduleId) &#123;</span><br><span class="line">/******/</span><br><span class="line">/******/ // Check if module is in cache</span><br><span class="line">/******/ if(installedModules[moduleId]) &#123;</span><br><span class="line">/******/ return installedModules[moduleId].exports;</span><br><span class="line">/******/ &#125;</span><br><span class="line">/******/ // Create a new module (and put it into the cache)</span><br><span class="line">/******/ var module = installedModules[moduleId] = &#123;</span><br><span class="line">/******/ i: moduleId,</span><br><span class="line">/******/ l: false,</span><br><span class="line">/******/ exports: &#123;&#125;</span><br><span class="line">/******/ &#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ // Execute the module function</span><br><span class="line">/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><br><span class="line">/******/</span><br><span class="line">/******/ // Flag the module as loaded</span><br><span class="line">/******/ module.l = true;</span><br><span class="line">/******/</span><br><span class="line">/******/ // Return the exports of the module</span><br><span class="line">/******/ return module.exports;</span><br><span class="line">/******/ &#125;</span><br><span class="line">/******/</span><br><span class="line">/******/</span><br><span class="line">/******/ // expose the modules object (__webpack_modules__)</span><br><span class="line">/******/ __webpack_require__.m = modules;</span><br><span class="line">/******/</span><br><span class="line">/******/ // expose the module cache</span><br><span class="line">/******/ __webpack_require__.c = installedModules;</span><br><span class="line">/******/</span><br><span class="line">/******/ // define getter function for harmony exports</span><br><span class="line">/******/ __webpack_require__.d = function(exports, name, getter) &#123;</span><br><span class="line">/******/ if(!__webpack_require__.o(exports, name)) &#123;</span><br><span class="line">/******/ Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;);</span><br><span class="line">/******/ &#125;</span><br><span class="line">/******/ &#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ // define __esModule on exports</span><br><span class="line">/******/ __webpack_require__.r = function(exports) &#123;</span><br><span class="line">/******/ if(typeof Symbol !== &apos;undefined&apos; &amp;&amp; Symbol.toStringTag) &#123;</span><br><span class="line">/******/ Object.defineProperty(exports, Symbol.toStringTag, &#123; value: &apos;Module&apos; &#125;);</span><br><span class="line">/******/ &#125;</span><br><span class="line">/******/ Object.defineProperty(exports, &apos;__esModule&apos;, &#123; value: true &#125;);</span><br><span class="line">/******/ &#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ // create a fake namespace object</span><br><span class="line">/******/ // mode &amp; 1: value is a module id, require it</span><br><span class="line">/******/ // mode &amp; 2: merge all properties of value into the ns</span><br><span class="line">/******/ // mode &amp; 4: return value when already ns object</span><br><span class="line">/******/ // mode &amp; 8|1: behave like require</span><br><span class="line">/******/ __webpack_require__.t = function(value, mode) &#123;</span><br><span class="line">/******/ if(mode &amp; 1) value = __webpack_require__(value);</span><br><span class="line">/******/ if(mode &amp; 8) return value;</span><br><span class="line">/******/ if((mode &amp; 4) &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; value &amp;&amp; value.__esModule) return value;</span><br><span class="line">/******/ var ns = Object.create(null);</span><br><span class="line">/******/ __webpack_require__.r(ns);</span><br><span class="line">/******/ Object.defineProperty(ns, &apos;default&apos;, &#123; enumerable: true, value: value &#125;);</span><br><span class="line">/******/ if(mode &amp; 2 &amp;&amp; typeof value != &apos;string&apos;) for(var key in value) __webpack_require__.d(ns, key, function(key) &#123; return value[key]; &#125;.bind(null, key));</span><br><span class="line">/******/ return ns;</span><br><span class="line">/******/ &#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ // getDefaultExport function for compatibility with non-harmony modules</span><br><span class="line">/******/ __webpack_require__.n = function(module) &#123;</span><br><span class="line">/******/ var getter = module &amp;&amp; module.__esModule ?</span><br><span class="line">/******/ function getDefault() &#123; return module[&apos;default&apos;]; &#125; :</span><br><span class="line">/******/ function getModuleExports() &#123; return module; &#125;;</span><br><span class="line">/******/ __webpack_require__.d(getter, &apos;a&apos;, getter);</span><br><span class="line">/******/ return getter;</span><br><span class="line">/******/ &#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ // Object.prototype.hasOwnProperty.call</span><br><span class="line">/******/ __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ // __webpack_public_path__</span><br><span class="line">/******/ __webpack_require__.p = &quot;&quot;;</span><br><span class="line">/******/</span><br><span class="line">/******/</span><br><span class="line">/******/ // Load entry module and return exports</span><br><span class="line">/******/ return __webpack_require__(__webpack_require__.s = &quot;./src/index.js&quot;);</span><br><span class="line">/******/ &#125;)</span><br><span class="line">/************************************************************************/</span><br><span class="line">/******/ (&#123;</span><br><span class="line"></span><br><span class="line">/***/ &quot;./src/index.js&quot;:</span><br><span class="line">/*!**********************!*\</span><br><span class="line">  !*** ./src/index.js ***!</span><br><span class="line">  \**********************/</span><br><span class="line">/*! no static exports found */</span><br><span class="line">/***/ (function(module, exports, __webpack_require__) &#123;</span><br><span class="line"></span><br><span class="line">eval(&quot;// index.js\nconst func = __webpack_require__(/*! ./lib */ \&quot;./src/lib.js\&quot;)\n\nconst result = func()\n// print hello\nconsole.log(result)\n\n//# sourceURL=webpack:///./src/index.js?&quot;);</span><br><span class="line"></span><br><span class="line">/***/ &#125;),</span><br><span class="line"></span><br><span class="line">/***/ &quot;./src/lib.js&quot;:</span><br><span class="line">/*!********************!*\</span><br><span class="line">  !*** ./src/lib.js ***!</span><br><span class="line">  \********************/</span><br><span class="line">/*! no static exports found */</span><br><span class="line">/***/ (function(module, exports) &#123;</span><br><span class="line"></span><br><span class="line">eval(&quot;module.exports = function () &#123;\n    return \&quot;hello webpack!\&quot;\n&#125;\n\n//# sourceURL=webpack:///./src/lib.js?&quot;);</span><br><span class="line"></span><br><span class="line">/***/ &#125;)</span><br><span class="line"></span><br><span class="line">/******/ &#125;);</span><br></pre></td></tr></table></figure><p>我们先将此文件的主要部分拿出来看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/******/</span><br><span class="line">(function (modules) &#123;</span><br><span class="line">    var installedModules = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function __webpack_require__ (moduleId) &#123;</span><br><span class="line">        if (installedModules[moduleId]) &#123;</span><br><span class="line">            return installedModules[moduleId].exports</span><br><span class="line">        &#125;</span><br><span class="line">        var module = installedModules[moduleId] = &#123;</span><br><span class="line">            i: moduleId,</span><br><span class="line">            l: false,</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__)</span><br><span class="line">        module.l = true</span><br><span class="line">        return module.exports</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return __webpack_require__(__webpack_require__.s = &apos;./src/index.js&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">(&#123;</span><br><span class="line">    &apos;./src/index.js&apos;:</span><br><span class="line">        (function (module, exports, __webpack_require__) &#123;</span><br><span class="line">            eval(</span><br><span class="line">                &apos;// index.js\nconst func = __webpack_require__(/*! ./lib */ &quot;./src/lib.js&quot;)\n\nconst result = func()\n// print hello\nconsole.log(result)\n\n//# sourceURL=webpack:///./src/index.js?&apos;)</span><br><span class="line">        &#125;),</span><br><span class="line">    &apos;./src/lib.js&apos;:</span><br><span class="line">        (function (module, exports) &#123;</span><br><span class="line">            eval(</span><br><span class="line">                &apos;module.exports = function () &#123;\n    return &quot;hello webpack!&quot;\n&#125;\n\n//# sourceURL=webpack:///./src/lib.js?&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这是一个立即执行函数，首先申明了 installedModules 对象，这是已安装的模块集合，之后定义了一个函数 <strong>webpack_require</strong> ，此函数用来获取模块的引用，最后 return 了此函数，参数为入口，moduleId = ‘./src/index.js’<br>modules 即为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &apos;./src/index.js&apos;:</span><br><span class="line">        (function (module, exports, __webpack_require__) &#123;</span><br><span class="line">            eval(</span><br><span class="line">                &apos;// index.js\nconst func = __webpack_require__(/*! ./lib */ &quot;./src/lib.js&quot;)\n\nconst result = func()\n// print hello\nconsole.log(result)\n\n//# sourceURL=webpack:///./src/index.js?&apos;)</span><br><span class="line">        &#125;),</span><br><span class="line">    &apos;./src/lib.js&apos;:</span><br><span class="line">        (function (module, exports) &#123;</span><br><span class="line">            eval(</span><br><span class="line">                &apos;module.exports = function () &#123;\n    return &quot;hello webpack!&quot;\n&#125;\n\n//# sourceURL=webpack:///./src/lib.js?&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modules[moduleId].call(module.exports, module, module.exports, __webpack_require__)</span><br></pre></td></tr></table></figure><p>module 即模块，modules[moduleId] 即为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function (module, exports, __webpack_require__) &#123;</span><br><span class="line">           eval(</span><br><span class="line">               &apos;// index.js\nconst func = __webpack_require__(/*! ./lib */ &quot;./src/lib.js&quot;)\n\nconst result = func()\n// print hello\nconsole.log(result)\n\n//# sourceURL=webpack:///./src/index.js?&apos;)</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure><p>module.exports 为 this 上下文环境，该函数执行中，第一行即调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const func = __webpack_require__(&quot;./src/lib.js&quot;)</span><br></pre></td></tr></table></figure><p><strong>webpack_require</strong>(&quot;./src/lib.js&quot;) 即调用了此函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function (module, exports) &#123;</span><br><span class="line">            eval(</span><br><span class="line">                &apos;module.exports = function () &#123;\n    return &quot;hello webpack!&quot;\n&#125;\n\n//# sourceURL=webpack:///./src/lib.js?&apos;)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>最后返回 module.exports 即 lib 里面的导出函数。再往后执行便是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const result = func()</span><br><span class="line">// print hello</span><br><span class="line">console.log(result)</span><br></pre></td></tr></table></figure><p>此刻基本已经将关系理顺了，此后如果在调用模块，则世界从 installedModules 中直接返回。</p><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>此文只是分析了简单的模块引用，需要仔细分析才能融会贯通。</p>]]></content>
    
    <summary type="html">
    
      Webpack
    
    </summary>
    
      <category term="JavaScript" scheme="https://wzes.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://wzes.github.io/tags/JavaScript/"/>
    
      <category term="Webpack" scheme="https://wzes.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Android PageTransformer 源码解析</title>
    <link href="https://wzes.github.io/2019/07/05/Android/PageTransformer/"/>
    <id>https://wzes.github.io/2019/07/05/Android/PageTransformer/</id>
    <published>2019-07-05T12:35:00.000Z</published>
    <updated>2019-09-01T15:01:55.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>作为一个很久没写过 Android 业务的人，心里有点慌了，于是拿起 Android Studio，还是找点东西学习一下，并且记录一下。一直觉得 ViewPager 是个好东西，偶然间看到一些很好的案例，很酷炫的翻页效果。直到了解了这个东西的实现原来没有想象中的那么复杂，但如果没有深刻理解，还是很难写出酷炫的效果的。于是， ViewPager Transformer 的学习就提上了日程。</p><h3 id="hello-world"><a class="markdownIt-Anchor" href="#hello-world"></a> Hello World</h3><p>首先我们来实现一个场景，很简单，只需要一个 ViewPager，然后给他设置几页用来展现效果就行了</p><h6 id="layout-文件"><a class="markdownIt-Anchor" href="#layout-文件"></a> Layout 文件</h6><p>只需要放入一个 ViewPager</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;androidx.constraintlayout.widget.ConstraintLayout</span><br><span class="line">        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">        xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">        xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        tools:context=&quot;.MainActivity&quot;&gt;</span><br><span class="line">    &lt;androidx.viewpager.widget.ViewPager</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:id=&quot;@+id/view_pager&quot;&gt;</span><br><span class="line">    &lt;/androidx.viewpager.widget.ViewPager&gt;</span><br><span class="line"></span><br><span class="line">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure><p>之后，我们创建一个 PageAdapter，可以直接使用 FragmentPagerAdapter，getItem 返回一个 Fragment 就好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class PageAdapter(fm: FragmentManager) : FragmentPagerAdapter(fm) &#123;</span><br><span class="line"></span><br><span class="line">    override fun getItem(position: Int): Fragment &#123;</span><br><span class="line">        return PageFragment(&quot;Fragment $position&quot;, position)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getCount(): Int &#123;</span><br><span class="line">        return 4</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;ValidFragment&quot;)</span><br><span class="line">    class PageFragment(private var content: String, private var position: Int) : Fragment() &#123;</span><br><span class="line"></span><br><span class="line">        private val colors = Arrays.asList(Color.GRAY, Color.RED, Color.BLUE, Color.YELLOW)!!</span><br><span class="line">        override fun onActivityCreated(savedInstanceState: Bundle?) &#123;</span><br><span class="line">            super.onActivityCreated(savedInstanceState)</span><br><span class="line">            text_view.text = content</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onCreateView(</span><br><span class="line">            inflater: LayoutInflater,</span><br><span class="line">            container: ViewGroup?,</span><br><span class="line">            savedInstanceState: Bundle?</span><br><span class="line">        ): View? &#123;</span><br><span class="line">            val view = inflater.inflate(R.layout.tab_item, container, false)</span><br><span class="line">            view.setBackgroundColor(colors[position % colors.size])</span><br><span class="line">            view.tag = &quot;$position&quot;</span><br><span class="line">            return view</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们的 Activity 中，设置 view_pager，这里需要注意的是，由于我们使用了 FragmentPagerAdapter，所以我们在展示是如果需要展示多页的话，必须设置为 <strong>offscreenPageLimit</strong> 一个比较大的值，以便 ViewPager 能够渲染足够多的页面满足我们的需求。<br>最后为 ViewPager 设置一个 PageTransformer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        view_pager.adapter = PageAdapter(supportFragmentManager)</span><br><span class="line"></span><br><span class="line">        view_pager.offscreenPageLimit = 4</span><br><span class="line"></span><br><span class="line">        view_pager.setPageTransformer(true, ViewPagerTransformer(TransformType.DEPTH))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个比较简单的 PageTransformer 的实现如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ViewPagerTransformer : ViewPager.PageTransformer  &#123;</span><br><span class="line">    override fun transformPage(page: View, position: Float) &#123;</span><br><span class="line">          page.rotationY = position * -30f</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下，翻页时会根据位置修改页面的显示，页面将会绕 Y 轴进行旋转一定的角度，效果很赞吧！！！只用了一点代码<br><img src="https://upload-images.jianshu.io/upload_images/7117641-ca06163fe13e1f15.gif?imageMogr2/auto-orient/strip" alt="页面翻转"></p><h4 id="viewpagerpagetransformer"><a class="markdownIt-Anchor" href="#viewpagerpagetransformer"></a> ViewPager.PageTransformer</h4><h5 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h5><p>PageTransfomer 接口只有一个方法，该方法有两个参数，一个是 page，指的是 ViewPage 的一个内容页</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface PageTransformer &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Apply a property transformation to the given page.</span><br><span class="line">     *</span><br><span class="line">     * @param page Apply the transformation to this page</span><br><span class="line">     * @param position Position of page relative to the current front-and-center</span><br><span class="line">     *                 position of the pager. 0 is front and center. 1 is one full</span><br><span class="line">     *                 page position to the right, and -1 is one page position to the left.</span><br><span class="line">     */</span><br><span class="line">    void transformPage(@NonNull View page, float position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>position</strong> 指的是该内容页的位置偏移，该偏移是相对的，具体表示请看一张图，页面静止时，以屏幕左边界为 0，屏幕内的页面 position 为0，左边为-1，依次递减，右侧为1，依次递增。当屏幕滑动时，page2只出现一半，此时，page2 的 position 为-0.5，page3 为0.5，依次类推可得出其他page 回调的 position 值<br><img src="https://upload-images.jianshu.io/upload_images/7117641-a9868f1c4f6cd870.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Page Transformer"></p><h4 id="实践"><a class="markdownIt-Anchor" href="#实践"></a> 实践</h4><p>1、淡入淡出 效果<br><img src="https://upload-images.jianshu.io/upload_images/7117641-d9f22c656de352bc.gif?imageMogr2/auto-orient/strip" alt="淡入淡出"></p><p>页面随着位置改变透明度，alpha = 0 是透明，alpha = 1 是不透明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (position &lt;= -1.0f || position &gt;= 1.0f) &#123;</span><br><span class="line">    page.alpha = 0.0f</span><br><span class="line">&#125; else if (position == 0.0f) &#123;</span><br><span class="line">    page.alpha = 1.0f</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    page.alpha = 1.0f - Math.abs(position)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、缩放变大效果<br><img src="https://upload-images.jianshu.io/upload_images/7117641-af318d5c1ab4d301.gif?imageMogr2/auto-orient/strip" alt="缩放变大"></p><p>同时改变位移与透明度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (position &gt; 0 &amp;&amp; position &lt; 1) &#123;</span><br><span class="line">      page.alpha = 1 - position</span><br><span class="line">      page.scaleXY = 0.85f + (1 - 0.85f) * (1 - Math.abs(position))</span><br><span class="line">      page.translationX = page.width * -position</span><br><span class="line">&#125; else &#123;</span><br><span class="line">      page.alpha = 1f</span><br><span class="line">      page.scaleXY = 1f</span><br><span class="line">      page.translationX = 0f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更多效果"><a class="markdownIt-Anchor" href="#更多效果"></a> 更多效果</h4><p>等你去发现</p><h4 id="源码解析"><a class="markdownIt-Anchor" href="#源码解析"></a> 源码解析</h4><p>其实这个原理很简单，在每一次滚动的时候，在 ViewPager 内部，计算出 每一个view 的 position ，并且调用这个接口的方法就可以实现了<br>源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected void onPageScrolled(int position, float offset, int offsetPixels) &#123;</span><br><span class="line">     // 省略.......</span><br><span class="line">     if (mPageTransformer != null) &#123;</span><br><span class="line">         final int scrollX = getScrollX();</span><br><span class="line">         final int childCount = getChildCount();</span><br><span class="line">         for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">             final View child = getChildAt(i);</span><br><span class="line">             final LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">             if (lp.isDecor) continue;</span><br><span class="line">             final float transformPos = (float) (child.getLeft() - scrollX) / getClientWidth();</span><br><span class="line">             mPageTransformer.transformPage(child, transformPos);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     // ....</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先判断 mPageTransformer 是否存在，存在的话就可以调用了，获取 scrollX，根据 childCount 对每一个 view 执行 mPageTransformer.transformPage 方法 transformPos 是由 (float) (child.getLeft() - scrollX) / getClientWidth() 计算得出。此处使用 getLeft - scrollX 计算验证了我们对想法。</p><p><a href="https://github.com/wzes/vptfdemo/tree/master" target="_blank" rel="noopener">demo</a></p><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p>看似复杂的功能，其实没那么复杂，静下心来研究，原来这么简单</p>]]></content>
    
    <summary type="html">
    
      Android ViewPager
    
    </summary>
    
      <category term="Android" scheme="https://wzes.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://wzes.github.io/tags/Android/"/>
    
      <category term="ViewPager" scheme="https://wzes.github.io/tags/ViewPager/"/>
    
  </entry>
  
  <entry>
    <title>Android TabLayout 源码解析</title>
    <link href="https://wzes.github.io/2019/02/21/Android/TabLayout/"/>
    <id>https://wzes.github.io/2019/02/21/Android/TabLayout/</id>
    <published>2019-02-21T07:36:00.000Z</published>
    <updated>2019-09-01T14:41:43.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>很久很久没写过源码解析了，不是自己没有看了，只是没有记录了，却发现不记录的话，似懂非懂，时间久了就忘得差不多了，用到了还是得再学一遍，忍住提笔一篇 TabLayout 源码学习。</p><h3 id="hello-world"><a class="markdownIt-Anchor" href="#hello-world"></a> Hello World</h3><h5 id="依赖"><a class="markdownIt-Anchor" href="#依赖"></a> 依赖</h5><p>添加 support design 包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.android.support:design:27.1.1&apos;</span><br></pre></td></tr></table></figure><h5 id="xml"><a class="markdownIt-Anchor" href="#xml"></a> xml</h5><p>添加一个 TabLayout 就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;.TabLayoutActivity&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;android.support.design.widget.TabLayout</span><br><span class="line">        android:id=&quot;@+id/tab_layout&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;/&gt;</span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure><h5 id="mainactivityjava"><a class="markdownIt-Anchor" href="#mainactivityjava"></a> MainActivity.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import android.support.design.widget.TabLayout;</span><br><span class="line">import android.support.v7.app.AppCompatActivity;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line"></span><br><span class="line">public class TabLayoutActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_tab_layout);</span><br><span class="line"></span><br><span class="line">        TabLayout mTabLayout = findViewById(R.id.tab_layout);</span><br><span class="line">        // 添加 tab item</span><br><span class="line">        mTabLayout.addTab(mTabLayout.newTab().setText(&quot;TAB1&quot;));</span><br><span class="line">        mTabLayout.addTab(mTabLayout.newTab().setText(&quot;TAB2&quot;));</span><br><span class="line">        mTabLayout.addTab(mTabLayout.newTab().setText(&quot;TAB3&quot;));</span><br><span class="line">        mTabLayout.addTab(mTabLayout.newTab().setText(&quot;TAB4&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="效果"><a class="markdownIt-Anchor" href="#效果"></a> 效果</h5><p><img src="https://upload-images.jianshu.io/upload_images/7117641-d36e4e9cef4c41bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot_1550732046.png"></p><h3 id="源码学习"><a class="markdownIt-Anchor" href="#源码学习"></a> 源码学习</h3><p>其实，实现这样一个布局并不难，让我们来看看里面所有的内容</p><h4 id="前世今生"><a class="markdownIt-Anchor" href="#前世今生"></a> 前世今生</h4><p>继承自 HorizontalScrollView 因为他支持滚动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class TabLayout extends HorizontalScrollView</span><br></pre></td></tr></table></figure><p>TabLayout 支持两种模式，一种是固定的，一种是可滚动的（tab 太多，一屏显示不下，可使用这种模式，否则默认为平分）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Scrollable tabs display a subset of tabs at any given moment, and can contain longer tab</span><br><span class="line"> * labels and a larger number of tabs. They are best used for browsing contexts in touch</span><br><span class="line"> * interfaces when users don’t need to directly compare the tab labels.</span><br><span class="line"> *</span><br><span class="line"> * @see #setTabMode(int)</span><br><span class="line"> * @see #getTabMode()</span><br><span class="line"> */</span><br><span class="line">public static final int MODE_SCROLLABLE = 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Fixed tabs display all tabs concurrently and are best used with content that benefits from</span><br><span class="line"> * quick pivots between tabs. The maximum number of tabs is limited by the view’s width.</span><br><span class="line"> * Fixed tabs have equal width, based on the widest tab label.</span><br><span class="line"> *</span><br><span class="line"> * @see #setTabMode(int)</span><br><span class="line"> * @see #getTabMode()</span><br><span class="line"> */</span><br><span class="line">public static final int MODE_FIXED = 1;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @hide</span><br><span class="line"> */</span><br><span class="line">@RestrictTo(LIBRARY_GROUP)</span><br><span class="line">@IntDef(value = &#123;MODE_SCROLLABLE, MODE_FIXED&#125;)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface Mode &#123;&#125;</span><br></pre></td></tr></table></figure><p>Tab 的位置有两种，一种是居中，一种是平分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Gravity used to fill the &#123;@link TabLayout&#125; as much as possible. This option only takes effect</span><br><span class="line"> * when used with &#123;@link #MODE_FIXED&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @see #setTabGravity(int)</span><br><span class="line"> * @see #getTabGravity()</span><br><span class="line"> */</span><br><span class="line">public static final int GRAVITY_FILL = 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Gravity used to lay out the tabs in the center of the &#123;@link TabLayout&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @see #setTabGravity(int)</span><br><span class="line"> * @see #getTabGravity()</span><br><span class="line"> */</span><br><span class="line">public static final int GRAVITY_CENTER = 1;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @hide</span><br><span class="line"> */</span><br><span class="line">@RestrictTo(LIBRARY_GROUP)</span><br><span class="line">@IntDef(flag = true, value = &#123;GRAVITY_FILL, GRAVITY_CENTER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.SOURCE)</span><br><span class="line">public @interface TabGravity &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>居中模式</strong><br><img src="https://upload-images.jianshu.io/upload_images/7117641-a4c409810ec18439.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2019-02-21 下午3.07.13.png"></p><h4 id="创建-tab"><a class="markdownIt-Anchor" href="#创建-tab"></a> 创建 Tab</h4><p>使用代码创建 Tab</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Tab newTab() &#123;</span><br><span class="line">    Tab tab = sTabPool.acquire();</span><br><span class="line">    if (tab == null) &#123;</span><br><span class="line">        tab = new Tab();</span><br><span class="line">    &#125;</span><br><span class="line">    tab.mParent = this;</span><br><span class="line">    tab.mView = createTabView(tab);</span><br><span class="line">    return tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tab 还使用了 Pool，还是挺细心的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final Pools.Pool&lt;Tab&gt; sTabPool = new Pools.SynchronizedPool&lt;&gt;(16);</span><br></pre></td></tr></table></figure><h5 id="可滑动的指示条形图"><a class="markdownIt-Anchor" href="#可滑动的指示条形图"></a> 可滑动的指示条形图</h5><p>自定义 ViewGroup</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private class SlidingTabStrip extends LinearLayout</span><br></pre></td></tr></table></figure><h5 id="onmeasure"><a class="markdownIt-Anchor" href="#onmeasure"></a> onMeasure</h5><p>如果设置了 MODE_FIXED 和 GRAVITY_CENTER 则需要重新测量，目的就是让居中，每个 ITEM 的宽度都是一样的，而且等于最大的一个，如果一屏放得下则需要重新设置每个 ITEM 的大小，并且重新测量。如果发不下，那么侧设置GRAVITY_FILL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">        protected void onMeasure(final int widthMeasureSpec, final int heightMeasureSpec) &#123;</span><br><span class="line">            super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">            if (MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY) &#123;</span><br><span class="line">                // HorizontalScrollView will first measure use with UNSPECIFIED, and then with</span><br><span class="line">                // EXACTLY. Ignore the first call since anything we do will be overwritten anyway</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 重新测量</span><br><span class="line">            if (mMode == MODE_FIXED &amp;&amp; mTabGravity == GRAVITY_CENTER) &#123;</span><br><span class="line">                final int count = getChildCount();</span><br><span class="line"></span><br><span class="line">                // First we&apos;ll find the widest tab</span><br><span class="line">                int largestTabWidth = 0;</span><br><span class="line">                for (int i = 0, z = count; i &lt; z; i++) &#123;</span><br><span class="line">                    View child = getChildAt(i);</span><br><span class="line">                    if (child.getVisibility() == VISIBLE) &#123;</span><br><span class="line">                        largestTabWidth = Math.max(largestTabWidth, child.getMeasuredWidth());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (largestTabWidth &lt;= 0) &#123;</span><br><span class="line">                    // If we don&apos;t have a largest child yet, skip until the next measure pass</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                // 间隔</span><br><span class="line">                final int gutter = dpToPx(FIXED_WRAP_GUTTER_MIN);</span><br><span class="line">                boolean remeasure = false;</span><br><span class="line">                // 一屏放得下</span><br><span class="line">                if (largestTabWidth * count &lt;= getMeasuredWidth() - gutter * 2) &#123;</span><br><span class="line">                    // If the tabs fit within our width minus gutters, we will set all tabs to have  </span><br><span class="line">                    // the same width</span><br><span class="line">                    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                        final LinearLayout.LayoutParams lp =</span><br><span class="line">                                (LayoutParams) getChildAt(i).getLayoutParams();</span><br><span class="line">                        if (lp.width != largestTabWidth || lp.weight != 0) &#123;</span><br><span class="line">                            lp.width = largestTabWidth;</span><br><span class="line">                            lp.weight = 0;</span><br><span class="line">                            remeasure = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // If the tabs will wrap to be larger than the width minus gutters, we need</span><br><span class="line">                    // to switch to GRAVITY_FILL</span><br><span class="line">                    mTabGravity = GRAVITY_FILL;</span><br><span class="line">                    updateTabViews(false);</span><br><span class="line">                    remeasure = true;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (remeasure) &#123;</span><br><span class="line">                    // Now re-measure after our changes</span><br><span class="line">                    super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="如何实现动画"><a class="markdownIt-Anchor" href="#如何实现动画"></a> 如何实现动画？</h4><p>通过移动 IndicatorView</p><h5 id="onlayout"><a class="markdownIt-Anchor" href="#onlayout"></a> onLayout</h5><p>mIndicatorAnimator 是动画辅助类，在 onLayout 中，非空而且正在运行则看取消，然后调用 animateIndicatorToPosition，动画调用，否则直接设置位置，不支持动画</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override                                                                               </span><br><span class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;                  </span><br><span class="line">    super.onLayout(changed, l, t, r, b);                                                </span><br><span class="line">                                                                                        </span><br><span class="line">    if (mIndicatorAnimator != null &amp;&amp; mIndicatorAnimator.isRunning()) &#123;                 </span><br><span class="line">        // If we&apos;re currently running an animation, lets cancel it and start a          </span><br><span class="line">        // new animation with the remaining duration                                    </span><br><span class="line">        mIndicatorAnimator.cancel();                                                    </span><br><span class="line">        final long duration = mIndicatorAnimator.getDuration();                         </span><br><span class="line">        animateIndicatorToPosition(mSelectedPosition,                                   </span><br><span class="line">                Math.round((1f - mIndicatorAnimator.getAnimatedFraction()) * duration));</span><br><span class="line">    &#125; else &#123;                                                                            </span><br><span class="line">        // If we&apos;ve been layed out, update the indicator position                       </span><br><span class="line">        updateIndicatorPosition();                                                      </span><br><span class="line">    &#125;                                                                                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>updateIndicatorPosition 首先获取选中的 View，然后看 mSelectionOffset 是否大于零，说明发生滚动，则需要重新计算新位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void updateIndicatorPosition() &#123;                                       </span><br><span class="line">    final View selectedTitle = getChildAt(mSelectedPosition);                  </span><br><span class="line">    int left, right;                                                           </span><br><span class="line">                                                                               </span><br><span class="line">    if (selectedTitle != null &amp;&amp; selectedTitle.getWidth() &gt; 0) &#123;               </span><br><span class="line">        left = selectedTitle.getLeft();                                        </span><br><span class="line">        right = selectedTitle.getRight();                                      </span><br><span class="line">                                                                               </span><br><span class="line">        if (mSelectionOffset &gt; 0f &amp;&amp; mSelectedPosition &lt; getChildCount() - 1) &#123;</span><br><span class="line">            // Draw the selection partway between the tabs                     </span><br><span class="line">            View nextTitle = getChildAt(mSelectedPosition + 1);                </span><br><span class="line">            left = (int) (mSelectionOffset * nextTitle.getLeft() +             </span><br><span class="line">                    (1.0f - mSelectionOffset) * left);                         </span><br><span class="line">            right = (int) (mSelectionOffset * nextTitle.getRight() +           </span><br><span class="line">                    (1.0f - mSelectionOffset) * right);                        </span><br><span class="line">        &#125;                                                                      </span><br><span class="line">    &#125; else &#123;                                                                   </span><br><span class="line">        left = right = -1;                                                     </span><br><span class="line">    &#125;                                                                          </span><br><span class="line">                                                                               </span><br><span class="line">    setIndicatorPosition(left, right);                                         </span><br><span class="line">&#125; </span><br><span class="line">// mIndicatorLeft 和 mIndicatorRight 控制了线的起始位置</span><br><span class="line">void setIndicatorPosition(int left, int right) &#123;                </span><br><span class="line">    if (left != mIndicatorLeft || right != mIndicatorRight) &#123;   </span><br><span class="line">        // If the indicator&apos;s left/right has changed, invalidate</span><br><span class="line">        mIndicatorLeft = left;                                  </span><br><span class="line">        mIndicatorRight = right;                                </span><br><span class="line">        ViewCompat.postInvalidateOnAnimation(this);             </span><br><span class="line">    &#125;                                                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动动画，移动间隔大的话，并不会从当前位置直接移动，而是跳跃一段距离再移动，通过 startLeft 和 startRight 控制，并且使用 ValueAnimator 来实现动画<br>这个不错，同意了 fraction 0-1 ，通过函数计算进度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setIndicatorPosition(                                           </span><br><span class="line">        AnimationUtils.lerp(startLeft, targetLeft, fraction),   </span><br><span class="line">        AnimationUtils.lerp(startRight, targetRight, fraction));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">void animateIndicatorToPosition(final int position, int duration) &#123;              </span><br><span class="line">    if (mIndicatorAnimator != null &amp;&amp; mIndicatorAnimator.isRunning()) &#123;          </span><br><span class="line">        mIndicatorAnimator.cancel();                                             </span><br><span class="line">    &#125;                                                                            </span><br><span class="line">                                                                                 </span><br><span class="line">    final boolean isRtl = ViewCompat.getLayoutDirection(this)                    </span><br><span class="line">            == ViewCompat.LAYOUT_DIRECTION_RTL;                                  </span><br><span class="line">                                                                                 </span><br><span class="line">    final View targetView = getChildAt(position);                                </span><br><span class="line">    if (targetView == null) &#123;                                                    </span><br><span class="line">        // If we don&apos;t have a view, just update the position now and return      </span><br><span class="line">        updateIndicatorPosition();                                               </span><br><span class="line">        return;                                                                  </span><br><span class="line">    &#125;                                                                            </span><br><span class="line">                                                                                 </span><br><span class="line">    final int targetLeft = targetView.getLeft();                                 </span><br><span class="line">    final int targetRight = targetView.getRight();                               </span><br><span class="line">    final int startLeft;                                                         </span><br><span class="line">    final int startRight;                                                        </span><br><span class="line">                                                                                 </span><br><span class="line">    if (Math.abs(position - mSelectedPosition) &lt;= 1) &#123;                           </span><br><span class="line">        // If the views are adjacent, we&apos;ll animate from edge-to-edge            </span><br><span class="line">        startLeft = mIndicatorLeft;                                              </span><br><span class="line">        startRight = mIndicatorRight;                                            </span><br><span class="line">    &#125; else &#123;                                                                     </span><br><span class="line">        // Else, we&apos;ll just grow from the nearest edge                           </span><br><span class="line">        final int offset = dpToPx(MOTION_NON_ADJACENT_OFFSET);                   </span><br><span class="line">        if (position &lt; mSelectedPosition) &#123;                                      </span><br><span class="line">            // We&apos;re going end-to-start                                          </span><br><span class="line">            if (isRtl) &#123;                                                         </span><br><span class="line">                startLeft = startRight = targetLeft - offset;                    </span><br><span class="line">            &#125; else &#123;                                                             </span><br><span class="line">                startLeft = startRight = targetRight + offset;                   </span><br><span class="line">            &#125;                                                                    </span><br><span class="line">        &#125; else &#123;                                                                 </span><br><span class="line">            // We&apos;re going start-to-end                                          </span><br><span class="line">            if (isRtl) &#123;                                                         </span><br><span class="line">                startLeft = startRight = targetRight + offset;                   </span><br><span class="line">            &#125; else &#123;                                                             </span><br><span class="line">                startLeft = startRight = targetLeft - offset;                    </span><br><span class="line">            &#125;                                                                    </span><br><span class="line">        &#125;                                                                        </span><br><span class="line">    &#125;                                                                            </span><br><span class="line">    // 开始移动位置                                                                             </span><br><span class="line">    if (startLeft != targetLeft || startRight != targetRight) &#123;                  </span><br><span class="line">        ValueAnimator animator = mIndicatorAnimator = new ValueAnimator();       </span><br><span class="line">        animator.setInterpolator(AnimationUtils.FAST_OUT_SLOW_IN_INTERPOLATOR);  </span><br><span class="line">        animator.setDuration(duration);                                          </span><br><span class="line">        animator.setFloatValues(0, 1);                                           </span><br><span class="line">        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;  </span><br><span class="line">            @Override                                                            </span><br><span class="line">            public void onAnimationUpdate(ValueAnimator animator) &#123;              </span><br><span class="line">                final float fraction = animator.getAnimatedFraction();           </span><br><span class="line">                setIndicatorPosition(                                            </span><br><span class="line">                        AnimationUtils.lerp(startLeft, targetLeft, fraction),    </span><br><span class="line">                        AnimationUtils.lerp(startRight, targetRight, fraction)); </span><br><span class="line">            &#125;                                                                    </span><br><span class="line">        &#125;);                                                                      </span><br><span class="line">        animator.addListener(new AnimatorListenerAdapter() &#123;                     </span><br><span class="line">            @Override                                                            </span><br><span class="line">            public void onAnimationEnd(Animator animator) &#123;                      </span><br><span class="line">                mSelectedPosition = position;                                    </span><br><span class="line">                mSelectionOffset = 0f;                                           </span><br><span class="line">            &#125;                                                                    </span><br><span class="line">        &#125;);                                                                      </span><br><span class="line">        animator.start();                                                        </span><br><span class="line">    &#125;                                                                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onDraw 很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override                                                                          </span><br><span class="line">public void draw(Canvas canvas) &#123;                                                  </span><br><span class="line">    super.draw(canvas);                                                            </span><br><span class="line">                                                                                   </span><br><span class="line">    // Thick colored underline below the current selection                         </span><br><span class="line">    if (mIndicatorLeft &gt;= 0 &amp;&amp; mIndicatorRight &gt; mIndicatorLeft) &#123;                 </span><br><span class="line">        canvas.drawRect(mIndicatorLeft, getHeight() - mSelectedIndicatorHeight,    </span><br><span class="line">                mIndicatorRight, getHeight(), mSelectedIndicatorPaint);            </span><br><span class="line">    &#125;                                                                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tabview"><a class="markdownIt-Anchor" href="#tabview"></a> TabView</h4><p>接下来再看看上面的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class TabView extends LinearLayout &#123;</span><br><span class="line">      private Tab mTab;                  </span><br><span class="line">      private TextView mTextView;        </span><br><span class="line">      private ImageView mIconView;       </span><br><span class="line">                                         </span><br><span class="line">      private View mCustomView;          </span><br><span class="line">      private TextView mCustomTextView;  </span><br><span class="line">      private ImageView mCustomIconView; </span><br><span class="line">                                         </span><br><span class="line">      private int mDefaultMaxLines = 2;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实现监听的，对每个 TabView 设置点击事件，重写了 performClick，其中调用 mTab.select，mTab 拥有 TabLayout 的引用，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override                                               </span><br><span class="line">public boolean performClick() &#123;                         </span><br><span class="line">    final boolean handled = super.performClick();       </span><br><span class="line">                                                        </span><br><span class="line">    if (mTab != null) &#123;                                 </span><br><span class="line">        if (!handled) &#123;                                 </span><br><span class="line">            playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">        &#125;                                               </span><br><span class="line">        mTab.select();                                  </span><br><span class="line">        return true;                                    </span><br><span class="line">    &#125; else &#123;                                            </span><br><span class="line">        return handled;                                 </span><br><span class="line">    &#125;                                                   </span><br><span class="line">&#125;                                                       </span><br><span class="line">/**                                                                             </span><br><span class="line"> * Select this tab. Only valid if the tab has been added to the action bar.     </span><br><span class="line"> */                                                                             </span><br><span class="line">public void select() &#123;                                                          </span><br><span class="line">    if (mParent == null) &#123;                                                      </span><br><span class="line">        throw new IllegalArgumentException(&quot;Tab not attached to a TabLayout&quot;);  </span><br><span class="line">    &#125;                                                                           </span><br><span class="line">    mParent.selectTab(this);                                                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tabLayout 回调事件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void selectTab(Tab tab) &#123;                                                              </span><br><span class="line">    selectTab(tab, true);                                                              </span><br><span class="line">&#125;                                                                                      </span><br><span class="line">                                                                                       </span><br><span class="line">void selectTab(final Tab tab, boolean updateIndicator) &#123;                               </span><br><span class="line">    final Tab currentTab = mSelectedTab;                                               </span><br><span class="line">                                                                                       </span><br><span class="line">    if (currentTab == tab) &#123;                                                           </span><br><span class="line">        if (currentTab != null) &#123;                                                      </span><br><span class="line">            dispatchTabReselected(tab);                                                </span><br><span class="line">            animateToTab(tab.getPosition());                                           </span><br><span class="line">        &#125;                                                                              </span><br><span class="line">    &#125; else &#123;                                                                           </span><br><span class="line">        final int newPosition = tab != null ? tab.getPosition() : Tab.INVALID_POSITION;</span><br><span class="line">        if (updateIndicator) &#123;                                                         </span><br><span class="line">            if ((currentTab == null || currentTab.getPosition() == Tab.INVALID_POSITION</span><br><span class="line">                    &amp;&amp; newPosition != Tab.INVALID_POSITION) &#123;                          </span><br><span class="line">                // If we don&apos;t currently have a tab, just draw the indicator           </span><br><span class="line">                setScrollPosition(newPosition, 0f, true);                              </span><br><span class="line">            &#125; else &#123;                                                                   </span><br><span class="line">                animateToTab(newPosition);                                             </span><br><span class="line">            &#125;                                                                          </span><br><span class="line">            if (newPosition != Tab.INVALID_POSITION) &#123;                                 </span><br><span class="line">                setSelectedTabView(newPosition);                                       </span><br><span class="line">            &#125;                                                                          </span><br><span class="line">        &#125;                                                                              </span><br><span class="line">        if (currentTab != null) &#123;                                                      </span><br><span class="line">            dispatchTabUnselected(currentTab);                                         </span><br><span class="line">        &#125;                                                                              </span><br><span class="line">        mSelectedTab = tab;                                                            </span><br><span class="line">        if (tab != null) &#123;                                                             </span><br><span class="line">            dispatchTabSelected(tab);                                                  </span><br><span class="line">        &#125;                                                                              </span><br><span class="line">    &#125;                                                                                  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动 Tab，动画</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void animateToTab(int newPosition) &#123;                                        </span><br><span class="line">    if (newPosition == Tab.INVALID_POSITION) &#123;                                      </span><br><span class="line">        return;                                                                     </span><br><span class="line">    &#125;                                                                               </span><br><span class="line">                                                                                    </span><br><span class="line">    if (getWindowToken() == null || !ViewCompat.isLaidOut(this)                     </span><br><span class="line">            || mTabStrip.childrenNeedLayout()) &#123;                                    </span><br><span class="line">        // If we don&apos;t have a window token, or we haven&apos;t been laid out yet just dra</span><br><span class="line">        // position now                                                             </span><br><span class="line">        setScrollPosition(newPosition, 0f, true);                                   </span><br><span class="line">        return;                                                                     </span><br><span class="line">    &#125;                                                                               </span><br><span class="line">                                                                                    </span><br><span class="line">    final int startScrollX = getScrollX();                                          </span><br><span class="line">    final int targetScrollX = calculateScrollXForTab(newPosition, 0);               </span><br><span class="line">                                                                                    </span><br><span class="line">    if (startScrollX != targetScrollX) &#123;                                            </span><br><span class="line">        ensureScrollAnimator();                                                     </span><br><span class="line">                                                                                    </span><br><span class="line">        mScrollAnimator.setIntValues(startScrollX, targetScrollX);                  </span><br><span class="line">        mScrollAnimator.start();                                                    </span><br><span class="line">    &#125;                                                                               </span><br><span class="line">                                                                                    </span><br><span class="line">    // Now animate the indicator                                                    </span><br><span class="line">    mTabStrip.animateIndicatorToPosition(newPosition, ANIMATION_DURATION);          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算移动的距离，让选中的 tab 位于中间位置，由于 Android ScrollView 默认不会滚动超出边界，所以如果到达边界也不会继续滚动了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private int calculateScrollXForTab(int position, float positionOffset) &#123;                                  </span><br><span class="line">    if (mMode == MODE_SCROLLABLE) &#123;                                                                       </span><br><span class="line">        final View selectedChild = mTabStrip.getChildAt(position);                                        </span><br><span class="line">        final View nextChild = position + 1 &lt; mTabStrip.getChildCount()                                   </span><br><span class="line">                ? mTabStrip.getChildAt(position + 1)                                                      </span><br><span class="line">                : null;                                                                                   </span><br><span class="line">        final int selectedWidth = selectedChild != null ? selectedChild.getWidth() : 0;                   </span><br><span class="line">        final int nextWidth = nextChild != null ? nextChild.getWidth() : 0;                               </span><br><span class="line">                                                                                                          </span><br><span class="line">        // base scroll amount: places center of tab in center of parent                                   </span><br><span class="line">        int scrollBase = selectedChild.getLeft() + (selectedWidth / 2) - (getWidth() / 2);                </span><br><span class="line">        // offset amount: fraction of the distance between centers of tabs                                </span><br><span class="line">        int scrollOffset = (int) ((selectedWidth + nextWidth) * 0.5f * positionOffset);                   </span><br><span class="line">                                                                                                          </span><br><span class="line">        return (ViewCompat.getLayoutDirection(this) == ViewCompat.LAYOUT_DIRECTION_LTR)                   </span><br><span class="line">                ? scrollBase + scrollOffset                                                               </span><br><span class="line">                : scrollBase - scrollOffset;                                                              </span><br><span class="line">    &#125;                                                                                                     </span><br><span class="line">    return 0;                                                                                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="viewpager"><a class="markdownIt-Anchor" href="#viewpager"></a> ViewPager</h4><p>其实很简单，就是给 ViewPager 添加一个 OnPageChangeListener 就行了，代码也很简单，在 onPageScrolled 中改变 指示条 的位置，在 onPageSelected 中改变 选中状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public static class TabLayoutOnPageChangeListener implements ViewPager.OnPageChangeListener &#123;</span><br><span class="line">    private final WeakReference&lt;TabLayout&gt; mTabLayoutRef;</span><br><span class="line">    private int mPreviousScrollState;</span><br><span class="line">    private int mScrollState;</span><br><span class="line"></span><br><span class="line">    public TabLayoutOnPageChangeListener(TabLayout tabLayout) &#123;</span><br><span class="line">        mTabLayoutRef = new WeakReference&lt;&gt;(tabLayout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onPageScrollStateChanged(final int state) &#123;</span><br><span class="line">        mPreviousScrollState = mScrollState;</span><br><span class="line">        mScrollState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onPageScrolled(final int position, final float positionOffset,</span><br><span class="line">            final int positionOffsetPixels) &#123;</span><br><span class="line">        final TabLayout tabLayout = mTabLayoutRef.get();</span><br><span class="line">        if (tabLayout != null) &#123;</span><br><span class="line">            // Only update the text selection if we&apos;re not settling, or we are settling after</span><br><span class="line">            // being dragged</span><br><span class="line">            final boolean updateText = mScrollState != SCROLL_STATE_SETTLING ||</span><br><span class="line">                    mPreviousScrollState == SCROLL_STATE_DRAGGING;</span><br><span class="line">            // Update the indicator if we&apos;re not settling after being idle. This is caused</span><br><span class="line">            // from a setCurrentItem() call and will be handled by an animation from</span><br><span class="line">            // onPageSelected() instead.</span><br><span class="line">            final boolean updateIndicator = !(mScrollState == SCROLL_STATE_SETTLING</span><br><span class="line">                    &amp;&amp; mPreviousScrollState == SCROLL_STATE_IDLE);</span><br><span class="line">            tabLayout.setScrollPosition(position, positionOffset, updateText, updateIndicator);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onPageSelected(final int position) &#123;</span><br><span class="line">        final TabLayout tabLayout = mTabLayoutRef.get();</span><br><span class="line">        if (tabLayout != null &amp;&amp; tabLayout.getSelectedTabPosition() != position</span><br><span class="line">                &amp;&amp; position &lt; tabLayout.getTabCount()) &#123;</span><br><span class="line">            // Select the tab, only updating the indicator if we&apos;re not being dragged/settled</span><br><span class="line">            // (since onPageScrolled will handle that).</span><br><span class="line">            final boolean updateIndicator = mScrollState == SCROLL_STATE_IDLE</span><br><span class="line">                    || (mScrollState == SCROLL_STATE_SETTLING</span><br><span class="line">                    &amp;&amp; mPreviousScrollState == SCROLL_STATE_IDLE);</span><br><span class="line">            tabLayout.selectTab(tabLayout.getTabAt(position), updateIndicator);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void reset() &#123;</span><br><span class="line">        mPreviousScrollState = mScrollState = SCROLL_STATE_IDLE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h5><p>基本上看完了，但对于一些细节，滚动边界问题还没有深刻的理解，只知道大概的逻辑</p>]]></content>
    
    <summary type="html">
    
      Android TabLayout
    
    </summary>
    
      <category term="Android" scheme="https://wzes.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://wzes.github.io/tags/Android/"/>
    
      <category term="TabLayout" scheme="https://wzes.github.io/tags/TabLayout/"/>
    
  </entry>
  
  <entry>
    <title>Android Recycview 分割线</title>
    <link href="https://wzes.github.io/2018/10/12/Android/Android%20Recycview%20Devider/"/>
    <id>https://wzes.github.io/2018/10/12/Android/Android Recycview Devider/</id>
    <published>2018-10-12T12:35:00.000Z</published>
    <updated>2019-09-01T14:51:13.279Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最近有一个需求需要做分割线网上有一些大致的做法但感觉都不是那么通俗易懂然后自己想了想干脆自己弄吧后面发现了一个比较好的非常简洁分享给大家"><a class="markdownIt-Anchor" href="#最近有一个需求需要做分割线网上有一些大致的做法但感觉都不是那么通俗易懂然后自己想了想干脆自己弄吧后面发现了一个比较好的非常简洁分享给大家"></a> 最近有一个需求需要做分割线，网上有一些大致的做法，但感觉都不是那么通俗易懂，然后自己想了想，干脆自己弄吧，后面发现了一个比较好的，非常简洁，分享给大家</h3><h3 id="效果"><a class="markdownIt-Anchor" href="#效果"></a> 效果</h3><p><img src="https://upload-images.jianshu.io/upload_images/7117641-a576c4213a43f594.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class GridSpanDecoration extends RecyclerView.ItemDecoration &#123;</span><br><span class="line">    private Paint mPaint;</span><br><span class="line"></span><br><span class="line">    GridSpanDecoration(int color) &#123;</span><br><span class="line">        mPaint = new Paint();</span><br><span class="line">        mPaint.setColor(color);</span><br><span class="line">        mPaint.setStyle(Paint.Style.STROKE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123;</span><br><span class="line">        super.getItemOffsets(outRect, view, parent, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;</span><br><span class="line">        drawVertical(c, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void drawVertical(Canvas c, RecyclerView parent) &#123;</span><br><span class="line">        final int childCount = parent.getChildCount();</span><br><span class="line">        for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">            final View child = parent.getChildAt(i);</span><br><span class="line">            c.drawRect(child.getLeft(), child.getTop(), child.getRight(), child.getBottom(), mPaint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理就是给每个子view画一个边框就行了！是不是很简单</p>]]></content>
    
    <summary type="html">
    
      Android
    
    </summary>
    
      <category term="Android" scheme="https://wzes.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://wzes.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java3 介绍（翻译）</title>
    <link href="https://wzes.github.io/2018/09/30/Book%20Notes/Effective%20Java3%20%E4%BB%8B%E7%BB%8D/"/>
    <id>https://wzes.github.io/2018/09/30/Book Notes/Effective Java3 介绍/</id>
    <published>2018-09-30T14:18:00.000Z</published>
    <updated>2019-09-01T15:32:11.298Z</updated>
    
    <content type="html"><![CDATA[<h3 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h3><p>本书旨在帮助您有效地使用 Java 编程语言及其基础库：java.lang，java.util 和 <a href="http://java.io" target="_blank" rel="noopener">java.io</a>，以及 java.util.concurrent 和 java.util.function等子包。 也会涉及到其他的类库。</p><p>本书一共九十小节，每个小节讲述了一条规则。 这些规则实践通常会使那些最优秀和最富有经验的程序员从中受益。 所有的内容分为11章，每章都涉及软件设计的一个广泛方面。 本书不打算从头到尾阅读：每个小节都或多或少地独立存在。 这些小节有很多交叉引用，因此您可以通过本书轻松绘制自己的课程。</p><p>自本书上一版出版以来，该平台增加了许多新功能。 本书中的大多数项目都以某种方式使用这些功能。 此表显示了主要功能的主要覆盖范围:<br><img src="https://upload-images.jianshu.io/upload_images/7117641-68d157770f16a26c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-09-30 at 9.38.24 PM.png"></p><p>大多数项目都用程序示例说明。 本书的一个关键特性是它包含说明许多设计模式和习语的代码示例。 在适当的情况下，它们与该领域的标准参考工作[Gamma95]相互参照。</p><p>许多小节包含一个或多个程序示例，说明了要避免的一些实践。 这样的例子，有时被称为反模式，清楚地标有评论，例如 <code>//never do this！</code> 在每种情况下，该项目都解释了为什么示例不好并提出了另一种方法。</p><p>本书不适合初学者：它假设您已经熟悉Java。 如果不是，请考虑许多优秀的入门级书籍之一，例如Peter Sestoft的Java Precisely [Sestoft16]。 虽然Effective Java旨在让任何具有该语言工作知识的人都可以阅读，但它应该为高级程序员提供思考的空间。</p><p>本书中的大多数规则都源于一些基本原则。 清晰和简洁至关重要。 组件的用户不应该对其行为感到惊讶。 组件应尽可能小，但不能小。 （正如本书中所使用的，术语组件是指任何可重用的软件元素，从单个方法到由多个包组成的复杂框架。）代码应该被重用而不是被复制。 组件之间的依赖关系应保持最小。 错误应该在发生后尽快检测到，理想情况是在编译时。</p><p>虽然本书中的规则并非100％适用，但在绝大多数情况下，它们都是最佳编程实践的特征。你不应该盲目地遵守这些规则，而只是偶尔并且有充分的理由违反这些规则。像大多数其他学科一样，学习编程艺术包括首先学习规则，然后学习何时打破规则。</p><p>在大多数情况下，本书不涉及性能。它是关于编写清晰，正确，可用，健壮，灵活和可维护的程序。如果你能做到这一点，那么获得所需的性能通常是一件相对简单的事情（第67条）。有些项目确实讨论了性能问题，其中一些项目提供了性能数据。使用短语“在我的机器上”引入的这些数字应该被认为是最近的。</p><p>值得一提的是，我的机器是老旧的自制3.5GHz四核英特尔酷睿i7-4770K，配备16千兆位DDR3-1866 CL9内存，运行Azul的Zulu 9.0.0.15版本的OpenJDK，在Microsoft Windows 7 Professional SP1（64-位）。</p><p>在讨论Java编程语言及其库的功能时，有时需要参考特定版本。 为方便起见，本书使用昵称而不是正式版本名称。 此表显示版本名称和昵称之间的映射：<br><img src="https://upload-images.jianshu.io/upload_images/7117641-e8be621975318c9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-09-30 at 9.48.26 PM.png"></p><p>这些例子相当完整，但有利于完整性的可读性。他们可以自由地使用java.util和java.io包中的类。为了编译示例，您可能必须添加一个或多个导入声明或其他此类样板。该书的网站http://joshbloch.com/effectivejava包含每个示例的扩展版本，您可以编译和运行它。</p><p>在大多数情况下，本书使用了Java语言规范Java SE 8 Edition [JLS]中定义的技术术语。一些术语值得特别提及。该语言支持四种类型：接口（包括注释），类（包括枚举），数组和基元。前三个被称为参考类型。类实例和数组是对象;原始值不是。类的成员由其字段，方法，成员类和成员接口组成。方法的签名由其名称和形式参数的类型组成;签名不包括方法的返回类型。</p><p>本书使用的几个术语与Java语言规范不同。与Java语言规范不同，本书使用继承 inheritance 作为子类 subclassing 的同义词。本书不是对接口使用术语继承，而是简单地声明一个类实现一个接口或一个接口扩展另一个接口。要描述在未指定时应用的访问级别，本书使用传统的package-private而不是技术上正确的包访问[JLS，6.6.1]。</p><p>本书使用了一些未在Java语言规范中定义的技术术语。术语“导出API”或简称“API”是指程序员访问类，接口或包时所使用的类，接口，构造函数，成员和序列化形式。 （API是应用程序编程接口的缩写，优先于其他优选的术语接口，以避免与该名称的语言结构混淆。）编写使用API​​的程序的程序员被称为作为API的用户。其实现使用API​​的类是API的客户端。</p><p>类，接口，构造函数，成员和序列化表单被统称为API元素。导出的API包含可在定义API的包之外访问的API元素。这些是任何客户端都可以使用的API元素，并且API的作者承诺支持。并非巧合的是，它们也是Javadoc实用程序以其默认操作模式生成文档的元素。简而言之，包的导出API由包中每个公共类或接口的公共成员和受保护成员以及构造函数组成。</p><p>在Java 9中，模块系统被添加到平台中。如果库使用模块系统，则其导出的API是库的模块声明导出的所有包的导出API的并集。</p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
      <category term="Java" scheme="https://wzes.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wzes.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java8 Unsafe 解开你神秘的面纱</title>
    <link href="https://wzes.github.io/2018/09/17/Java/Java8%20Unsafe%20%E8%A7%A3%E5%BC%80%E4%BD%A0%E7%A5%9E%E7%A7%98%E7%9A%84%E9%9D%A2%E7%BA%B1/"/>
    <id>https://wzes.github.io/2018/09/17/Java/Java8 Unsafe 解开你神秘的面纱/</id>
    <published>2018-09-16T16:05:00.000Z</published>
    <updated>2019-09-01T15:14:33.833Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>Unsafe 类一直是个很神秘的角色，我们普通开发者几乎不会碰到，顶多也是使用了并发包之类的系统类库，间接使用到了而已。那它到底是用来做什么的呢？它提供了我们直接操作内存的接口。Java 本身作为一个内存自动管理的工具，内存的开辟释放由虚拟机代为管理，然而，HotSpot 的设计者留下了 Unsafe 的类，用于扩展，它可以直接开辟内存，释放内存，读取任意地址的内存，而不受 Java 堆内存的限制。尽管如此，它并不能为我们所用，加载这个类只能由系统的类加载器执行，但我们可以通过反射获取到它的实例对象，Java 反射的确很牛啊。</p><h3 id="如何获取实例对象"><a class="markdownIt-Anchor" href="#如何获取实例对象"></a> 如何获取实例对象</h3><p>第一个问题：为什么我们需要通过 Field 获取，不能使用 newInstance 获取呢？<br>通过 newInstance 的方法获取实力需要构造函数是 public 的，否则会抛异常，及时 getUnsafe 是静态函数，我们也不能通过这个去获取，因为这时候类加载不是系统的，会抛异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private Unsafe() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@CallerSensitive</span><br><span class="line">public static Unsafe getUnsafe() &#123;</span><br><span class="line">    Class var0 = Reflection.getCallerClass();</span><br><span class="line">    if (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">        throw new SecurityException(&quot;Unsafe&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unsafe unsafe = Unsafe.class.newInstance();</span><br></pre></td></tr></table></figure><p>由于 Unsafe 是单例，当类加载时，theUnsafe 实例会被加载，这样我们就可以通过反射获取这个实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    registerNatives();</span><br><span class="line">    Reflection.registerMethodsToFilter(Unsafe.class, new String[]&#123;&quot;getUnsafe&quot;&#125;);</span><br><span class="line">    // 重点</span><br><span class="line">    theUnsafe = new Unsafe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Field 获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">    Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">    theUnsafe.setAccessible(true);</span><br><span class="line">    Unsafe unsafe = (Unsafe) theUnsafe.get(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到这实例，就可以干很多事情了…<br>先来看看 API 图<br><img src="https://upload-images.jianshu.io/upload_images/7117641-ce223b93dc352337.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-09-16 at 11.20.42 PM.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/7117641-b57b7a4e6597503a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-09-16 at 11.20.59 PM.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/7117641-62cb37b125863ad1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-09-16 at 11.21.15 PM.png"><br>太多了，眼睛都看瞎了<br>归个类吧</p><ul><li>直接操作内存，将某个对象的值更改，读取，比如将 String 的 value 更改，是不是很神奇，这个是用反射也可以更改哦！下次面试的时候可以考考别人 String 的 value 怎么才能改的掉，看他会几种。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello Unsafe&quot;;</span><br><span class="line">Field value = str.getClass().getDeclaredField(&quot;value&quot;);</span><br><span class="line">unsafe.putObject(str, unsafe.objectFieldOffset(value), new char[]&#123;&apos;M&apos;, &apos;a&apos;, &apos;j&apos;, &apos;i&apos;, &apos;c&apos;&#125;);]</span><br><span class="line">System.out.println(str);</span><br><span class="line">// output: Majic</span><br><span class="line"></span><br><span class="line">// throw exception</span><br><span class="line">String str = &quot;Hello Unsafe&quot;;</span><br><span class="line">Field value = str.getClass().getDeclaredField(&quot;value&quot;);</span><br><span class="line"></span><br><span class="line">value.setAccessible(true);</span><br><span class="line">value.set(str, new char[] &#123;&apos;f&apos;, &apos;i&apos;, &apos;n&apos;, &apos;a&apos;, &apos;l&apos;&#125;);</span><br></pre></td></tr></table></figure><ul><li>CompareAndSwap 著名的 CAS<br>为了保证并发安全， CAS 涉及到的变量应该使用 volatile 修饰，保证读到的值最新<br>allocateInstance 新建一个没有初始化的实例，各个值都是默认值<br>compareAndSwapLong 第一个参数是 object，第二个参数是变量内存偏移值，可以用 unsafe 类获取实际偏移值，第三个参数是 期望值，第四个三叔目标值，大致的语义就是：如果内存中是期望值，我就更新为目标值，否则不更新</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">    Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">    theUnsafe.setAccessible(true);</span><br><span class="line">    Unsafe unsafe = (Unsafe) theUnsafe.get(null);</span><br><span class="line">    InnerClass o = (InnerClass)unsafe.allocateInstance(InnerClass.class);</span><br><span class="line">    o.print(); // print 100</span><br><span class="line">    Field a = o.getClass().getDeclaredField(&quot;value&quot;);</span><br><span class="line">    unsafe.putLong(o, unsafe.objectFieldOffset(a), 10000);</span><br><span class="line">    o.print(); // print 10000</span><br><span class="line">    unsafe.compareAndSwapLong(o, unsafe.objectFieldOffset(a), 10000, 1111);</span><br><span class="line">    o.print(); // print 1111</span><br><span class="line">    unsafe.compareAndSwapLong(o, unsafe.objectFieldOffset(a), 1000, 10000);</span><br><span class="line">    o.print(); // print 1111</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static class InnerClass &#123;</span><br><span class="line">    // 保证内存可见性</span><br><span class="line">    private volatile long value;</span><br><span class="line">    InnerClass() &#123;</span><br><span class="line">        value = 100L;</span><br><span class="line">    &#125;</span><br><span class="line">    void print() &#123;</span><br><span class="line">        System.err.println(&quot;value==&gt;&quot; + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>线程挂起，取消<br>使用 unsafe.unpark 可以取消 Thread.sleep() 后者 park 的线程<br>使用 unsafe.park(false, 1000000000) 可以挂起当前线程，第一个参数表示是isAbsolute，是否是绝对时间，后一个参数为时间，flase 表示相对时间，0表示一直挂起，单位为纳秒；true 表示绝对时间，单位为毫秒，System.currentThreadMillis 搭配使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InstantiationException, InterruptedException &#123;</span><br><span class="line">    Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">    theUnsafe.setAccessible(true);</span><br><span class="line">    Unsafe unsafe = (Unsafe) theUnsafe.get(null);</span><br><span class="line"></span><br><span class="line">    InnerThread innerThread = new InnerThread(unsafe);</span><br><span class="line">    innerThread.run();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(20);</span><br><span class="line">    // 取消挂起</span><br><span class="line">    unsafe.unpark(innerThread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class InnerThread extends Thread &#123;</span><br><span class="line">    Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">    InnerThread(Unsafe unsafe) &#123;</span><br><span class="line">        this.unsafe = unsafe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;start&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        //unsafe.park(false, 1000000000L);</span><br><span class="line">        System.out.println(&quot;end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>以后又可以吹一波了，一箭双雕，反射，Unsafe</p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
      <category term="Java" scheme="https://wzes.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wzes.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java8 ArrayList &amp; LinkedList 要点</title>
    <link href="https://wzes.github.io/2018/09/13/Java/Java8%20ArrayList&amp;LinkedList%20%E8%A6%81%E7%82%B9/"/>
    <id>https://wzes.github.io/2018/09/13/Java/Java8 ArrayList&amp;LinkedList 要点/</id>
    <published>2018-09-13T11:03:00.000Z</published>
    <updated>2019-09-01T15:10:09.232Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>为什么会想写这东西呢？这是我们都非常常用的数据结构，然而平时除了添加，遍历操作，很少使用其他功能，即使是这样，我们也存在万般理由搞清楚他们的 API，这对于我们在编程时如何选择二者具有良好的指导意义。所以，我觉得好好看看这二者的区别，之前一直以为只是 ArrayList 和 LinkedList 只是数组和链表的区别，我已经大错特错了， Java8 的实现远远不止于此，LinkedList 还有双端队列的功能，之前一直没注意到，最近发现 <a href="https://www.jianshu.com/p/7b6d0f4c2844" target="_blank" rel="noopener">ArrayDeque</a>，却没有看到 LinkedDeque，恍然想起 LinkedList 实现了 Deque 接口，这才恍然大悟～～</p><h3 id="arraylist-linkedlist"><a class="markdownIt-Anchor" href="#arraylist-linkedlist"></a> ArrayList &amp; LinkedList</h3><p>他们的区别从实现的接口上也可以看出来，  LinkedList 多实现了一个接口，下次面试官再问到，我们可以谈谈这个问题，面试官会另眼相看的，面试官就喜欢深入研究的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><h3 id="arraylist-原理"><a class="markdownIt-Anchor" href="#arraylist-原理"></a> ArrayList 原理</h3><p>初始大小为 10，transient Object[] elementData 用来存储元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Default initial capacity.</span><br><span class="line"> */</span><br><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Shared empty array instance used for empty instances.</span><br><span class="line"> */</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">transient Object[] elementData; // non-private to simplify nested class access</span><br><span class="line"></span><br><span class="line">private int size;</span><br><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add 方法，首先检查容量，检查的时候首先在是否是空的，获取一个最小容量，才去执行扩容，为 elementData 赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容策略，每次增长 1/2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想在数组中确定某一个元素的话，那么需要遍历，有两种遍历方式，可根据场景自行选择</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            if (elementData[i]==null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int lastIndexOf(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">            if (elementData[i]==null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = size-1; i &gt;= 0; i--)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>toArray 通常需要进行类型强转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object[] toArray() &#123;</span><br><span class="line">    return Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取某个索引的元素，我们看到也是强转类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">E elementData(int index) &#123;</span><br><span class="line">    return (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Returns the element at the specified position in this list.</span><br><span class="line"> *</span><br><span class="line"> * @param  index index of the element to return</span><br><span class="line"> * @return the element at the specified position in this list</span><br><span class="line"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line"> */</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    return elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有 set 方法，覆盖之前的值，返回旧值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入，需要移动之后的所有元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除某个索引的元素，同样需要移动元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = null; // clear to let GC do its work</span><br><span class="line"></span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除某个 object，看到了 fastRemove，只不过是去除了边界验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int index = 0; index &lt; size; index++)</span><br><span class="line">            if (elementData[index] == null) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int index = 0; index &lt; size; index++)</span><br><span class="line">            if (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="linkedlist"><a class="markdownIt-Anchor" href="#linkedlist"></a> LinkedList</h3><p>由于是链表，很多首尾节点的插入删除操作，方便了很多</p><h4 id="属性"><a class="markdownIt-Anchor" href="#属性"></a> 属性</h4><p>很简单的三个属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">transient int size = 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Pointer to first node.</span><br><span class="line"> * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="line"> *            (first.prev == null &amp;&amp; first.item != null)</span><br><span class="line"> */</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Pointer to last node.</span><br><span class="line"> * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="line"> *            (last.next == null &amp;&amp; last.item != null)</span><br><span class="line"> */</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>node 静态内部类，根据 Effective Java 的描述，这种设计是比较好的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们简单看一些方法即可，由于实现了 Deque，大部分操作非常相似</p><p>add 在尾部添加元素，无需边界检查</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode;</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取元素，需要注意的是为了加快速度，会判断更接近后边还是前边，这样能省一般时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    // assert isElementIndex(index);</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        for (int i = 0; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 indexOf(Object o) 就没这个幸运了，必须老老实实从头开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    int index = 0;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">            if (x.item == null)</span><br><span class="line">                return index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">            if (o.equals(x.item))</span><br><span class="line">                return index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些关于队列的操作，注意方法的返回值，如果出现为空是否会抛出异常呢，像 element pop remove 会抛异常，而 peek，poll 则不会，这些都要注意，否则一不小心就会引发惨案！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public E peek() &#123;</span><br><span class="line">    final Node&lt;E&gt; f = first;</span><br><span class="line">    return (f == null) ? null : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Retrieves, but does not remove, the head (first element) of this list.</span><br><span class="line"> *</span><br><span class="line"> * @return the head of this list</span><br><span class="line"> * @throws NoSuchElementException if this list is empty</span><br><span class="line"> * @since 1.5</span><br><span class="line"> */</span><br><span class="line">public E element() &#123;</span><br><span class="line">    return getFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f = first;</span><br><span class="line">    if (f == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Retrieves and removes the head (first element) of this list.</span><br><span class="line"> *</span><br><span class="line"> * @return the head of this list, or &#123;@code null&#125; if this list is empty</span><br><span class="line"> * @since 1.5</span><br><span class="line"> */</span><br><span class="line">public E poll() &#123;</span><br><span class="line">    final Node&lt;E&gt; f = first;</span><br><span class="line">    return (f == null) ? null : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E pop() &#123;</span><br><span class="line">    return removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它的便不贴代码了，都很好理解了</p><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>总的来说，对这两个东西的用法更加清晰了，来龙去脉摸得更准确了～</p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
      <category term="Java" scheme="https://wzes.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wzes.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java8 ArrayDeque 源码解析</title>
    <link href="https://wzes.github.io/2018/09/12/Java/Java8%20ArrayDeque%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://wzes.github.io/2018/09/12/Java/Java8 ArrayDeque 源码解析/</id>
    <published>2018-09-12T15:36:00.000Z</published>
    <updated>2019-09-01T15:09:15.645Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>今天我们来看看 ArrayDeque，可以说，之前使用的队列的场景不多，所以也没有深入研究队列，但最近在做 LeetCode 的时候，很多时候使用队列会有想不到的功效，比如我们在写 BFS 广度优先遍历的时候，或者在写 二叉树的层次遍历，非递归前序，中序，后序遍历，都会用到这个结构，如果还不会的同学，赶紧去复习一波吧，非常总要，也能为你的笔面试加不少分，很多时候当面试官问道我分析过的源码时，心里那个叫酸爽啊，令面试官刮目相看。闲话不多说了，让我们深入了解一下我们的主角</p><h3 id="前世今生"><a class="markdownIt-Anchor" href="#前世今生"></a> 前世今生</h3><p>实现了 Deque 接口，Deque 继承了 Queue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt;</span><br><span class="line">                           implements Deque&lt;E&gt;, Cloneable, Serializable &#123;&#125;</span><br><span class="line"></span><br><span class="line">public interface Deque&lt;E&gt; extends Queue&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> Queue</h3><p>在了解 ArrayDeque 之前，我们先来看看 Queue 有些什么东西，谈到队列，我们会想到先进先出等特性，我把接口贴出来给大家看一下，如果你还不熟悉这几个方法的区别，是该反省一下了！！！一定要熟记，这是基本功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean add(E e);</span><br><span class="line"></span><br><span class="line">boolean offer(E e);</span><br><span class="line"></span><br><span class="line">E remove();</span><br><span class="line"></span><br><span class="line">E poll();</span><br><span class="line"></span><br><span class="line">E element();</span><br><span class="line"></span><br><span class="line">E peek();</span><br></pre></td></tr></table></figure><h3 id="deque"><a class="markdownIt-Anchor" href="#deque"></a> Deque</h3><p>由于是双端队列，多了很多接口，一张图真相，你可能会说，记住这些所有的太难了，太多了，但总结起来，也并不多，在之前的Queue的接口的基础上，加了 First，Last 的接口，是不是一下子变少了<br><img src="https://upload-images.jianshu.io/upload_images/7117641-a7d6e0c635c213e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-09-12 at 11.00.50 PM.png"></p><h3 id="arraydeque"><a class="markdownIt-Anchor" href="#arraydeque"></a> ArrayDeque</h3><p>终于到了我们的主角了，然而你可能会想，是不是也有LinkedDeque，当初我也这样想过，然而我并没有在 jdk 里找到这个数据结构，但是 LinkedList 却实现了 Deque 也就是说它取代了自己LinkedDeque，也就没有必要多此一举了</p><h4 id="属性"><a class="markdownIt-Anchor" href="#属性"></a> 属性</h4><p>既然是 Array，那么里面势必用数组存储，记住，使用 Object[] elements,而不是T[] elements,聪明的你能否想到这样做的目的呢？哈哈。然后是一个head，tail 的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elements; // non-private to simplify nested class access</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * The index of the element at the head of the deque (which is the</span><br><span class="line">  * element that would be removed by remove() or pop()); or an</span><br><span class="line">  * arbitrary number equal to tail if the deque is empty.</span><br><span class="line">  */</span><br><span class="line"> transient int head;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * The index at which the next element would be added to the tail</span><br><span class="line">  * of the deque (via addLast(E), add(E), or push(E)).</span><br><span class="line">  */</span><br><span class="line"> transient int tail;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h4><p>默认开辟了 16 的数组，一般都是这样，预先开辟空间，不够了再扩容。如果自己指定了大小，那么将调用 allocateElements函数，获取一个 2 的幂次方的大小的容量，如果你知道 Hashmap的初始化，那么这个初始化你一定不陌生！至于怎么做到，你可以自己实践一下，这样会理解的更加透彻！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public ArrayDeque() &#123;</span><br><span class="line">    elements = new Object[16];</span><br><span class="line">&#125;</span><br><span class="line">public ArrayDeque(int numElements) &#123;</span><br><span class="line">    allocateElements(numElements);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public ArrayDeque(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    allocateElements(c.size());</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void allocateElements(int numElements) &#123;</span><br><span class="line">    elements = new Object[calculateSize(numElements)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int calculateSize(int numElements) &#123;</span><br><span class="line">    int initialCapacity = MIN_INITIAL_CAPACITY;</span><br><span class="line">    // Find the best power of two to hold elements.</span><br><span class="line">    // Tests &quot;&lt;=&quot; because arrays aren&apos;t kept full.</span><br><span class="line">    if (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">        initialCapacity = numElements;</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  1);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  2);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  4);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  8);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt; 16);</span><br><span class="line">        initialCapacity++;</span><br><span class="line"></span><br><span class="line">        if (initialCapacity &lt; 0)   // Too many elements, must back off</span><br><span class="line">            initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements</span><br><span class="line">    &#125;</span><br><span class="line">    return initialCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="普通的方法"><a class="markdownIt-Anchor" href="#普通的方法"></a> 普通的方法</h4><p>add 使用 addLast 在末尾追加元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addLast，直接给数组的末尾元素赋值，之后便是移动tail 指针，这里的扩容实现的很有意思，这也对应了为什么容量要为 2的幂次方，当数组大小刚好为 2 的幂次方时，(tail = (tail + 1) &amp; (elements.length - 1) 为零，也就是说如果head也为0，那么就需要扩容了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    elements[tail] = e;</span><br><span class="line">    if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doubleCapacity 函数，新数组的大小为两倍，使用 System.arraycopy 函数复制，效率极高。因为 head 不一定为零，所以在扩容的时候，需要恢复head = 0；这里我们应该推测出整个数组都是存储数据，为了方便删除数组而不移动元素，便使用了指针记录状态，这一实现必须要好好琢磨，下次面试别人的时候可以问一下别人，哈哈，有点小坏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void doubleCapacity() &#123;</span><br><span class="line">    assert head == tail;</span><br><span class="line">    int p = head;</span><br><span class="line">    int n = elements.length;</span><br><span class="line">    int r = n - p; // number of elements to the right of p</span><br><span class="line">    int newCapacity = n &lt;&lt; 1;</span><br><span class="line">    if (newCapacity &lt; 0)</span><br><span class="line">        throw new IllegalStateException(&quot;Sorry, deque too big&quot;);</span><br><span class="line">    Object[] a = new Object[newCapacity];</span><br><span class="line">    System.arraycopy(elements, p, a, 0, r);</span><br><span class="line">    System.arraycopy(elements, 0, a, r, p);</span><br><span class="line">    elements = a;</span><br><span class="line">    head = 0;</span><br><span class="line">    tail = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pollFirst 获取元素，当然是从 head 位置获取元素，这里需要注意的是，head 如果到了数组末尾，那么又会通过 (h + 1) &amp; (elements.length - 1) 变为 0 了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public E pollFirst() &#123;</span><br><span class="line">    int h = head;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E result = (E) elements[h];</span><br><span class="line">    // Element is null if deque empty</span><br><span class="line">    if (result == null)</span><br><span class="line">        return null;</span><br><span class="line">    elements[h] = null;     // Must null out slot</span><br><span class="line">    head = (h + 1) &amp; (elements.length - 1);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pollLast 获取队尾元素，如果队尾元素此时为 0，那么将回到了 数组末尾，别问我怎么知道，老师叫你好好学二进制！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public E pollLast() &#123;</span><br><span class="line">    int t = (tail - 1) &amp; (elements.length - 1);</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E result = (E) elements[t];</span><br><span class="line">    if (result == null)</span><br><span class="line">        return null;</span><br><span class="line">    elements[t] = null;</span><br><span class="line">    tail = t;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的不涉及到删除，添加到操作就显得尤为简单了，直接获取，就不必多说了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public E getFirst() &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E result = (E) elements[head];</span><br><span class="line">    if (result == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @throws NoSuchElementException &#123;@inheritDoc&#125;</span><br><span class="line"> */</span><br><span class="line">public E getLast() &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    E result = (E) elements[(tail - 1) &amp; (elements.length - 1)];</span><br><span class="line">    if (result == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pop 根据先进先出，pop 应该移除队首的元素，注意，这里会抛出异常，如果队首为空的话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> * @throws NoSuchElementException &#123;@inheritDoc&#125;</span><br><span class="line"> */</span><br><span class="line">public E pop() &#123;</span><br><span class="line">    return removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>ArrayDeque 看起来不大，但也有不少东西，知道大概容易，弄懂每一个细节很难，如果你做到了，成功便是你的~</p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
      <category term="Java" scheme="https://wzes.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wzes.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android IntentService 源码解析</title>
    <link href="https://wzes.github.io/2018/09/06/Android/IntentService/"/>
    <id>https://wzes.github.io/2018/09/06/Android/IntentService/</id>
    <published>2018-09-06T15:04:00.000Z</published>
    <updated>2019-09-01T14:58:58.704Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>顾名思义，是一个 Service，先说和普通的 Service 的区别吧，普通的 Service 通常运行在主线程，而 IntentService 的处理逻辑在子线程里，另外 Service 需要自己去 destroy，而 IntentService 在处理完自己的逻辑时会自动结束，那他是怎么实现线程切换，主要还是 Handler 机制，内部有一个 HandleThread，关于这个，可以查看 [HandlerThread 源码解析] (<a href="https://www.jianshu.com/p/5ff83236c8e2" target="_blank" rel="noopener">https://www.jianshu.com/p/5ff83236c8e2</a>)</p><h3 id="前世今生"><a class="markdownIt-Anchor" href="#前世今生"></a> 前世今生</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class IntentService extends Service &#123;&#125;</span><br></pre></td></tr></table></figure><p>继承自 Service，拥有 Service 的特性，不熟悉 Service 的同学可以自行百度，面试必问的，然而感觉我还是不想深入了解，以后再说吧<br>记住</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onCreate -&gt; onStartCommand -&gt; onDestroy</span><br><span class="line">onCreate -&gt; onBind -&gt; onUnbind</span><br></pre></td></tr></table></figure><p>自己写一个 IntentService</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class MyIntentService extends IntentService &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="源码解析"><a class="markdownIt-Anchor" href="#源码解析"></a> 源码解析</h3><p>很熟悉的 Looper 和 ServiceHandler</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private volatile Looper mServiceLooper;</span><br><span class="line">private volatile ServiceHandler mServiceHandler;</span><br><span class="line">private String mName;</span><br><span class="line">private boolean mRedelivery;</span><br><span class="line"></span><br><span class="line">private final class ServiceHandler extends Handler &#123;</span><br><span class="line">    public ServiceHandler(Looper looper) &#123;</span><br><span class="line">        super(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        onHandleIntent((Intent)msg.obj);</span><br><span class="line">        stopSelf(msg.arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下 onCreate，初始化了一个 HandlerThread，然后再把他的 Looper 拿出来，然后抛弃了它，这个 Looper 是子线程的 Looper，因此事件处理也发生在子线程。利用这个 Looper 新建了一个 Handler</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void onCreate() &#123;</span><br><span class="line">      // TODO: It would be nice to have an option to hold a partial wakelock</span><br><span class="line">      // during processing, and to have a static startService(Context, Intent)</span><br><span class="line">      // method that would launch the service &amp; hand off a wakelock.</span><br><span class="line"></span><br><span class="line">      super.onCreate();</span><br><span class="line">      HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);</span><br><span class="line">      thread.start();</span><br><span class="line"></span><br><span class="line">      mServiceLooper = thread.getLooper();</span><br><span class="line">      mServiceHandler = new ServiceHandler(mServiceLooper);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>启动以后调用 onStart，发送一个消息，onHandleIntent((Intent)msg.obj) 里面进行处理，我们要重写这个方法，通常这个在子线程中运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line"> public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123;</span><br><span class="line">     onStart(intent, startId);</span><br><span class="line">     return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"> public void onStart(@Nullable Intent intent, int startId) &#123;</span><br><span class="line">     Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">     msg.arg1 = startId;</span><br><span class="line">     msg.obj = intent;</span><br><span class="line">     mServiceHandler.sendMessage(msg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>处理完即关闭，不需要手动关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public final void stopSelf() &#123;</span><br><span class="line">    stopSelf(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Old version of &#123;@link #stopSelfResult&#125; that doesn&apos;t return a result.</span><br><span class="line"> *  </span><br><span class="line"> * @see #stopSelfResult</span><br><span class="line"> */</span><br><span class="line">public final void stopSelf(int startId) &#123;</span><br><span class="line">    if (mActivityManager == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        mActivityManager.stopServiceToken(</span><br><span class="line">                new ComponentName(this, mClassName), mToken, startId);</span><br><span class="line">    &#125; catch (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们自己的 IntentService 里面，写处理的逻辑，由于是在子线程中，所以可以处理耗时的逻辑，不必担心 ANR，普通 Service 由于在主线程运行，所以不能直接处理耗时逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onHandleIntent(Intent intent) &#123;</span><br><span class="line">    if (intent != null) &#123;</span><br><span class="line">        final String action = intent.getAction();</span><br><span class="line">        if (ACTION_FOO.equals(action)) &#123;</span><br><span class="line">            final String param1 = intent.getStringExtra(EXTRA_PARAM1);</span><br><span class="line">            final String param2 = intenonHt.getStringExtra(EXTRA_PARAM2);</span><br><span class="line">            handleActionFoo(param1, param2);</span><br><span class="line">        &#125; else if (ACTION_BAZ.equals(action)) &#123;</span><br><span class="line">            final String param1 = intent.getStringExtra(EXTRA_PARAM1);</span><br><span class="line">            final String param2 = intent.getStringExtra(EXTRA_PARAM2);</span><br><span class="line">            handleActionBaz(param1, param2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>非常简单的 IntentService，使用的时候注意与普通 Service 的区别即可，里面使用了 HandlerThread 获取 Looper 对象，处理完会自动关闭，即调用 onDestroy，再次启动又重新走 Service 的生命周期，一个问题，如果多次 startService，那么 onHandleIntent 是怎么样的呢？答案是一次执行，因为 Looper 事件处理是阻塞的</p>]]></content>
    
    <summary type="html">
    
      Android
    
    </summary>
    
      <category term="Android" scheme="https://wzes.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://wzes.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>BloomFilter&amp;Hyperloglog 去重&amp;统计</title>
    <link href="https://wzes.github.io/2018/09/06/Backend/BloomFilter&amp;Hyperloglog%20%E5%8E%BB%E9%87%8D&amp;%E7%BB%9F%E8%AE%A1/"/>
    <id>https://wzes.github.io/2018/09/06/Backend/BloomFilter&amp;Hyperloglog 去重&amp;统计/</id>
    <published>2018-09-06T04:53:00.000Z</published>
    <updated>2019-09-01T15:18:42.043Z</updated>
    
    <content type="html"><![CDATA[<h3 id="去重小结"><a class="markdownIt-Anchor" href="#去重小结"></a> 去重小结</h3><p>最近在做爬虫的时候，遇到了去重的问题，关于去重，有很多地方可以做，比如</p><ul><li>内存级别，利用 hashmap，准确，性能好但是内存有限</li><li>数据库，利用唯一键，准确，存储量大但是性能差</li><li>内存级别 BloomFilter，利用 bitmap，性能好，存储量比 hashmap 大得多，但是有误差<br>实际使用的时候要根据场景去 tradeoff，没有最好的办法，只有最合适的办法</li></ul><h3 id="基数统计"><a class="markdownIt-Anchor" href="#基数统计"></a> 基数统计</h3><p>同样，当我们需要统计个数时，也有很多办法，比如</p><ul><li>内存级别 hashset，准确，但是存储量跟数据量成正比，原始数据还存在</li><li>数据库也可以做，准确但性能较差</li><li>内存级别，Hyperloglog，只需少量内存即可，但误差较大<br>如果我们单单只是技术统计，对准确率要求并不高，可以采取 Hyperloglog，只不过没有记录原始数据，但这恰好为节省内存埋下了伏笔</li></ul><h3 id="bloomfilter-原理"><a class="markdownIt-Anchor" href="#bloomfilter-原理"></a> BloomFilter 原理</h3><p>有 k 个 hash 函数，对每一个 key 进行 hash 函数计算大小，将 m 位 0 字符串在对应的取余赋值为 1 即可</p><blockquote><p>检查是否存在：计算 key 对应的 k 个 hash值在字符串中的位是否全为 1，如果是，则有可能存在，否则肯定不存在</p></blockquote><p>例子， key = bloom hashcode = [1, 2, 3]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">011100000000000000000</span><br></pre></td></tr></table></figure><p>接下来 key = filter 经过同样的 hash 计算 hashcode = [2,4,6]<br>经过计算不存在，则放入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">011101000000000000000</span><br></pre></td></tr></table></figure><p>实际应用中如何选择 m，k，f 的大小，有一个数据公式推导，大家可以自行 Google</p><h3 id="hyperloglog-原理"><a class="markdownIt-Anchor" href="#hyperloglog-原理"></a> HyperLogLog 原理</h3><p>使用概率的原理<br>这篇文章还不错 <a href="https://blog.csdn.net/firenet1/article/details/77247649" target="_blank" rel="noopener">https://blog.csdn.net/firenet1/article/details/77247649</a><br>总结一下，就是说，我们丢硬币的场景，第一次出现正面，之前都是反面的概率与实验次数有一个关系 n = 2^k，那么我们将 key 映射成 二进制hashcode，0001010, 该过程完全随机，那么 n 就等于 2^4，也就是说试验次数达到 8，但误差较大，所以我们采用多个映射取平均，这样误差就会变小<br>但是这样的误差很大</p><p>大家可以看看 <a href="https://github.com/addthis/stream-lib" target="_blank" rel="noopener">stream-lib</a> 里边的实现，很经典</p><h3 id="欢迎讨论~"><a class="markdownIt-Anchor" href="#欢迎讨论~"></a> 欢迎讨论～</h3>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
      <category term="Java" scheme="https://wzes.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wzes.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Geohash&amp;Haversine 附近功能</title>
    <link href="https://wzes.github.io/2018/09/06/Backend/Geohash&amp;Haversine%20%E9%99%84%E8%BF%91%E5%8A%9F%E8%83%BD/"/>
    <id>https://wzes.github.io/2018/09/06/Backend/Geohash&amp;Haversine 附近功能/</id>
    <published>2018-09-06T01:13:00.000Z</published>
    <updated>2019-09-01T15:18:08.690Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>最近偶然间看到了 Geohash 算法，才想起来之前自己做过的<strong>附近</strong>的功能简直不堪一击，竟然是计算所有与目标点的距离，再排序。想必有经验的人早就笑出声了吧，按照以前的水平，如果不这样做，那也得找出比较相近的，先不计算球面距离，然后得到一个小一点的集合，再计算距离，这样计算量大大减小，然而还是要扫描所有点，那有没有办法不扫描整张表就能得到附近点的信息，想到这，我们而已给所有点预先做一个标签，我们每一次想找附近的点就去比较这些标签，如果我们能够保证，距离相近的点在一个标签内，那么我们就可以只取该标签的点，然后再做距离计算，这样就不用扫描整张表了，问题到这，基本已经浮出水面，接下来就是最核心的问题，如何将点的信息映射成标签，这便是 Geohash <a href="https://en.wikipedia.org/wiki/Geohash" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Geohash</a> wiki 上有所解释，但不是那么易懂，可以看看这位仁兄的博客，<a href="https://www.cnblogs.com/LBSer/p/3310455.html" target="_blank" rel="noopener">GeoHash核心原理解析</a> 讲解清晰易懂</p><h3 id="相似度"><a class="markdownIt-Anchor" href="#相似度"></a> 相似度</h3><p>Geohash 将经纬度映射成一段字符串，越是相近的点，前缀匹配就越长，每一位都会有一个精度问题，匹配的越长距离就越近，当然也存在误差<br><img src="https://upload-images.jianshu.io/upload_images/7117641-f2d5cbb6c0134b71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot from 2018-09-06 09-10-02.png"><br>利用这个来做附近的点选取再合适不过了。</p><h3 id="haversine-计算球面距离"><a class="markdownIt-Anchor" href="#haversine-计算球面距离"></a> Haversine 计算球面距离</h3><p>传统的计算球面距离公式计算量大，当我们没有要求很高的精度的时候，可以适当通过别的更简单的计算公式得到近似的结果，这便是 Haversine 发挥的作用</p>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
      <category term="Java" scheme="https://wzes.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wzes.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android Rxjava 源码解析</title>
    <link href="https://wzes.github.io/2018/09/05/Android/Android%20Rxjava/"/>
    <id>https://wzes.github.io/2018/09/05/Android/Android Rxjava/</id>
    <published>2018-09-04T16:15:16.000Z</published>
    <updated>2019-09-01T14:46:44.886Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>RxJava 这个名字，想必做过 Android 的人都有所了解，简单的使用几乎不成问题，但里面的知识点却一向令人望而生畏，接下来几日我便想慢慢解开这层面纱</p><h3 id="先来回归一下简单的例子"><a class="markdownIt-Anchor" href="#先来回归一下简单的例子"></a> 先来回归一下简单的例子</h3><p>没有线程切换的最简单的版本，初学者一定很困惑，这段代码是怎么运行起来的，这段代码中最具核心的是 Observable，Observable 有一个方法是 subcribe，当调用这个方法时便调用了 ObservableOnSubscribe.subscibe 方法，里面调用了 e.onNext()，也就是调用了 Obersver 的 onNext 方法，整个的流程便是这样，围绕这个流程，便衍生出了线程切换，各种类型的任务，背压。。。。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception &#123;</span><br><span class="line">        e.onNext(&quot;hello&quot;);</span><br><span class="line">        e.onNext(&quot;world&quot;);</span><br><span class="line">        e.onComplete();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Observer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(String o) &#123;</span><br><span class="line">        System.out.println(o.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="map"><a class="markdownIt-Anchor" href="#map"></a> map</h3><p>为了方便理解，举一个简单的例子，实际的Rajava 与之类似<br>映射，将一个 Observable 转化成另一个 Observable 的过程，主要是 onNext 的调用链的关系，实际想起来还是挺复杂的，一个递归的结构，每一个 map 操作都会封装一个 Observable 而他的参数是 MapSubscribe 的发射器，里面在调用 onNext 时穿进去的参数是 transformer.call 的结果，这就说明了如果有 map 存在，首先会递归到开始，然后调用离之最近的 mapSubcriber 的 call 函数，获取结果，并调用下一个发射器的onNext函数，知道调用最顶层的Subcriber的回调函数，该过程还是很有意思的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123;</span><br><span class="line">                subscriber.onNext(10);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).map(new Observable.Transformer&lt;Integer, String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String call(Integer from) &#123;</span><br><span class="line">                return String.valueOf(from);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).map(new Observable.Transformer&lt;String, String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String call(String from) &#123;</span><br><span class="line">                return String.valueOf(from + 10);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).map(new Observable.Transformer&lt;String, String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String call(String from) &#123;</span><br><span class="line">                return String.valueOf(from + 10);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io()).subscribe(new Subscriber&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onStart() &#123;</span><br><span class="line">                System.out.println(&quot;onStart called&quot;+ &quot; &quot; + Thread.currentThread());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onCompleted() &#123;</span><br><span class="line">                System.out.println(&quot;onComplete called&quot;+ &quot; &quot; + Thread.currentThread());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(String object) &#123;</span><br><span class="line">                System.out.println(object + &quot; &quot; + Thread.currentThread());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable t) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Android
    
    </summary>
    
      <category term="Android" scheme="https://wzes.github.io/categories/Android/"/>
    
      <category term="Java" scheme="https://wzes.github.io/categories/Android/Java/"/>
    
    
      <category term="Java" scheme="https://wzes.github.io/tags/Java/"/>
    
      <category term="Android" scheme="https://wzes.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java2 读书笔记78条</title>
    <link href="https://wzes.github.io/2018/08/30/Book%20Notes/Effective-Java-2-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-78%E6%9D%A1/"/>
    <id>https://wzes.github.io/2018/08/30/Book Notes/Effective-Java-2-读书笔记-78条/</id>
    <published>2018-08-30T14:18:00.000Z</published>
    <updated>2019-09-01T15:31:55.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一条-考虑使用静态工厂方法代替构造器"><a class="markdownIt-Anchor" href="#第一条-考虑使用静态工厂方法代替构造器"></a> 第一条 考虑使用静态工厂方法代替构造器</h3><h4 id="优势"><a class="markdownIt-Anchor" href="#优势"></a> 优势</h4><ol><li>有名称</li><li>不必每次调用的时候都创建一个对象</li><li>返回原返回类型的所有子类型的对象</li><li>在创建参数实例化的时候，他们使代码变得更简洁</li></ol><h4 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h4><ol><li>类如果不含有共有的或者受保护的类构造器，就不能被子类化</li><li>他们与其他的静态方法没什么区别</li></ol><h3 id="第二条-遇到多个构造器时要考虑用构建器"><a class="markdownIt-Anchor" href="#第二条-遇到多个构造器时要考虑用构建器"></a> 第二条 遇到多个构造器时要考虑用构建器</h3><p>构造器参数多，个数多，则优先使用 Builder 模式，构建器比JavaBeans更加安全</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Builder&lt;T&gt; &#123;</span><br><span class="line">  public T build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三条-用私有构造器火鹤枚举类型强化singleton属性"><a class="markdownIt-Anchor" href="#第三条-用私有构造器火鹤枚举类型强化singleton属性"></a> 第三条 用私有构造器火鹤枚举类型强化singleton属性</h3><p>单元素的枚举类型已经成为实现Singleton的最佳方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public enum Elvis &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  public void leaveTheBuilding() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第四条-通过私有构造器强化不可实例化的能力"><a class="markdownIt-Anchor" href="#第四条-通过私有构造器强化不可实例化的能力"></a> 第四条 通过私有构造器强化不可实例化的能力</h3><p>超类也不能被实例化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class UtilityClass &#123;</span><br><span class="line">  private UtilityClass() &#123;</span><br><span class="line">    throw new AssertionError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第五条-避免创建不必要的对象"><a class="markdownIt-Anchor" href="#第五条-避免创建不必要的对象"></a> 第五条 避免创建不必要的对象</h3><ol><li>避免重复创建相同的对象</li><li>优先使用基本类型而不是装箱基本类型</li><li>不要盲目觉得创建对象代价十分昂贵，使用对象池的特例：数据库连接池，否则没必要创建对象池，会影响GC</li></ol><h3 id="第六条-消除过期的对象引用"><a class="markdownIt-Anchor" href="#第六条-消除过期的对象引用"></a> 第六条 消除过期的对象引用</h3><ol><li>常见的场景在与ArrayList，删除对象后需要把该索引位置置空。</li><li>监听器，其他回调</li></ol><p>可使用 WeakHashMap 将键保持为弱引用</p><h3 id="第七条-避免使用终结方法"><a class="markdownIt-Anchor" href="#第七条-避免使用终结方法"></a> 第七条 避免使用终结方法</h3><p>终结方法通常是不可预测的，也是很危险的吗，一般情况下是不必要的。使用终结方法是很危险的。</p><p>终结方法线程的优先级比应用程序线程的优先级低很多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 不保证 finalize 执行</span><br><span class="line">System.gc System.runFinaliaation</span><br><span class="line">// 保证执行</span><br><span class="line">System.runFinalizersOnExit Runtime.runFinalizersOnExit</span><br></pre></td></tr></table></figure><h3 id="第八条-覆盖-equals-时请遵守通用约定"><a class="markdownIt-Anchor" href="#第八条-覆盖-equals-时请遵守通用约定"></a> 第八条 覆盖 equals 时请遵守通用约定</h3><ul><li>类是私有的或是包级私有的，可以确定它的 equals 方法永远不会被调用。<br><strong>防止方法被调用的方法</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Ovveride</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">  throw new AssertionError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="equals-方法实现了等价关系"><a class="markdownIt-Anchor" href="#equals-方法实现了等价关系"></a> equals 方法实现了等价关系</h6><ul><li>自反性</li><li>对称性</li><li>传递性</li><li>一致性<br>一般做法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">  if (o == this) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!(o instanceOf MyClass)) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  MyClass class = (MyClass) o;</span><br><span class="line">  // 比较各个域值</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第九条-覆盖-equals-时总要覆盖-hashcode"><a class="markdownIt-Anchor" href="#第九条-覆盖-equals-时总要覆盖-hashcode"></a> 第九条 覆盖 equals 时总要覆盖 hashCode</h3><p>Object 规范（JavaSE6）</p><ul><li>同一个对象多次调用必须一致，同一个程序多次执行可以不一致</li><li>equals 相等，hashCode 必然要相等</li><li>hashCode 相同，equals 不一定相同</li></ul><p><strong>一个好的散列函数通常倾向于“为不同的对象产生不相等的散列码”</strong><br>如何计算：</p><ol><li>把某个非零常熟值，比如说17，保存到一个名为 result 的 int 类型的变量中。</li><li>对于对象中每个关键域 f （指 equals 方法中涉及到的每个域），完成以下步骤：<br>a. 为该域计算 int 类型的散列码 c ：<ul><li>如果该域是 boolean 类型，则计算 （f ? 1 : 0）</li><li>如果该域是 byte ，char，short，int，则计算 （int）f</li><li>如果该域是 long，则计算（int）（f ^ （f &gt;&gt; 32））</li><li>如果该域是 float，则计算 Float.floatToIntBits(f);</li><li>如果该域是 double，则计算 Double.doubleToLongBits(f), 然后按照步骤 a.3，计算 long 的散列值</li><li>如果该域是一个对象引用，并且该类的 equals 方法通过递归的调用 equals 的方式来比较这个域，则同样为这个域递归的调用 hashCode。如果这个域为 null， 则为 0</li><li>如果该域是一个数组，则需要把每一个元素当作单独的域来处理。</li></ul></li></ol><p>b. 按照下面的公式，把步骤2.a 中计算得到的散列码 c 合并到 result 中：<br>result = 31 * result + c；<br>3. 返回 result<br>4. check</p><h3 id="第十条-始终要覆盖-tostring"><a class="markdownIt-Anchor" href="#第十条-始终要覆盖-tostring"></a> 第十条 始终要覆盖 toString</h3><p>建议所有的子类都应该覆盖这个方法</p><h3 id="第十一条-谨慎的覆盖-clone"><a class="markdownIt-Anchor" href="#第十一条-谨慎的覆盖-clone"></a> 第十一条 谨慎的覆盖 clone</h3><p>创建和返回该对象的一个拷贝，不必调用构造器创建对象<br>JavaSE6 的约定内容：</p><ul><li>x.clone() != x 为 true</li><li>x.clone().getClass() == x.getClass() 为 true</li><li>x.clone().equals(x) 为 true<br>一般写法，通过递归 super.clone() 创建对象，再将域逐个复制即可</li></ul><h3 id="第十二条-考虑实现-comparable-接口"><a class="markdownIt-Anchor" href="#第十二条-考虑实现-comparable-接口"></a> 第十二条 考虑实现 Comparable 接口</h3><p>实现了 Comparable 接口，就表明它的实例具有内在的排序关系。<br>当然，也可以使用外在排序 Comparator</p><h3 id="第十三条-使类和成员的可访问性最小化"><a class="markdownIt-Anchor" href="#第十三条-使类和成员的可访问性最小化"></a> 第十三条 使类和成员的可访问性最小化</h3><p>设计良好的模块会隐藏所有的实现细节，把它的API与它的实现清晰的隔离开来。</p><ul><li>尽可能地使每个类或成员不被外界访问</li><li>有四种访问性：<ul><li>私有的（private）</li><li>包级私有的（default）</li><li>受保护的（protected）</li><li>共有的（public）<br><strong>实例域不能是共有的</strong></li></ul></li></ul><h3 id="第十四条-在共有类中使用访问方法而非共有域"><a class="markdownIt-Anchor" href="#第十四条-在共有类中使用访问方法而非共有域"></a> 第十四条 在共有类中使用访问方法而非共有域</h3><p>有时候，可能会编写一些退化类，没有什么作用，只是用来集中实例域<br>Java平台类库中有一些违反了，但应该警惕<br><strong>共有类永远不应该暴露可变的域</strong></p><h3 id="第十五条-使可变性最小化"><a class="markdownIt-Anchor" href="#第十五条-使可变性最小化"></a> 第十五条 使可变性最小化</h3><p>不可变类只是其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变，Java 平台类库中包含了许多不可变类，比如 String，基本类型包装类，BigDecimal 和 BigInteger。存在不可变的类有很多理由：不可变的类比可变的类更加容易设计，实现和使用。<br>原则</p><ul><li>不要提供任何会修改对象状态的方法</li><li>保证类不会被扩展</li><li>使所有的域都是 final 的</li><li>使所有的域都是私有的</li><li>确保对于任何可变组件的互斥访问</li></ul><h3 id="第十六条-复合优先于继承"><a class="markdownIt-Anchor" href="#第十六条-复合优先于继承"></a> 第十六条 复合优先于继承</h3><p>继承虽然是实现代码重用的有力手段，但它会打破封装性。而复合可以解决这个问题，只有当子类是超类的子类型时，才适用继承（is-a关系）。Java 平台类库中 Stack和Vector，Properties和Hashtable 违反了这个原则</p><h3 id="第十七条-要么为继承而设计并提供文档说明要么就禁止继承"><a class="markdownIt-Anchor" href="#第十七条-要么为继承而设计并提供文档说明要么就禁止继承"></a> 第十七条 要么为继承而设计，并提供文档说明，要么就禁止继承</h3><p>对于专门为了继承而设计的类需要具有良好文档说明，该文档必须精确的描述覆盖每个方法所带来的影响</p><ul><li>构造器绝不能调用可被覆盖的方法</li></ul><h3 id="第十八条-接口优于抽象类"><a class="markdownIt-Anchor" href="#第十八条-接口优于抽象类"></a> 第十八条 接口优于抽象类</h3><p>Java 程序设计语言提供了两种机制，可以用来定义允许多个实现的类型：接口和抽象</p><ul><li>现有的类很容易被更新，以实现新的借口</li><li>接口是定义mixin（混合类型）的理想选择</li><li>接口允许我们构造非层次结构的类型框架</li></ul><h3 id="第十九条-接口只用于定义类型"><a class="markdownIt-Anchor" href="#第十九条-接口只用于定义类型"></a> 第十九条 接口只用于定义类型</h3><p>接口应该只被用来定义类型，不应该被用来导出常量<br>导出常量的做法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class PhysicalConstants  &#123;</span><br><span class="line">  //  私有</span><br><span class="line">  private PhysicalConstants() &#123;&#125;</span><br><span class="line">  public static final double AVOGADROS_NUMBER = 6.02214199e23;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二十条-类层次优先于标签类"><a class="markdownIt-Anchor" href="#第二十条-类层次优先于标签类"></a> 第二十条 类层次优先于标签类</h3><p>标签类使得类变得复杂难懂，考虑使用类层次替换<br><strong>域是不能做成 final 的</strong></p><h3 id="第二十一条-用函数对象表示策略"><a class="markdownIt-Anchor" href="#第二十一条-用函数对象表示策略"></a> 第二十一条 用函数对象表示策略</h3><p>简而言之，函数指针的主要用途就是实现策略模式。为了在 Java 中实现这种模式，要声明一个接口来表示该策略，并且为每个具体的策略声明实现一个该接口的类。当一个具体策略只被使用一次的时候，通常使用匿名类的方式和实例化这个具体策略类。当一个具体策略是设计用来重复使用的时候，他的类通常就要实现为私有的静态成员类，并通过共有的静态final域被导出，其类型为该策略接口。</p><h3 id="第二十二条-优先考虑静态成员类"><a class="markdownIt-Anchor" href="#第二十二条-优先考虑静态成员类"></a> 第二十二条 优先考虑静态成员类</h3><p>嵌套类被定义为在另外一个类的内部的类，有四种：静态成员类，非静态成员类，匿名类，局部类，后三者为内部类；</p><h3 id="第二十三条-请不要在新代码中使用原生态类型"><a class="markdownIt-Anchor" href="#第二十三条-请不要在新代码中使用原生态类型"></a> 第二十三条 请不要在新代码中使用原生态类型</h3><p>例如，List 原生态类型不能再编译器发现类型转化错误，而使用范型则可以，更加安全</p><h3 id="第二十四条-消除非受检警告"><a class="markdownIt-Anchor" href="#第二十四条-消除非受检警告"></a> 第二十四条 消除非受检警告</h3><h3 id="第二十五条-列表优先于数组"><a class="markdownIt-Anchor" href="#第二十五条-列表优先于数组"></a> 第二十五条 列表优先于数组</h3><h3 id="第二十六条-优先考虑范型"><a class="markdownIt-Anchor" href="#第二十六条-优先考虑范型"></a> 第二十六条 优先考虑范型</h3><p>不能创建范型数组</p><h3 id="第二十七条-优先考虑范型方法"><a class="markdownIt-Anchor" href="#第二十七条-优先考虑范型方法"></a> 第二十七条 优先考虑范型方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T entends Comparable&lt;T&gt;&gt; T max(List&lt;T&gt; list) &#123;</span><br><span class="line">  Iterator&lt;T&gt; i = list.iterator();</span><br><span class="line">  T result = i.next();</span><br><span class="line">  while (i.hasNext()) &#123;</span><br><span class="line">    T t = i.next();</span><br><span class="line">    if (t.compareTo(result) &gt; 0) &#123;</span><br><span class="line">      result = t&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二十八条-利用有限通配符来提升api的灵活性"><a class="markdownIt-Anchor" href="#第二十八条-利用有限通配符来提升api的灵活性"></a> 第二十八条 利用有限通配符来提升API的灵活性</h3><h3 id="第二十九条-优先考虑类型安全的异构容器"><a class="markdownIt-Anchor" href="#第二十九条-优先考虑类型安全的异构容器"></a> 第二十九条 优先考虑类型安全的异构容器</h3><h3 id="第三十条-用-enum-代替-int"><a class="markdownIt-Anchor" href="#第三十条-用-enum-代替-int"></a> 第三十条 用 enum 代替 int</h3><h3 id="第三十一条-用实例域代替序数"><a class="markdownIt-Anchor" href="#第三十一条-用实例域代替序数"></a> 第三十一条 用实例域代替序数</h3><h3 id="第三十二条-用-enumset-代替位域"><a class="markdownIt-Anchor" href="#第三十二条-用-enumset-代替位域"></a> 第三十二条 用 EnumSet 代替位域</h3><h3 id="第三十三条-用enummap-代替序数索引"><a class="markdownIt-Anchor" href="#第三十三条-用enummap-代替序数索引"></a> 第三十三条 用EnumMap 代替序数索引</h3><h3 id="第三十四条-用接口模拟可伸缩的枚举"><a class="markdownIt-Anchor" href="#第三十四条-用接口模拟可伸缩的枚举"></a> 第三十四条 用接口模拟可伸缩的枚举</h3><p>虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface Operation &#123;</span><br><span class="line">  double apply(double x, double y);</span><br><span class="line">&#125;</span><br><span class="line">public enum BasicOperation implements Operation &#123;</span><br><span class="line">  PLUS(&quot;+&quot;) &#123;</span><br><span class="line">    public double apply(double x, double y) &#123; return x + y; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  private final String symbol;</span><br><span class="line">  BasicOperation(String symbol) &#123;</span><br><span class="line">    this.symbol = symbol;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三十五条-注解优先于命名模式"><a class="markdownIt-Anchor" href="#第三十五条-注解优先于命名模式"></a> 第三十五条 注解优先于命名模式</h3><p>命名模式指的是：给一些类或者方法使用有特定约束的名字</p><h3 id="第三十六条-坚持使用-override-注解"><a class="markdownIt-Anchor" href="#第三十六条-坚持使用-override-注解"></a> 第三十六条 坚持使用 Override 注解</h3><p>坚持使用 Override 注解能够避免一些错误</p><h3 id="第三十七条-用标记接口定义类型"><a class="markdownIt-Anchor" href="#第三十七条-用标记接口定义类型"></a> 第三十七条 用标记接口定义类型</h3><p>标记接口是没有包含任何方法的接口，例如 Serializable 接口，不包含任何方法</p><h3 id="第三十八条-检查参数的有效性"><a class="markdownIt-Anchor" href="#第三十八条-检查参数的有效性"></a> 第三十八条 检查参数的有效性</h3><p>对于共有的可以使用 throws 说明方法会产生什么异常<br>对于私有的方法可以使用 assert 断言<br>简而言之，每当编写方法或者构造器的时候，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法提开头处，通过显式的检查来实施这些限制。</p><h3 id="第三十九条-必要时进行保护性拷贝"><a class="markdownIt-Anchor" href="#第三十九条-必要时进行保护性拷贝"></a> 第三十九条 必要时进行保护性拷贝</h3><p>简而言之，如果类具有从客户端得到或者返回客户端的可变组件，类就必须保护性地拷贝这些组件。如果拷贝的成本受到限制，并且类信任它的客户端不会不恰当的修改组件，就可以在文档中指明客户端的职责是不得修改受到影响的组件，以此来代替保护性拷贝</p><h3 id="第四十条-谨慎设计方法签名"><a class="markdownIt-Anchor" href="#第四十条-谨慎设计方法签名"></a> 第四十条 谨慎设计方法签名</h3><ul><li>谨慎的选择方法的名称</li><li>不要过于追求提供便利的方法</li><li>避免过长的参数列表</li></ul><h3 id="第四十一条-慎用重载"><a class="markdownIt-Anchor" href="#第四十一条-慎用重载"></a> 第四十一条 慎用重载</h3><p>安全而保守的策略是，永远不要导出两个具有相同参数树木的重载方法</p><h3 id="第四十二条-慎用可变参数"><a class="markdownIt-Anchor" href="#第四十二条-慎用可变参数"></a> 第四十二条 慎用可变参数</h3><h3 id="第四十三条-返回零长度的数组或者集合而不是null"><a class="markdownIt-Anchor" href="#第四十三条-返回零长度的数组或者集合而不是null"></a> 第四十三条 返回零长度的数组或者集合，而不是null</h3><p>返回类型为 List 或数组，长度为零是返回 Collections.empty();</p><h3 id="第四十四条-为所有导出的api元素编写文档注释"><a class="markdownIt-Anchor" href="#第四十四条-为所有导出的api元素编写文档注释"></a> 第四十四条 为所有导出的API元素编写文档注释</h3><h3 id="第四十五条-将局部变量的作用域最小化"><a class="markdownIt-Anchor" href="#第四十五条-将局部变量的作用域最小化"></a> 第四十五条 将局部变量的作用域最小化</h3><h3 id="第四十六条-for-each-循环优先于传统的for循环"><a class="markdownIt-Anchor" href="#第四十六条-for-each-循环优先于传统的for循环"></a> 第四十六条 for-each 循环优先于传统的for循环</h3><h3 id="第四十七条-了解和使用类库"><a class="markdownIt-Anchor" href="#第四十七条-了解和使用类库"></a> 第四十七条 了解和使用类库</h3><h3 id="第四十八条-如果需要精确的答案请避免使用-float-和-double"><a class="markdownIt-Anchor" href="#第四十八条-如果需要精确的答案请避免使用-float-和-double"></a> 第四十八条 如果需要精确的答案，请避免使用 float 和 double</h3><h3 id="第四十九条-基本类型优先于装箱基本类型"><a class="markdownIt-Anchor" href="#第四十九条-基本类型优先于装箱基本类型"></a> 第四十九条 基本类型优先于装箱基本类型</h3><h3 id="第五十条-如果其他类型更合适则尽量避免使用字符串"><a class="markdownIt-Anchor" href="#第五十条-如果其他类型更合适则尽量避免使用字符串"></a> 第五十条 如果其他类型更合适，则尽量避免使用字符串</h3><h3 id="第五十一条-当心字符串连接的性能"><a class="markdownIt-Anchor" href="#第五十一条-当心字符串连接的性能"></a> 第五十一条 当心字符串连接的性能</h3><h3 id="第五十二条-通过接口引用对象"><a class="markdownIt-Anchor" href="#第五十二条-通过接口引用对象"></a> 第五十二条 通过接口引用对象</h3><p>应该优先使用接口而不是类来引用对象</p><h3 id="第五十三条-接口优先于反射机制"><a class="markdownIt-Anchor" href="#第五十三条-接口优先于反射机制"></a> 第五十三条 接口优先于反射机制</h3><h3 id="第五十四条-谨慎的使用本地方法"><a class="markdownIt-Anchor" href="#第五十四条-谨慎的使用本地方法"></a> 第五十四条 谨慎的使用本地方法</h3><h3 id="第五十五条-谨慎的使用优化"><a class="markdownIt-Anchor" href="#第五十五条-谨慎的使用优化"></a> 第五十五条 谨慎的使用优化</h3><h3 id="第五十六条-遵守普遍接受的命名习惯"><a class="markdownIt-Anchor" href="#第五十六条-遵守普遍接受的命名习惯"></a> 第五十六条 遵守普遍接受的命名习惯</h3><h3 id="第五十七条-只有针对异常的情况才使用异常"><a class="markdownIt-Anchor" href="#第五十七条-只有针对异常的情况才使用异常"></a> 第五十七条 只有针对异常的情况才使用异常</h3><h3 id="第五十八条-对可恢复的情况使用受检异常对编程错误使用运行时异常"><a class="markdownIt-Anchor" href="#第五十八条-对可恢复的情况使用受检异常对编程错误使用运行时异常"></a> 第五十八条 对可恢复的情况使用受检异常，对编程错误使用运行时异常</h3><h3 id="第五十九条-避免不必要地使用受检的异常"><a class="markdownIt-Anchor" href="#第五十九条-避免不必要地使用受检的异常"></a> 第五十九条 避免不必要地使用受检的异常</h3><h3 id="第六十条-优先使用标准的异常"><a class="markdownIt-Anchor" href="#第六十条-优先使用标准的异常"></a> 第六十条 优先使用标准的异常</h3><h3 id="第六十一条-抛出与抽象相对应的异常"><a class="markdownIt-Anchor" href="#第六十一条-抛出与抽象相对应的异常"></a> 第六十一条 抛出与抽象相对应的异常</h3><h3 id="第六十二条-每个方法抛出的异常都要有文档"><a class="markdownIt-Anchor" href="#第六十二条-每个方法抛出的异常都要有文档"></a> 第六十二条 每个方法抛出的异常都要有文档</h3><h3 id="第六十三条-在细节消息中包含能捕获失败的消息"><a class="markdownIt-Anchor" href="#第六十三条-在细节消息中包含能捕获失败的消息"></a> 第六十三条 在细节消息中包含能捕获失败的消息</h3><h3 id="第六十四条-努力是失败保持原子性"><a class="markdownIt-Anchor" href="#第六十四条-努力是失败保持原子性"></a> 第六十四条 努力是失败保持原子性</h3><h3 id="第六十五条-不要忽略异常"><a class="markdownIt-Anchor" href="#第六十五条-不要忽略异常"></a> 第六十五条 不要忽略异常</h3><h3 id="第六十六条-同步访问共享的可变数据"><a class="markdownIt-Anchor" href="#第六十六条-同步访问共享的可变数据"></a> 第六十六条 同步访问共享的可变数据</h3><h3 id="第六十七条-避免过度同步"><a class="markdownIt-Anchor" href="#第六十七条-避免过度同步"></a> 第六十七条 避免过度同步</h3><h3 id="第六十八条-executor-和-task-优先于线程"><a class="markdownIt-Anchor" href="#第六十八条-executor-和-task-优先于线程"></a> 第六十八条 executor 和 task 优先于线程</h3><h3 id="第六十九条-并发工具优先于-wait-和-notify"><a class="markdownIt-Anchor" href="#第六十九条-并发工具优先于-wait-和-notify"></a> 第六十九条 并发工具优先于 wait 和 notify</h3><h3 id="第七十条-线程安全性的文档化"><a class="markdownIt-Anchor" href="#第七十条-线程安全性的文档化"></a> 第七十条 线程安全性的文档化</h3><h3 id="第七十一条-慎用延迟初始化"><a class="markdownIt-Anchor" href="#第七十一条-慎用延迟初始化"></a> 第七十一条 慎用延迟初始化</h3><h3 id="第七十二条-不要依赖于线程调度器"><a class="markdownIt-Anchor" href="#第七十二条-不要依赖于线程调度器"></a> 第七十二条 不要依赖于线程调度器</h3><h3 id="第七十三条-避免使用线程组"><a class="markdownIt-Anchor" href="#第七十三条-避免使用线程组"></a> 第七十三条 避免使用线程组</h3><h3 id="第七十四条-谨慎地实现-serializble-接口"><a class="markdownIt-Anchor" href="#第七十四条-谨慎地实现-serializble-接口"></a> 第七十四条 谨慎地实现 Serializble 接口</h3><p>实现 Serializable 接口而付出第最大代价是，一旦一个类被发布，就大大降低了“改变这个类的实现” 的灵活性</p><h3 id="第七十五条-考虑使用自定义的序列化形式"><a class="markdownIt-Anchor" href="#第七十五条-考虑使用自定义的序列化形式"></a> 第七十五条 考虑使用自定义的序列化形式</h3><h3 id="第七十六条-保护性的编写-readobject-方法"><a class="markdownIt-Anchor" href="#第七十六条-保护性的编写-readobject-方法"></a> 第七十六条 保护性的编写 readObject 方法</h3><h3 id="第七十七条-对于实例控制枚举类型优先于-readresolve"><a class="markdownIt-Anchor" href="#第七十七条-对于实例控制枚举类型优先于-readresolve"></a> 第七十七条 对于实例控制，枚举类型优先于 readResolve</h3><h3 id="第七十八条-考虑使用序列化代理代替序列化实例"><a class="markdownIt-Anchor" href="#第七十八条-考虑使用序列化代理代替序列化实例"></a> 第七十八条 考虑使用序列化代理代替序列化实例</h3>]]></content>
    
    <summary type="html">
    
      Java
    
    </summary>
    
      <category term="Java" scheme="https://wzes.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wzes.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
