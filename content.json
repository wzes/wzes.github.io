{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Xuantang Cun","url":"https://wzes.github.io","root":"/"},"pages":[],"posts":[{"title":"JavaScript Array 的 1 个属性，35 个方法","slug":"JavaScript Array","date":"2019-09-01T07:30:16.000Z","updated":"2019-09-01T14:31:10.512Z","comments":true,"path":"2019/09/01/JavaScript Array/","link":"","permalink":"https://wzes.github.io/2019/09/01/JavaScript Array/","excerpt":"","text":"前言 这周呢，彻底学习一下 Array 的所有方法。学习地址 MDN，里面还有各个函数实现的源码！数组作为 JavaScript 的一种类型，与 Number，Boolean，Null，Undefined，Object，Symbol 齐驱并驾。了解 Array 的所有方法，能帮助我们最快找到适合自己的函数。 Create an Array 创建一个数组很简单，直接赋值，或者使用 [] 创建空数组 12var fruits = [&apos;Apple&apos;, &apos;Banana&apos;];console.log(fruits.length); // 2 Properties Array.length 123456var clothing = [&apos;shoes&apos;, &apos;shirts&apos;, &apos;socks&apos;, &apos;sweaters&apos;];console.log(clothing.length);// expected output: 4var array = new Array(2) Methods 首先看一下 Array 的三个静态方法 #####1. Array.from() Array.from() 方法从类似数组或可迭代的对象创建一个新的，浅拷贝的 Array 实例，或者从 {length: 3} 对象中创建固定长度的 undefined 数组 Array.from(arrayLike[, mapFn[, thisArg]]) 12345678console.log(Array.from(&apos;foo&apos;));// expected output: Array [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]console.log(Array.from([1, 2, 3], x =&gt; x + x));// expected output: Array [2, 4, 6]console.log(Array.from(&#123;length: 3&#125;));// expected output: Array [undefined, undefined, undefined] 2. Array.isArray() Array.isArray() 方法确定传递的值是否为 Array，由于 typeof Array = ‘object’ ，所以判断是否是一个数组使用 isArray 才可以 Array.isArray(value) 1234Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray(&apos;foobar&apos;); // falseArray.isArray(undefined); // false 3. Array.of() Array.of() 方法从可变数量的参数创建一个新的Array实例，无论参数的数量或类型如何 注意它与构造函数的不同之处 Array.of(element0[, element1[, …[, elementN]]]) 12345Array.of(7); // [7] Array.of(1, 2, 3); // [1, 2, 3]Array(7); // array of 7 empty slotsArray(1, 2, 3); // [1, 2, 3] 接下来看 Array 的对象方法 4. Array.prototype.concat() concat() 方法用于合并两个或多个数组。 此方法不会更改现有数组，而是返回一个新数组 var new_array = old_array.concat([value1[, value2[, …[, valueN]]]]) 12345var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];var array2 = [&apos;d&apos;, &apos;e&apos;, &apos;f&apos;];console.log(array1.concat(array2));// expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 5. Array.prototype.copyWithin() copyWithin() 方法浅析将数组的一部分复制到同一数组中的另一个位置，并返回它而不修改其长度 arr.copyWithin(target[, start[, end]]) 123456789var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];// copy to index 0 the element at index 3console.log(array1.copyWithin(0, 3, 4));// expected output: Array [&quot;d&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]// copy to index 1 all elements from index 3 to the endconsole.log(array1.copyWithin(1, 3));// expected output: Array [&quot;d&quot;, &quot;d&quot;, &quot;e&quot;, &quot;d&quot;, &quot;e&quot;] 6. Array.prototype.entries() entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。 array.entries() 1234567891011121314151617181920var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];var iterator1 = array1.entries();console.log(iterator1.next().value);// expected output: Array [0, &quot;a&quot;]console.log(iterator1.next().value);// expected output: Array [1, &quot;b&quot;]// 使用 for of 遍历var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];var iterator = a.entries();for (let e of iterator) &#123; console.log(e);&#125;// [0, &apos;a&apos;]// [1, &apos;b&apos;]// [2, &apos;c&apos;] 7. Array.prototype.every() every() 方法测试数组中的所有元素是否都通过了由提供的函数实现的测试。 它返回一个布尔值 arr.every(callback(element[, index[, array]])[, thisArg]) 12345678function isBelowThreshold(currentValue) &#123; return currentValue &lt; 40;&#125;var array1 = [1, 30, 39, 29, 10, 13];console.log(array1.every(isBelowThreshold));// expected output: true 8. Array.prototype.fill() fill() 方法使用静态值从开始索引（默认为零）到结束索引（默认数组长度）填充（修改）数组的所有元素。 它返回修改后的数组，原数组会改变～ arr.fill(value[, start[, end]]) 123456789101112 var array1 = [1, 2, 3, 4];// fill with 0 from position 2 until position 4console.log(array1.fill(0, 2, 4));// expected output: [1, 2, 0, 0]// fill with 5 from position 1console.log(array1.fill(5, 1));// expected output: [1, 5, 5, 5]console.log(array1.fill(6));// expected output: [6, 6, 6, 6] 9. Array.prototype.filter() filter() 方法创建一个新数组，其中包含所有传递由提供的函数实现的测试的元素 var newArray = arr.filter(callback(element[, index[, array]])[, thisArg]) 123456var words = [&apos;spray&apos;, &apos;limit&apos;, &apos;elite&apos;, &apos;exuberant&apos;, &apos;destruction&apos;, &apos;present&apos;];const result = words.filter(word =&gt; word.length &gt; 6);console.log(result);// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;] 10. Array.prototype.find() find() 方法返回数组中第一个满足提供的测试函数的元素的值。 否则返回undefined arr.find(callback(element[, index[, array]])[, thisArg]) 12345678var array1 = [5, 12, 8, 130, 44];var found = array1.find(function(element) &#123; return element &gt; 10;&#125;);console.log(found);// expected output: 12 11. Array.prototype.findIndex() findIndex() 方法返回数组中第一个满足提供的测试函数的元素的索引。 否则，它返回-1，表示没有元素通过测试 arr.findIndex(callback(element[, index[, array]])[, thisArg]) 1234567var array1 = [5, 12, 8, 130, 44];function isLargeNumber(element) &#123; return element &gt; 13;&#125;console.log(array1.findIndex(isLargeNumber)); 12. Array.prototype.flat() flat() 方法创建一个新数组，所有子数组元素以递归方式连接到指定的深度。 var newArray = arr.flat([depth]); 123456789101112131415var arr1 = [1, 2, [3, 4]];arr1.flat(); // [1, 2, 3, 4]var arr2 = [1, 2, [3, 4, [5, 6]]];arr2.flat();// [1, 2, 3, 4, [5, 6]]var arr3 = [1, 2, [3, 4, [5, 6]]];arr3.flat(2);// [1, 2, 3, 4, 5, 6]var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];arr4.flat(Infinity);// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 13. Array.prototype.flatMap() flatMap() 方法首先使用映射函数映射每个元素，然后将结果展平为新数组。 它与map（）后跟深度为1的flat（）相同，但flatMap（）通常非常有用，因为将两者合并到一个方法中效率稍高 var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) { // return element for new_array }[, thisArg]) 1234567let arr1 = [&quot;it&apos;s Sunny in&quot;, &quot;&quot;, &quot;California&quot;];arr1.map(x =&gt; x.split(&quot; &quot;));// [[&quot;it&apos;s&quot;,&quot;Sunny&quot;,&quot;in&quot;],[&quot;&quot;],[&quot;California&quot;]]arr1.flatMap(x =&gt; x.split(&quot; &quot;));// [&quot;it&apos;s&quot;,&quot;Sunny&quot;,&quot;in&quot;, &quot;&quot;, &quot;California&quot;] 14. Array.prototype.forEach() forEach() 方法为每个数组元素执行一次提供的函数 arr.forEach(callback(currentValue [, index [, array]])[, thisArg]); 123456789var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];array1.forEach(function(element) &#123; console.log(element);&#125;);// expected output: &quot;a&quot;// expected output: &quot;b&quot;// expected output: &quot;c&quot; 15. Array.prototype.includes() includes() 方法确定数组是否在其条目中包含某个值，并在适当时返回true或false arr.includes(valueToFind[, fromIndex]) 123456789101112var array1 = [1, 2, 3];console.log(array1.includes(2));// expected output: truevar pets = [&apos;cat&apos;, &apos;dog&apos;, &apos;bat&apos;];console.log(pets.includes(&apos;cat&apos;));// expected output: trueconsole.log(pets.includes(&apos;at&apos;));// expected output: false 16. Array.prototype.indexOf() indexOf() 方法返回可在数组中找到给定元素的第一个索引，如果不存在则返回-1 arr.indexOf(searchElement[, fromIndex]) 1234567891011var beasts = [&apos;ant&apos;, &apos;bison&apos;, &apos;camel&apos;, &apos;duck&apos;, &apos;bison&apos;];console.log(beasts.indexOf(&apos;bison&apos;));// expected output: 1// start from index 2console.log(beasts.indexOf(&apos;bison&apos;, 2));// expected output: 4console.log(beasts.indexOf(&apos;giraffe&apos;));// expected output: -1 17. Array.prototype.join() join() 方法通过连接数组（或类数组对象）中的所有元素（用逗号或指定的分隔符字符串分隔）来创建并返回一个新字符串。 如果数组只有一个项目，那么将返回该项目而不使用分隔符 arr.join([separator]) 12345678910ar elements = [&apos;Fire&apos;, &apos;Air&apos;, &apos;Water&apos;];console.log(elements.join());// expected output: &quot;Fire,Air,Water&quot;console.log(elements.join(&apos;&apos;));// expected output: &quot;FireAirWater&quot;console.log(elements.join(&apos;-&apos;));// expected output: &quot;Fire-Air-Water&quot; 18. Array.prototype.keys() keys() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键 123456var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];var iterator = array1.keys(); for (let key of iterator) &#123; console.log(key); // expected output: 0 1 2&#125; 19. Array.prototype.lastIndexOf() lastIndexOf() 方法返回可在数组中找到给定元素的最后一个索引，如果不存在则返回-1。 从fromIndex开始向后搜索数组 arr.lastIndexOf(searchElement[, fromIndex]) 1234567var animals = [&apos;Dodo&apos;, &apos;Tiger&apos;, &apos;Penguin&apos;, &apos;Dodo&apos;];console.log(animals.lastIndexOf(&apos;Dodo&apos;));// expected output: 3console.log(animals.lastIndexOf(&apos;Penguin&apos;, 1));// expected output: -1 20. Array.prototype.map() map() 方法创建一个新数组，其结果是在调用数组中的每个元素上调用提供的函数 var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg]) 1234567var array1 = [1, 4, 9, 16];// pass a function to mapconst map1 = array1.map(x =&gt; x * 2);console.log(map1);// expected output: Array [2, 8, 18, 32] 21. Array.prototype.pop() pop() 方法从数组中删除最后一个元素并返回该元素。 此方法更改数组的长度。 arr.pop() 123456789101112var plants = [&apos;broccoli&apos;, &apos;cauliflower&apos;, &apos;cabbage&apos;, &apos;kale&apos;, &apos;tomato&apos;];console.log(plants.pop());// expected output: &quot;tomato&quot;console.log(plants);// expected output: Array [&quot;broccoli&quot;, &quot;cauliflower&quot;, &quot;cabbage&quot;, &quot;kale&quot;]plants.pop();console.log(plants);// expected output: Array [&quot;broccoli&quot;, &quot;cauliflower&quot;, &quot;cabbage&quot;] 22. Array.prototype.push() push() 方法将一个或多个元素添加到数组的末尾，并返回数组的新长度 arr.push(element1[, …[, elementN]]) 123456789101112var animals = [&apos;pigs&apos;, &apos;goats&apos;, &apos;sheep&apos;];console.log(animals.push(&apos;cows&apos;));// expected output: 4console.log(animals);// expected output: Array [&quot;pigs&quot;, &quot;goats&quot;, &quot;sheep&quot;, &quot;cows&quot;]animals.push(&apos;chickens&apos;);console.log(animals);// expected output: Array [&quot;pigs&quot;, &quot;goats&quot;, &quot;sheep&quot;, &quot;cows&quot;, &quot;chickens&quot;] 23. Array.prototype.reduce() reduce() 方法在数组的每个元素上执行reducer函数（您提供），从而产生单个输出值 arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) 12345678910const array1 = [1, 2, 3, 4];const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;// 1 + 2 + 3 + 4console.log(array1.reduce(reducer));// expected output: 10// 5 + 1 + 2 + 3 + 4console.log(array1.reduce(reducer, 5));// expected output: 15 24. Array.prototype.reduceRight() reduceRight() 方法对累加器和数组的每个值（从右到左）应用函数以将其减少为单个值 arr.reduceRight(callback(accumulator, currentValue[, index[, array]])[, initialValue]) 123456const array1 = [[0, 1], [2, 3], [4, 5]].reduceRight( (accumulator, currentValue) =&gt; accumulator.concat(currentValue));console.log(array1);// expected output: Array [4, 5, 2, 3, 0, 1] 25. Array.prototype.reverse() reverse() 方法将数组反转到位。 第一个数组元素成为最后一个，最后一个数组元素成为第一个 a.reverse() 123456789101112var array1 = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;];console.log(&apos;array1: &apos;, array1);// expected output: Array [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]var reversed = array1.reverse(); console.log(&apos;reversed: &apos;, reversed);// expected output: Array [&apos;three&apos;, &apos;two&apos;, &apos;one&apos;]/* Careful: reverse is destructive. It also changesthe original array */ console.log(&apos;array1: &apos;, array1);// expected output: Array [&apos;three&apos;, &apos;two&apos;, &apos;one&apos;] 26. Array.prototype.shift() shift() 方法从数组中删除第一个元素并返回已删除的元素。 此方法更改数组的长度 arr.shift() 123456789var array1 = [1, 2, 3];var firstElement = array1.shift();console.log(array1);// expected output: Array [2, 3]console.log(firstElement);// expected output: 1 27. Array.prototype.slice() slice() 方法将数组的一部分的浅表副本返回到从头到尾选择的新数组对象（不包括结尾），其中begin和end表示该数组中项的索引。 原始数组不会被修改 arr.slice([begin[, end]]) 12345678910var animals = [&apos;ant&apos;, &apos;bison&apos;, &apos;camel&apos;, &apos;duck&apos;, &apos;elephant&apos;];console.log(animals.slice(2));// expected output: Array [&quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]console.log(animals.slice(2, 4));// expected output: Array [&quot;camel&quot;, &quot;duck&quot;]console.log(animals.slice(1, 5));// expected output: Array [&quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;] 28. # Array.prototype.some() some() 方法测试数组中是否至少有一个元素通过了由提供的函数实现的测试。 它返回一个布尔值 arr.some(callback(element[, index[, array]])[, thisArg]) 123456789var array = [1, 2, 3, 4, 5];var even = function(element) &#123; // checks whether an element is even return element % 2 === 0;&#125;;console.log(array.some(even));// expected output: true 29. Array.prototype.sort() sort() 方法对数组中的元素进行排序并返回已排序的数组。 默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的。 由于取决于实现，因此无法保证排序的时间和空间复杂性。 arr.sort([compareFunction]) 123456789var months = [&apos;March&apos;, &apos;Jan&apos;, &apos;Feb&apos;, &apos;Dec&apos;];months.sort();console.log(months);// expected output: Array [&quot;Dec&quot;, &quot;Feb&quot;, &quot;Jan&quot;, &quot;March&quot;]var array1 = [1, 30, 4, 21, 100000];array1.sort();console.log(array1);// expected output: Array [1, 100000, 21, 30, 4] 30. Array.prototype.splice() splice() 方法通过删除或替换现有元素和/或在适当位置添加新元素来更改数组的内容 var arrDeletedItems = array.splice(start[, deleteCount[, item1[, item2[, …]]]]) 12345678910var months = [&apos;Jan&apos;, &apos;March&apos;, &apos;April&apos;, &apos;June&apos;];months.splice(1, 0, &apos;Feb&apos;);// inserts at index 1console.log(months);// expected output: Array [&apos;Jan&apos;, &apos;Feb&apos;, &apos;March&apos;, &apos;April&apos;, &apos;June&apos;]months.splice(4, 1, &apos;May&apos;);// replaces 1 element at index 4console.log(months);// expected output: Array [&apos;Jan&apos;, &apos;Feb&apos;, &apos;March&apos;, &apos;April&apos;, &apos;May&apos;] 31. Array.prototype.unshift() unshift() 方法将一个或多个元素添加到数组的开头并返回数组的新长度 arr.unshift(element1[, …[, elementN]]) 1234567var array1 = [1, 2, 3];console.log(array1.unshift(4, 5));// expected output: 5console.log(array1);// expected output: Array [4, 5, 1, 2, 3] 32. Array.prototype.values() values() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的值 arr.values() 123456const array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];const iterator = array1.values();for (const value of iterator) &#123; console.log(value); // expected output: &quot;a&quot; &quot;b&quot; &quot;c&quot;&#125; 33. Array.prototype.toLocaleString() toLocaleString() 方法返回表示数组元素的字符串。 使用toLocaleString方法将元素转换为字符串，并且这些字符串由特定于语言环境的字符串（例如逗号“，”）分隔 arr.toLocaleString([locales[, options]]); 123456var array1 = [1, &apos;a&apos;, new Date(&apos;21 Dec 1997 14:12:00 UTC&apos;)];var localeString = array1.toLocaleString(&apos;en&apos;, &#123;timeZone: &quot;UTC&quot;&#125;);console.log(localeString);// expected output: &quot;1,a,12/21/1997, 2:12:00 PM&quot;,// This assumes &quot;en&quot; locale and UTC timezone - your results may vary 34. Array.prototype.toString() toString() 方法返回表示指定数组及其元素的字符串 arr.toString() 1234var array1 = [1, 2, &apos;a&apos;, &apos;1a&apos;];console.log(array1.toString());// expected output: &quot;1,2,a,1a&quot; 35. Array.prototype@@iterator @@iterator 属性的初始值与values（）属性的初始值是相同的函数对象。 arrSymbol.iterator 12345678var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];var eArr = arr[Symbol.iterator]();// your browser must support for..of loop// and let-scoped variables in for loops// const and var could also be usedfor (let letter of eArr) &#123; console.log(letter);&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript Array","slug":"JavaScript-Array","permalink":"https://wzes.github.io/tags/JavaScript-Array/"}]},{"title":"Redux v0.2.1 源码学习","slug":"Redux V0.2.1","date":"2019-08-25T11:30:16.000Z","updated":"2019-09-01T14:29:39.685Z","comments":true,"path":"2019/08/25/Redux V0.2.1/","link":"","permalink":"https://wzes.github.io/2019/08/25/Redux V0.2.1/","excerpt":"","text":"前言 这周突然想学习一下状态管理的写法。看看业界是怎么实现的，之前使用过 redux，那就先从 redux 下手吧，但是，一上来就看最新版本的代码，不太适合新手学习，一方面最新版本已经发展n多年了，功能已经非常完善（代码多难懂），另一方面直接看最新的不了解这个工具是怎么设计出来的。于是就打算学习最早的发布版本 v0.2.1 先来说下我认识的一般的状态管理的基本路子： 全局只存在 唯一state，而前端不直接改变 state，而是通过 action 去改变 state HelloWorld 一个计数器的栗子，目录结构如下： 123456789101112counter├── App.js├── Counter.js├── actions│ ├── CounterActions.js│ └── index.js├── constants│ └── ActionTypes.js├── dispatcher.js└── stores ├── CounterStore.js └── index.js actions 函数，返回一个带 type 的对象，或者返回一个函数 123456789101112131415161718192021222324import &#123; INCREMENT_COUNTER, DECREMENT_COUNTER&#125; from &apos;../constants/ActionTypes&apos;;export function increment() &#123; return &#123; type: INCREMENT_COUNTER &#125;;&#125;export function incrementAsync() &#123; return dispatch =&gt; &#123; setTimeout(() =&gt; &#123; dispatch(increment()); &#125;, 1000); &#125;;&#125;export function decrement() &#123; return &#123; type: DECREMENT_COUNTER &#125;;&#125; store 返回一个函数，参数 state 和 action，当 state 为空时返回初始值，表示初始化。根据 action 的 type 值，进行相应的做法，返回一个新的 state。 1234567891011121314151617181920212223242526272829import &#123; INCREMENT_COUNTER, DECREMENT_COUNTER&#125; from &apos;../constants/ActionTypes&apos;;const initialState = &#123; counter: 0 &#125;;function incremenent(&#123; counter &#125;) &#123; return &#123; counter: counter + 1 &#125;;&#125;function decremenent(&#123; counter &#125;) &#123; return &#123; counter: counter - 1 &#125;;&#125;export default function CounterStore(state, action) &#123; if (!state) &#123; return initialState; &#125; switch (action.type) &#123; case INCREMENT_COUNTER: return incremenent(state, action); case DECREMENT_COUNTER: return decremenent(state, action); default: return state; &#125;&#125; 入口 App.js 你会发现 @provides(dispatcher) 这个奇怪的东西，在 React 里面还经常出现，装饰器。 12345678910111213import React, &#123; Component &#125; from &apos;react&apos;;import Counter from &apos;./Counter&apos;;import &#123; provides &#125; from &apos;redux&apos;;import dispatcher from &apos;./dispatcher&apos;;@provides(dispatcher)export default class App extends Component &#123; render() &#123; return ( &lt;Counter /&gt; ); &#125;&#125; Couter.js，同样，也出现 performs（方法），observes（观察者）等关键字。使用 state 直接使用 this.props 解构赋值即可。 12345678910111213141516171819import React from &apos;react&apos;;import &#123; performs, observes &#125; from &apos;redux&apos;;@performs(&apos;increment&apos;, &apos;decrement&apos;)@observes(&apos;CounterStore&apos;)export default class Counter &#123; render() &#123; const &#123; increment, decrement &#125; = this.props; return ( &lt;p&gt; Clicked: &#123;this.props.counter&#125; times &#123;&apos; &apos;&#125; &lt;button onClick=&#123;() =&gt; increment()&#125;&gt;+&lt;/button&gt; &#123;&apos; &apos;&#125; &lt;button onClick=&#123;() =&gt; decrement()&#125;&gt;-&lt;/button&gt; &lt;/p&gt; ); &#125;&#125; 这些关键字是早起 Redux 状态管理的关键，现在的版本应该已经不使用这种方式了。 解析 dispatcher 通过 provides 将 dispatcher 注入到 App 中，其中，dispatcher 是通过 createDispatcher 创建，并调用了 dispatcher.receive(stores, actions) 进行绑定。 123456789101112131415import * as stores from &apos;./stores/index&apos;;import * as actions from &apos;./actions/index&apos;;import &#123; createDispatcher &#125; from &apos;redux&apos;;const dispatcher = module.hot &amp;&amp; module.hot.data &amp;&amp; module.hot.data.dispatcher || createDispatcher();dispatcher.receive(stores, actions);module.hot.dispose(data =&gt; &#123; data.dispatcher = dispatcher;&#125;);export default dispatcher; receive 方法，actionCreator 将 action 进行封装， 123456789101112131415161718// Provide a way to receive new stores and actions function receive(nextStores, nextActionCreators) &#123; stores = nextStores; actionCreators = mapValues(nextActionCreators, wrapActionCreator); // Merge the observers observers = mapValues(stores, (store, key) =&gt; observers[key] || [] ); // Dispatch to initialize stores if (currentTransaction) &#123; updateState(committedState); currentTransaction.forEach(dispatch); &#125; else &#123; dispatch(BOOTSTRAP_STORE); &#125; &#125; action 进行转化返回一个 dispatchAction 函数，如果 action 为函数，则先执行函数，把 dispatchInTransaction 作为参数传入，这样可以在 action 内部使用该函数了，否则使用 dispatchInTransaction 函数调用。 12345678910111213// Bind action creator to the dispatcher function wrapActionCreator(actionCreator) &#123; return function dispatchAction(...args) &#123; const action = actionCreator(...args); if (typeof action === &apos;function&apos;) &#123; // Async action creator action(dispatchInTransaction); &#125; else &#123; // Sync action creator dispatchInTransaction(action); &#125; &#125;; &#125; dispatchInTransaction ，执行 dispatch ，计算 nextState，执行 updateState 更新。 1234567891011121314151617 // Dispatch in the context of current transaction function dispatchInTransaction(action) &#123; if (currentTransaction) &#123; currentTransaction.push(action); &#125; dispatch(action); &#125;// Reassign the current state on each dispatch function dispatch(action) &#123; if (typeof action.type !== &apos;string&apos;) &#123; throw new Error(&apos;Action type must be a string.&apos;); &#125; const nextState = computeNextState(currentState, action); updateState(nextState); &#125; 获取 store，也就是 CounterStore，把参数传入，获取新的 state 123456// To compute the next state, combine the next states of every storefunction computeNextState(state, action) &#123; return mapValues(stores, (store, key) =&gt; store(state[key], action) );&#125; updateState 实现，计算变化的 changedKeys，执行 emitChange 进行更新。 123456789101112// Update state and emit change if neededfunction updateState(nextState) &#123; // Swap the state const previousState = currentState; currentState = nextState; // Notify the observers const changedKeys = Object.keys(currentState).filter(key =&gt; currentState[key] !== previousState[key] ); emitChange(changedKeys);&#125; emitChange，获取需要通知的 observers，调用通知函数。 12345678910111213141516171819// Notify observers about the changed stores function emitChange(changedKeys) &#123; if (!changedKeys.length) &#123; return; &#125; // Gather the affected observers const notifyObservers = []; changedKeys.forEach(key =&gt; &#123; observers[key].forEach(o =&gt; &#123; if (notifyObservers.indexOf(o) === -1) &#123; notifyObservers.push(o); &#125; &#125;); &#125;); // Emit change notifyObservers.forEach(o =&gt; o()); &#125; 这里可能有点疑问，obersevers 是什么，从哪来？往下看～ observes.js 将 组件进行装饰，构造函数中有一个 this.unobserve = this.context.observeStores(storeKeys, this.handleChange); context 就是 dispatcher， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;import pick from &apos;lodash/object/pick&apos;;import identity from &apos;lodash/utility/identity&apos;;const contextTypes = &#123; observeStores: PropTypes.func.isRequired&#125;;export default function connect(...storeKeys) &#123; let mapState = identity; // Last argument may be a custom mapState function const lastIndex = storeKeys.length - 1; if (typeof storeKeys[lastIndex] === &apos;function&apos;) &#123; [mapState] = storeKeys.splice(lastIndex, 1); &#125; return function (DecoratedComponent) &#123; const wrappedDisplayName = DecoratedComponent.displayName || DecoratedComponent.name || &apos;Component&apos;; return class extends Component &#123; static displayName = `ReduxObserves($&#123;wrappedDisplayName&#125;)`; static contextTypes = contextTypes; constructor(props, context) &#123; super(props, context); this.handleChange = this.handleChange.bind(this); this.unobserve = this.context.observeStores(storeKeys, this.handleChange); &#125; .... componentWillUnmount() &#123; this.unobserve(); &#125; render() &#123; return ( &lt;DecoratedComponent &#123;...this.props&#125; &#123;...this.state&#125; /&gt; ); &#125; &#125;; &#125;;&#125; dispatcher observeStores 方法，将需要监听的组件传入，以及 onChange 函数，作为回调使用。最后返回一个函数，移除监听，这个也太妙了吧。 1234567891011121314151617181920212223// Provide subscription and unsubscription function observeStores(observedKeys, onChange) &#123; // Emit the state update function handleChange() &#123; onChange(currentState); &#125; // Synchronously emit the initial value handleChange(); // Register the observer for each relevant key observedKeys.forEach(key =&gt; observers[key].push(handleChange) ); // Let it unregister when the time comes return () =&gt; &#123; observedKeys.forEach(key =&gt; &#123; const index = observers[key].indexOf(handleChange); observers[key].splice(index, 1); &#125;); &#125;; &#125; 当计算好 nextState 后，就会调用 observe 的 onChange 方法， onChange 方法也就是 装饰器里面的方法。最后调用自身的 updateState，使用 setState 进行组件更新。而这些 state 作为 props 传入了我们自己的组件，也就可以通过 this.props 拿到。完美～～～ 1234567891011121314151617181920212223handleChange(stateFromStores) &#123; this.currentStateFromStores = pick(stateFromStores, storeKeys); this.updateState(stateFromStores, this.props);&#125;componentWillReceiveProps(nextProps) &#123; this.updateState(this.currentStateFromStores, nextProps);&#125;updateState(stateFromStores, props) &#123; if (storeKeys.length === 1) &#123; // Just give it the particular store state for convenience stateFromStores = stateFromStores[storeKeys[0]]; &#125; const state = mapState(stateFromStores, props); if (this.state) &#123; this.setState(state); &#125; else &#123; this.state = state; &#125;&#125; performs 组件 action 绑定到组件，可以通过 this.props ，通过 this.context.getActions() 拿到 actions 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;import pick from &apos;lodash/object/pick&apos;;import identity from &apos;lodash/utility/identity&apos;;const contextTypes = &#123; getActions: PropTypes.func.isRequired&#125;;export default function performs(...actionKeys) &#123; let mapActions = identity; // Last argument may be a custom mapState function const lastIndex = actionKeys.length - 1; if (typeof actionKeys[lastIndex] === &apos;function&apos;) &#123; [mapActions] = actionKeys.splice(lastIndex, 1); &#125; return function (DecoratedComponent) &#123; const wrappedDisplayName = DecoratedComponent.displayName || DecoratedComponent.name || &apos;Component&apos;; return class extends Component &#123; static displayName = `ReduxPerforms($&#123;wrappedDisplayName&#125;)`; static contextTypes = contextTypes; constructor(props, context) &#123; super(props, context); this.updateActions(props); &#125; componentWillReceiveProps(nextProps) &#123; this.updateActions(nextProps); &#125; updateActions(props) &#123; this.actions = mapActions( pick(this.context.getActions(), actionKeys), props ); &#125; render() &#123; return ( &lt;DecoratedComponent &#123;...this.props&#125; &#123;...this.actions&#125; /&gt; ); &#125; &#125;; &#125;;&#125; 到这里就差不多了～ 额外收获 Lodash pick 12345var object = &#123; &apos;user&apos;: &apos;fred&apos;, &apos;age&apos;: 40 &#125;;_.pick(object, &apos;user&apos;);// =&gt; &#123; &apos;user&apos;: &apos;fred&apos; &#125;_.pick(object, _.isString);// =&gt; &#123; &apos;user&apos;: &apos;fred&apos; &#125; identity 123function identity(value) &#123; return value;&#125; mapValues 1234_.mapValues(&#123; &apos;a&apos;: 1, &apos;b&apos;: 2 &#125;, function(n) &#123; return n * 3;&#125;);// =&gt; &#123; &apos;a&apos;: 3, &apos;b&apos;: 6 &#125; 最后 麻雀虽小，却能看透精髓～","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://wzes.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://wzes.github.io/tags/Redux/"}]},{"title":"KoaJs 源码解析","slug":"KoaJs","date":"2019-08-18T10:56:00.000Z","updated":"2019-09-01T14:30:02.699Z","comments":true,"path":"2019/08/18/KoaJs/","link":"","permalink":"https://wzes.github.io/2019/08/18/KoaJs/","excerpt":"","text":"前言 又是一周过去了，常规学习不能断！但是选择什么主题呢？一时间不知道选什么好，于是又想起简单的 koajs 非常愉快的就选择他了 https://koajs.com/，了解一下？ 他是个什么东西呢？ Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。 hello world 首先新建一个 node 项目，其实很简单，只需要一个 package.json 文件， 12345678910111213141516&#123; &quot;name&quot;: &quot;koa-hello&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;node src/index.js&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;koa&quot;: &quot;^2.7.0&quot; &#125;&#125; 然后执行 1npm i koa 代码 index.js 文件，新建一个 koa 实例，使用 app.use 写一个 async 方法，设置 ctx.body 的值就可以了。最后使用 app.listen 启动。 12345678const Koa = require(&apos;koa&apos;);const app = new Koa();app.use(async ctx =&gt; &#123; ctx.body = &apos;Hello World&apos;;&#125;);app.listen(3000); 这样的话，一个 web 服务器就搭建好了，访问 http://localhost:3000/ 就会得到 hello world 返回结果了。你可以尝试更改字段从而得到不同的返回结果。 源码解析 koa 的源码只有四个文件，不包含其他引用的话 12345678910 .├── History.md├── LICENSE├── Readme.md├── lib│ ├── application.js│ ├── context.js│ ├── request.js│ └── response.js└── package.json 主入口可以在 package.json 的 main 中得到，是 application.js，暂时先知道 middleware 是中间接，通常一个请求过来就会依次执行中间件的方法。 构造函数 12345678910111213141516171819202122module.exports = class Application extends Emitter &#123; /** * Initialize a new `Application`. * * @api public */ constructor() &#123; super(); this.proxy = false; this.middleware = []; this.subdomainOffset = 2; this.env = process.env.NODE_ENV || &apos;development&apos;; this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); if (util.inspect.custom) &#123; this[util.inspect.custom] = this.inspect; &#125; &#125;&#125; app.use 其实就是添加一个中间件，我们通常使用 async 的函数，generator 被抛弃了！ 123456789101112use(fn) &#123; if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;middleware must be a function!&apos;); if (isGeneratorFunction(fn)) &#123; deprecate(&apos;Support for generators will be removed in v3. &apos; + &apos;See the documentation for examples of how to convert old middleware &apos; + &apos;https://github.com/koajs/koa/blob/master/docs/migration.md&apos;); fn = convert(fn); &#125; debug(&apos;use %s&apos;, fn._name || fn.name || &apos;-&apos;); this.middleware.push(fn); return this;&#125; app.listen 创建一个服务器，监听 3000 端口，http.createServer 是 node 的服务器。 12345listen(...args) &#123; debug(&apos;listen&apos;); const server = http.createServer(this.callback()); return server.listen(...args);&#125; callback 是提供一个函数，所有请求都会走到这个函数里面进行处理。每次请求过来都会调用这个函数，所以，我们可以看到，每次请求都会创建一个 ctx 的对象。 compose 的作用就是将所有的中间件整合成一个函数，使用 next 函数继续调用下一个函数。 123456789101112callback() &#123; const fn = compose(this.middleware); if (!this.listenerCount(&apos;error&apos;)) this.on(&apos;error&apos;, this.onerror); const handleRequest = (req, res) =&gt; &#123; const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn); &#125;; return handleRequest;&#125; 初始化 ctx 对象，这里 this.request 将会把原生的 request 参数进行解析，方便我们进行相关参数获取。 1234567891011121314151617181920/** * Initialize a new context. * * @api private */createContext(req, res) &#123; const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.state = &#123;&#125;; return context;&#125; 比如我们之后就可以使用 ** ctx.query.key ** 来获取 http://localhost:3000?key=value，为什么可以使用 ctx.query 又可以获取参数呢，这个要靠 Object.create 的本事了，它相当于创造了一个对象，继承了原来的对象，而 this.request 有 query 的参数，而最为重要的是 this.context = Object.create(context); context 委托（使用了 Delegator）了这些 request 的相关属性和方法。【第一次体会到 js 委托，以前知识听说不知道是啥】 12345678910/** * Request delegation. */delegate(proto, &apos;request&apos;) .access(&apos;method&apos;) .access(&apos;query&apos;) .access(&apos;path&apos;) .access(&apos;url&apos;) ....... // 省略 handleRequest 请求处理，fnMiddleware 就是所有的中间件， 12345678handleRequest(ctx, fnMiddleware) &#123; const res = ctx.res; res.statusCode = 404; const onerror = err =&gt; ctx.onerror(err); const handleResponse = () =&gt; respond(ctx); onFinished(res, onerror); return fnMiddleware(ctx).then(handleResponse).catch(onerror);&#125; 调用完中间件以后，就执行 handleResponse 将数据返回，返回数据也就是将 ctx.body 拿出来，使用 response.end 返回数据，返回时，会对数据进行处理，在最后面可以体会到～ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Response helper. */function respond(ctx) &#123; // allow bypassing koa if (false === ctx.respond) return; if (!ctx.writable) return; const res = ctx.res; let body = ctx.body; const code = ctx.status; // ignore body if (statuses.empty[code]) &#123; // strip headers ctx.body = null; return res.end(); &#125; if (&apos;HEAD&apos; == ctx.method) &#123; if (!res.headersSent &amp;&amp; isJSON(body)) &#123; ctx.length = Buffer.byteLength(JSON.stringify(body)); &#125; return res.end(); &#125; // status body if (null == body) &#123; if (ctx.req.httpVersionMajor &gt;= 2) &#123; body = String(code); &#125; else &#123; body = ctx.message || String(code); &#125; if (!res.headersSent) &#123; ctx.type = &apos;text&apos;; ctx.length = Buffer.byteLength(body); &#125; return res.end(body); &#125; // responses if (Buffer.isBuffer(body)) return res.end(body); if (&apos;string&apos; == typeof body) return res.end(body); if (body instanceof Stream) return body.pipe(res); // body: json body = JSON.stringify(body); if (!res.headersSent) &#123; ctx.length = Buffer.byteLength(body); &#125; res.end(body);&#125; 到这里，基本的请求已经清楚了～～ End 再来看一眼最简单的 http server 代码，对比一下，比 koa 代码的 hello world 相比并没有多复杂 123456var http = require(&apos;http&apos;);http.createServer(function (req, res) &#123; res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); res.write(&apos;Hello World!&apos;); res.end();&#125;).listen(8080); 但是，获取参数，使用路由等等插件，koa 生态做了很多，非常方便，快来体验吧！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"},{"name":"Node","slug":"Node","permalink":"https://wzes.github.io/tags/Node/"},{"name":"Koa","slug":"Koa","permalink":"https://wzes.github.io/tags/Koa/"}]},{"title":"Babel-Loader 自定义入门","slug":"Babel Loader","date":"2019-08-04T05:42:00.000Z","updated":"2019-09-01T14:30:22.474Z","comments":true,"path":"2019/08/04/Babel Loader/","link":"","permalink":"https://wzes.github.io/2019/08/04/Babel Loader/","excerpt":"","text":"前言 突然觉得 babel-loader https://github.com/babel/babel-loader 很好玩，比较贴近AST，然而编译原理一直是噩梦，没学懂，好在这东西不需要什么编译原理的知识。但还是涉及到语法解析等操作，所以拿过来学一学还是挺好的。 什么是 Babel Babel 是一个工具链，主要用于将 ECMAScript 2015+ 代码转换为当前和旧版浏览器或环境中的向后兼容版本的 JavaScript。 以下是 Babel 可以为您做的主要事情： 转换语法 目标环境中缺少Polyfill功能（通过@ babel / polyfill）源代码转换（codemods） 更多 1234567// Babel Input: ES2015 arrow function[1, 2, 3].map((n) =&gt; n + 1);// Babel Output: ES5 equivalent[1, 2, 3].map(function(n) &#123; return n + 1;&#125;); 代码转化就涉及到了语法解析，这便是我们的重点 自定义 首先新建一个项目 webpack 项目 babel-demo 目录结构如下 1234567891011.├── README.md├── babel-plugin-transform-class│ └── index.js├── dist│ └── bundle.js├── package-lock.json├── package.json├── src│ └── index.js└── webpack.config.js 新建 package.json 并使用 npm install 安装所需插件 1npm install -D babel-loader @babel/core @babel/preset-env webpack package.json 123456789101112&#123; &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot; &#125;, &quot;dependencies&quot;: &#123;&#125;, &quot;devDependencies&quot;: &#123; &quot;@babel/core&quot;: &quot;^7.5.5&quot;, &quot;@babel/preset-env&quot;: &quot;^7.5.5&quot;, &quot;babel-loader&quot;: &quot;^8.0.6&quot;, &quot;webpack&quot;: &quot;^4.39.1&quot; &#125;&#125; 新建 webpack 文件 1234567891011121314151617181920212223var path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./src/index.js&apos;, mode: &apos;development&apos;, output: &#123; path: path.join(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, loader: &apos;babel-loader&apos;, options: &#123; plugins: [ &quot;transform-class&quot; ] &#125; &#125; ] &#125;&#125; module 里面的 rule 便是配置我们自定义的 babel 插件，transform-class 是插件名。 手写插件 下面是一个简单的插件 babel-plugin-transform-class/index.js 1234567891011// A plugin is just a functionmodule.exports = function (&#123; types: t &#125;) &#123; return &#123; visitor: &#123; Identifier(path) &#123; let name = path.node.name; // reverse the name: JavaScript -&gt; tpircSavaJ path.node.name = name.split(&apos;&apos;).reverse().join(&apos;&apos;); &#125; &#125; &#125;;&#125; 将 babel-plugin-transform-class 文件夹移动到 node-modules 目录下即可。当运行 webpack 的时候，便会运行这个插件，这个插件会把 node 的 name 做反转。 我们的 demo 1234function babel() &#123; let javascript = &apos;hello babel&apos;; console.log(javascript);&#125; 打包后 1eval(&quot;function lebab() &#123;\\n let tpircsavaj = &apos;hello babel&apos;;\\n elosnoc.gol(tpircsavaj);\\n&#125;\\n\\n//# sourceURL=webpack:///./src/index.js?&quot;); 我们看到变量名都反转了。 我们还可以实现更多·····更多属性，方法在这里 https://babeljs.io/docs/en/next/babel-types.html 参考 AST https://astexplorer.net/","categories":[{"name":"JavaScript Node","slug":"JavaScript-Node","permalink":"https://wzes.github.io/categories/JavaScript-Node/"}],"tags":[{"name":"JavaScript Babel","slug":"JavaScript-Babel","permalink":"https://wzes.github.io/tags/JavaScript-Babel/"}]},{"title":"React Lazyload 源码解析","slug":"React Lazyload","date":"2019-07-28T03:59:00.000Z","updated":"2019-09-01T14:30:38.029Z","comments":true,"path":"2019/07/28/React Lazyload/","link":"","permalink":"https://wzes.github.io/2019/07/28/React Lazyload/","excerpt":"","text":"前言 早在多年前，lazyload 已经出现了，懒加载在前端里边同样具有十分重要的意义。react-lazyload 的作用是当组件未出现在屏幕内时，不去挂载该组件，而是使用 placeholder 去渲染，让滚动使内容出现后，组件会被挂载。就是这么简单！例如，一个复杂的组件（非首屏内容），使用了懒加载后，渲染首屏就会节省很多资源，从而减少首屏渲染时间。 Demo 源码地址 react-lazyload Demo地址 Demo HelloWorld 将需要懒加载的组件使用 LazyLoad 包裹即可，最好使用 height 进行站位，否则该组件位置将会为 0 1234567&lt;LazyLoad height=&#123;200&#125;&gt; &lt;img src=&quot;tiger.jpg&quot; /&gt; /* Lazy loading images is supported out of box, no extra config needed, set `height` for better experience */ &lt;/LazyLoad&gt; 解析 从源码角度分析～ 一览核心 本小节摘取了最核心的代码，目的在于对 LazyLoad 组件有个最核心的认识，它的核心就是监听滚动事件，检查组件是否在屏幕内，如果在的话就显示，不在的话就不显示～ 12345678910111213class LazyLoad extends Component &#123; componentDidMount() &#123; on(scrollport, &apos;scroll&apos;, finalLazyLoadHandler, passiveEvent); &#125; render() &#123; return this.visible ? this.props.children : this.props.placeholder ? this.props.placeholder : &lt;div style=&#123;&#123; height: this.props.height &#125;&#125; className=&quot;lazyload-placeholder&quot; ref=&#123;this.setRef&#125; /&gt;; &#125;&#125; LazyLoad 的属性，透过属性，我们可以知道它大概有些什么功能。 12345678910111213141516171819202122232425LazyLoad.propTypes = &#123; once: PropTypes.bool, height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]), offset: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]), overflow: PropTypes.bool, // 不是 window 滚动，而使用了 overflow: scroll resize: PropTypes.bool, // 是否监听 resize scroll: PropTypes.bool, // 是否监听滚动 children: PropTypes.node, throttle: PropTypes.oneOfType([PropTypes.number, PropTypes.bool]), debounce: PropTypes.oneOfType([PropTypes.number, PropTypes.bool]), placeholder: PropTypes.node, scrollContainer: PropTypes.oneOfType([PropTypes.string, PropTypes.object]), unmountIfInvisible: PropTypes.bool, preventLoading: PropTypes.bool&#125;;// 默认值LazyLoad.defaultProps = &#123; once: false, offset: 0, overflow: false, resize: false, scroll: true, unmountIfInvisible: false, preventLoading: false,&#125;; 完整的 componentDidMount，scrollport 是滚动试图，默认是 window，如果 props 传入了 scrollContainer，那么滚动试图将是自定义的。needResetFinalLazyLoadHandler 是控制是否重置滚动监听。debounce 和 throttle 分别是用来控制滚动事件的监听触发频率，默认都是 undefine，needResetFinalLazyLoadHandler 初始值为 false。finalLazyLoadHandler 初始值也为 undefine，而 overflow 也为 false，scroll 为 true，listeners 是需要懒加载的组件集合，初始大小肯定为0，componentDidMount 最后才会进行添加，因此最终会走到 **on(scrollport, ‘scroll’, finalLazyLoadHandler, passiveEvent)，事件只需要一次绑定即可。 ** 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061componentDidMount() &#123; // It&apos;s unlikely to change delay type on the fly, this is mainly // designed for tests let scrollport = window; const &#123; scrollContainer, &#125; = this.props; if (scrollContainer) &#123; if (isString(scrollContainer)) &#123; scrollport = scrollport.document.querySelector(scrollContainer); &#125; &#125; const needResetFinalLazyLoadHandler = (this.props.debounce !== undefined &amp;&amp; delayType === &apos;throttle&apos;) || (delayType === &apos;debounce&apos; &amp;&amp; this.props.debounce === undefined); if (needResetFinalLazyLoadHandler) &#123; off(scrollport, &apos;scroll&apos;, finalLazyLoadHandler, passiveEvent); off(window, &apos;resize&apos;, finalLazyLoadHandler, passiveEvent); finalLazyLoadHandler = null; &#125; if (!finalLazyLoadHandler) &#123; if (this.props.debounce !== undefined) &#123; finalLazyLoadHandler = debounce(lazyLoadHandler, typeof this.props.debounce === &apos;number&apos; ? this.props.debounce : 300); delayType = &apos;debounce&apos;; &#125; else if (this.props.throttle !== undefined) &#123; finalLazyLoadHandler = throttle(lazyLoadHandler, typeof this.props.throttle === &apos;number&apos; ? this.props.throttle : 300); delayType = &apos;throttle&apos;; &#125; else &#123; finalLazyLoadHandler = lazyLoadHandler; &#125; &#125; if (this.props.overflow) &#123; const parent = scrollParent(this.ref); if (parent &amp;&amp; typeof parent.getAttribute === &apos;function&apos;) &#123; const listenerCount = 1 + (+parent.getAttribute(LISTEN_FLAG)); if (listenerCount === 1) &#123; parent.addEventListener(&apos;scroll&apos;, finalLazyLoadHandler, passiveEvent); &#125; parent.setAttribute(LISTEN_FLAG, listenerCount); &#125; &#125; else if (listeners.length === 0 || needResetFinalLazyLoadHandler) &#123; const &#123; scroll, resize &#125; = this.props; if (scroll) &#123; on(scrollport, &apos;scroll&apos;, finalLazyLoadHandler, passiveEvent); &#125; if (resize) &#123; on(window, &apos;resize&apos;, finalLazyLoadHandler, passiveEvent); &#125; &#125; listeners.push(this); checkVisible(this); &#125; 通常 finalLazyLoadHandler 就是 lazyLoadHandler，不会对滚动事件进行 debounce 或 throttle，我们一般为了性能，会使用 throttle 进行处理。函数会对每一个懒加载组件进行 checkVisible，之后会移除 once component 12345678const lazyLoadHandler = () =&gt; &#123; for (let i = 0; i &lt; listeners.length; ++i) &#123; const listener = listeners[i]; checkVisible(listener); &#125; // Remove `once` component in listeners purgePending();&#125;; checkVisible，检查组件是否出现在 viewport 中，如果出现了就吧 visible 设置为 true，当然如果设置了 unmountIfInvisible = true，那么不可见时组件将被移除，如果之前已经渲染了，需要避免再次渲染。 12345678910111213141516171819202122232425262728293031const checkVisible = function checkVisible(component) &#123; const node = component.ref; if (!(node instanceof HTMLElement)) &#123; return; &#125; const parent = scrollParent(node); const isOverflow = component.props.overflow &amp;&amp; parent !== node.ownerDocument &amp;&amp; parent !== document &amp;&amp; parent !== document.documentElement; const visible = isOverflow ? checkOverflowVisible(component, parent) : checkNormalVisible(component); if (visible) &#123; // Avoid extra render if previously is visible if (!component.visible &amp;&amp; !component.preventLoading) &#123; if (component.props.once) &#123; pending.push(component); &#125; component.visible = true; component.forceUpdate(); &#125; &#125; else if (!(component.props.once &amp;&amp; component.visible)) &#123; component.visible = false; if (component.props.unmountIfInvisible) &#123; component.forceUpdate(); &#125; &#125;&#125;; checkNormalVisible 检查组件是否 visible 的函数，判断组件的getgetBoundingClientRect 的 top - offset（相对于屏幕顶部的距离） 与 window 的 height 之间的关系 12345678910111213141516171819202122232425const checkNormalVisible = function checkNormalVisible(component) &#123; const node = component.ref; // If this element is hidden by css rules somehow, it&apos;s definitely invisible if (!(node.offsetWidth || node.offsetHeight || node.getClientRects().length)) return false; let top; let elementHeight; try &#123; // 这个语法 node 也是支持的 (&#123; top, height: elementHeight &#125; = node.getBoundingClientRect()); &#125; catch (e) &#123; (&#123; top, height: elementHeight &#125; = defaultBoundingClientRect); &#125; const windowInnerHeight = window.innerHeight || document.documentElement.clientHeight; const offsets = Array.isArray(component.props.offset) ? component.props.offset : [component.props.offset, component.props.offset]; // Be compatible with previous API return (top - offsets[0] &lt;= windowInnerHeight) &amp;&amp; (top + elementHeight + offsets[1] &gt;= 0);&#125;; 12(top - offsets[0] &lt;= windowInnerHeight) &amp;&amp; (top + elementHeight + offsets[1] &gt;= 0); 一张图解析！ 到这里解析的差不多了 欣赏一下 throttle 12345678910111213141516171819202122export default function throttle(fn, threshhold, scope) &#123; threshhold || (threshhold = 250); var last, deferTimer; return function () &#123; var context = scope || this; var now = +new Date, args = arguments; if (last &amp;&amp; now &lt; last + threshhold) &#123; // hold on to it clearTimeout(deferTimer); deferTimer = setTimeout(function () &#123; last = now; fn.apply(context, args); &#125;, threshhold); &#125; else &#123; last = now; fn.apply(context, args); &#125; &#125;;&#125; 再欣赏一下 debounce 12345678910111213141516171819202122232425262728293031323334353637383940414243export default function debounce(func, wait, immediate) &#123; let timeout; let args; let context; let timestamp; let result; const later = function later() &#123; const last = +(new Date()) - timestamp; if (last &lt; wait &amp;&amp; last &gt;= 0) &#123; timeout = setTimeout(later, wait - last); &#125; else &#123; timeout = null; if (!immediate) &#123; result = func.apply(context, args); if (!timeout) &#123; context = null; args = null; &#125; &#125; &#125; &#125;; return function debounced() &#123; context = this; args = arguments; timestamp = +(new Date()); const callNow = immediate &amp;&amp; !timeout; if (!timeout) &#123; timeout = setTimeout(later, wait); &#125; if (callNow) &#123; result = func.apply(context, args); context = null; args = null; &#125; return result; &#125;;&#125; 获取 scrollParent 12345678910111213141516171819202122232425262728293031323334export default (node) =&gt; &#123; if (!(node instanceof HTMLElement)) &#123; return document.documentElement; &#125; const excludeStaticParent = node.style.position === &apos;absolute&apos;; const overflowRegex = /(scroll|auto)/; let parent = node; while (parent) &#123; if (!parent.parentNode) &#123; return node.ownerDocument || document.documentElement; &#125; const style = window.getComputedStyle(parent); const position = style.position; const overflow = style.overflow; const overflowX = style[&apos;overflow-x&apos;]; const overflowY = style[&apos;overflow-y&apos;]; if (position === &apos;static&apos; &amp;&amp; excludeStaticParent) &#123; parent = parent.parentNode; continue; &#125; if (overflowRegex.test(overflow) &amp;&amp; overflowRegex.test(overflowX) &amp;&amp; overflowRegex.test(overflowY)) &#123; return parent; &#125; parent = parent.parentNode; &#125; return node.ownerDocument || node.documentElement || document.documentElement;&#125;; 总结思考 我们可以看到，Lazyload 并不能实现类似客户端的图片懒加载，Lazyload 加载图片也会出现白屏时间，解决办法是使用 image.onload，当图片资源请求关闭后，再显示图片，就可以做到类似客户端的效果。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://wzes.github.io/tags/React/"},{"name":"Lazyload","slug":"Lazyload","permalink":"https://wzes.github.io/tags/Lazyload/"}]},{"title":"Swipe-js-ios 源码解析","slug":"Swipe-js-ios","date":"2019-07-20T06:38:00.000Z","updated":"2019-09-01T14:30:49.232Z","comments":true,"path":"2019/07/20/Swipe-js-ios/","link":"","permalink":"https://wzes.github.io/2019/07/20/Swipe-js-ios/","excerpt":"","text":"前言 Swipe，常用来做轮播图，需要翻页的场景，最经典的开源库 swipe-js-iso ，不过更推荐使用 React 组件 react-swipe，它封装了 swipe-js-ios 组件，而 swipe-js-ios 组件则封装了 Swipe HelloWord 如果单独使用的化，创建一个 swipe，dom 必须是三层结构，最里面一层是放 slide 的。 1234567&lt;div id=&quot;slider&quot; class=&quot;swipe&quot;&gt; &lt;div class=&quot;swipe-wrap&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS 子元素 float: left; container 的宽度为自定义，swipe-wrap 的宽度为子页面数 * container 的 width，每一个 slide 的宽度为 container 的 width 1234567891011121314.swipe &#123; overflow: hidden; visibility: hidden; position: relative;&#125;.swipe-wrap &#123; overflow: hidden; position: relative;&#125;.swipe-wrap &gt; div &#123; float: left; width: 100%; position: relative;&#125; load 以后，创建 Swipe 即可 1const mySwipe = Swipe(document.getElementById(&apos;slider&apos;)); 源码解析 swipe-js-ios 使用立即函数导出了一个 Swipe 模块，使用 typeof module !== ‘undefined’ &amp;&amp; module.exports 兼容 Node 和 浏览器环境，如果是 Node 环境，将会有 module.export 那么则使用 module.export 导出，否则使用 root.Swipe 全局变量导出 123456789101112(function(root, factory) &#123; if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123; module.exports = factory(); &#125; else &#123; root.Swipe = factory(); &#125;&#125;)(this, function() &#123; &apos;use strict&apos;; return function Swipe(container, options) &#123; .... &#125;;&#125;); 检查浏览器的环境，算是一种规范吧，风别检查触摸事件和 transition 的支持 ⚠️在浏览器，手机模式下，触摸事件是存在的，而普通浏览器下是不存在的，所以该组件不能在普通浏览器中使用。 123456789101112131415161718var browser = &#123; addEventListener: !!window.addEventListener, touch: &apos;ontouchstart&apos; in window || (window.DocumentTouch &amp;&amp; document instanceof window.DocumentTouch), transitions: (function(temp) &#123; var props = [ &apos;transitionProperty&apos;, &apos;WebkitTransition&apos;, &apos;MozTransition&apos;, &apos;OTransition&apos;, &apos;msTransition&apos; ]; for (var i in props) if (temp.style[props[i]] !== undefined) return true; return false; &#125;)(document.createElement(&apos;swipe&apos;)) &#125;; 创建时会调用 setup，继而添加事件，touch 触摸事件、transitionend 移动事件，resize 重新布局事件 1234567891011121314151617181920212223242526272829// trigger setupsetup();// start auto slideshow if applicableif (delay) begin();// add event listenersif (browser.addEventListener) &#123; // set touchstart event on element if (browser.touch) &#123; element.addEventListener(&apos;touchstart&apos;, events, false); element.addEventListener(&apos;touchforcechange&apos;, function() &#123;&#125;, false); &#125; if (browser.transitions) &#123; element.addEventListener(&apos;webkitTransitionEnd&apos;, events, false); element.addEventListener(&apos;msTransitionEnd&apos;, events, false); element.addEventListener(&apos;oTransitionEnd&apos;, events, false); element.addEventListener(&apos;otransitionend&apos;, events, false); element.addEventListener(&apos;transitionend&apos;, events, false); &#125; // set resize event on window window.addEventListener(&apos;resize&apos;, events, false);&#125; else &#123; window.onresize = function() &#123; setup(); &#125;; // to play nice with old IE&#125; setup 函数的实现，slides 就是容器里面的页面，continuous 是否自动轮播，slidePos 记录了每一个页面的位置，width 是每一个页面的宽度，此处需要剪掉widthOfSiblingSlidePreview 的大小，可以预览前后页。element 的宽度是 **页数 * width ** 1234567891011121314151617181920function setup() &#123; // cache slides slides = element.children; length = slides.length; // set continuous to false if only one slide continuous = slides.length &lt; 2 ? false : options.continuous; // create an array to store current positions of each slide slidePos = new Array(slides.length); // determine width of each slide width = Math.round( container.getBoundingClientRect().width || container.offsetWidth ) - widthOfSiblingSlidePreview * 2; element.style.width = slides.length * width + &apos;px&apos;; &#125; 初始化时，需要更新页面的位置 123456789101112var pos = slides.length;while (pos--) &#123; var slide = slides[pos]; slide.style.width = width + &apos;px&apos;; slide.setAttribute(&apos;data-index&apos;, pos); if (browser.transitions) &#123; slide.style.left = pos * -width + widthOfSiblingSlidePreview + &apos;px&apos;; move(pos, index &gt; pos ? -width : index &lt; pos ? width : 0, 0); &#125;&#125; 如果支持轮播的化，需要把左边和右边也填充，然后把 container.style.visibility 设置为 visible，如果不支持 transition 的话，只需要设置 element.style.left 即可 12345678910// reposition elements before and after index if (continuous &amp;&amp; browser.transitions) &#123; move(circle(index - 1), -width, 0); move(circle(index + 1), width, 0); &#125; if (!browser.transitions) element.style.left = index * -width + widthOfSiblingSlidePreview + &apos;px&apos;; container.style.visibility = &apos;visible&apos;; move 的实现，translate，更新 slidePos 的位置 1234function move(index, dist, speed) &#123; translate(index, dist, speed); slidePos[index] = dist;&#125; translate 三个参数，index：需要移动的页，dist：移动的位置，speed：移动速度，移动只需要给 页面设置 style 的 transform 就OK了，之后就会以动画移动过去了 12345678910111213function translate(index, dist, speed) &#123; var slide = slides[index]; var style = slide &amp;&amp; slide.style; if (!style) return; style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration = speed + &apos;ms&apos;; style.webkitTransform = &apos;translate(&apos; + dist + &apos;px,0)&apos; + &apos;translateZ(0)&apos;; style.msTransform = style.MozTransform = style.OTransform = &apos;translateX(&apos; + dist + &apos;px)&apos;; &#125; prev 对外提供接口，手动翻页使用 1234function prev() &#123; if (continuous) slide(index - 1); else if (index) slide(index - 1);&#125; slide 移动函数，指定移动的页 index 和速度 12345678910111213141516171819202122232425262728293031323334353637383940414243function slide(to, slideSpeed) &#123; // do nothing if already on requested slide if (index == to) return; if (browser.transitions) &#123; var direction = Math.abs(index - to) / (index - to); // 1: backward, -1: forward // get the actual position of the slide if (continuous) &#123; var natural_direction = direction; direction = -slidePos[circle(to)] / width; // if going forward but to &lt; index, use to = slides.length + to // if going backward but to &gt; index, use to = -slides.length + to if (direction !== natural_direction) to = -direction * slides.length + to; &#125; var diff = Math.abs(index - to) - 1; // move all the slides between index and to in the right direction while (diff--) move( circle((to &gt; index ? to : index) - diff - 1), width * direction, 0 ); to = circle(to); move(index, width * direction, slideSpeed || speed); move(to, 0, slideSpeed || speed); if (continuous) move(circle(to - direction), -(width * direction), 0); // we need to get the next in place &#125; else &#123; to = circle(to); animate(index * -width, to * -width, slideSpeed || speed); //no fallback for a circular continuous if the browser does not accept transitions &#125; index = to; offloadFn(options.callback &amp;&amp; options.callback(index, slides[index])); &#125; 如果浏览器不支持 transition，那么则使用 setInterval 实现渐进移动， animation 是对整个页面进行移动，而 move 是移动每一个子页面 123456789101112131415161718192021222324252627282930function animate(from, to, speed) &#123; // if not an animation, just reposition if (!speed) &#123; element.style.left = to + &apos;px&apos;; return; &#125; var start = +new Date(); var timer = setInterval(function() &#123; var timeElap = +new Date() - start; if (timeElap &gt; speed) &#123; element.style.left = to + &apos;px&apos;; if (delay) begin(); options.transitionEnd &amp;&amp; options.transitionEnd.call(event, index, slides[index]); clearInterval(timer); return; &#125; element.style.left = (to - from) * (Math.floor((timeElap / speed) * 100) / 100) + from + &apos;px&apos;; &#125;, 4); &#125; 接下来研究一下触摸事件的处理，首先是 start，start 事件会记录起始触摸位置以及时间，并且添加 touchmove 和 touchend 事件，如果没有 start 事件，触摸事件是不存在的， end 的时候会被移除。 1234567891011121314151617181920212223start: function(event) &#123; var touches = event.touches[0]; // measure start values start = &#123; // get initial touch coords x: touches.pageX, y: touches.pageY, // store time to determine touch duration time: +new Date() &#125;; // used for testing first move event isScrolling = undefined; // reset delta and end measurements delta = &#123;&#125;; // attach touchmove and touchend listeners element.addEventListener(&apos;touchmove&apos;, this, false); element.addEventListener(&apos;touchend&apos;, this, false); &#125;, move 事件，delta 将手指移动距离记下，最后视同 translate 移动 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162move: function(event) &#123; // ensure swiping with one touch and not pinching if (event.touches.length &gt; 1 || (event.scale &amp;&amp; event.scale !== 1)) return; if (options.disableScroll) return; var touches = event.touches[0]; // measure change in x and y delta = &#123; x: touches.pageX - start.x, y: touches.pageY - start.y &#125;; // determine if scrolling test has run - one time test if (typeof isScrolling == &apos;undefined&apos;) &#123; isScrolling = !!( isScrolling || Math.abs(delta.x) &lt; Math.abs(delta.y) ); &#125; // if user is not trying to scroll vertically if (!isScrolling) &#123; // prevent native scrolling event.preventDefault(); // stop slideshow stop(); // increase resistance if first or last slide if (continuous) &#123; // we don&apos;t add resistance at the end translate( circle(index - 1), delta.x + slidePos[circle(index - 1)], 0 ); translate(index, delta.x + slidePos[index], 0); translate( circle(index + 1), delta.x + slidePos[circle(index + 1)], 0 ); &#125; else &#123; delta.x = delta.x / ((!index &amp;&amp; delta.x &gt; 0) || // if first slide and sliding left (index == slides.length - 1 &amp;&amp; // or if last slide and sliding right delta.x &lt; 0) // and if sliding at all ? Math.abs(delta.x) / width + 1 // determine resistance level : 1); // no resistance if false // translate 1:1 translate(index - 1, delta.x + slidePos[index - 1], 0); translate(index, delta.x + slidePos[index], 0); translate(index + 1, delta.x + slidePos[index + 1], 0); &#125; options.swiping &amp;&amp; options.swiping(-delta.x / width); &#125; &#125;, end 事件，主要判断本次触摸滑动是否有效，并持续接下来的操作，最后将会 remove 掉监听事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778end: function(event) &#123; // measure duration var duration = +new Date() - start.time; // determine if slide attempt triggers next/prev slide var isValidSlide = (Number(duration) &lt; 250 &amp;&amp; // if slide duration is less than 250ms Math.abs(delta.x) &gt; 20) || // and if slide amt is greater than 20px Math.abs(delta.x) &gt; width / 2; // or if slide amt is greater than half the width // determine if slide attempt is past start and end var isPastBounds = (!index &amp;&amp; delta.x &gt; 0) || // if first slide and slide amt is greater than 0 (index == slides.length - 1 &amp;&amp; delta.x &lt; 0); // or if last slide and slide amt is less than 0 if (continuous) isPastBounds = false; // determine direction of swipe (true:right, false:left) var direction = delta.x &lt; 0; // if not scrolling vertically if (!isScrolling) &#123; if (isValidSlide &amp;&amp; !isPastBounds) &#123; if (direction) &#123; if (continuous) &#123; // we need to get the next in this direction in place move(circle(index - 1), -width, 0); move(circle(index + 2), width, 0); &#125; else &#123; move(index - 1, -width, 0); &#125; move(index, slidePos[index] - width, speed); move( circle(index + 1), slidePos[circle(index + 1)] - width, speed ); index = circle(index + 1); &#125; else &#123; if (continuous) &#123; // we need to get the next in this direction in place move(circle(index + 1), width, 0); move(circle(index - 2), -width, 0); &#125; else &#123; move(index + 1, width, 0); &#125; move(index, slidePos[index] + width, speed); move( circle(index - 1), slidePos[circle(index - 1)] + width, speed ); index = circle(index - 1); &#125; options.callback &amp;&amp; options.callback(index, slides[index]); &#125; else &#123; if (continuous) &#123; move(circle(index - 1), -width, speed); move(index, 0, speed); move(circle(index + 1), width, speed); &#125; else &#123; move(index - 1, -width, speed); move(index, 0, speed); move(index + 1, width, speed); &#125; &#125; &#125; // kill touchmove and touchend event listeners until touchstart called again element.removeEventListener(&apos;touchmove&apos;, events, false); element.removeEventListener(&apos;touchend&apos;, events, false); element.removeEventListener(&apos;touchforcechange&apos;, function() &#123;&#125;, false); &#125;, 总结 总的来说，swipe-js-ios 充分利用了 transition，来实现移动动画，搞清楚触摸事件就比较容易能写出来可滑动的 swipe","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://wzes.github.io/tags/HTML/"},{"name":"DOM","slug":"DOM","permalink":"https://wzes.github.io/tags/DOM/"}]},{"title":"Webpack 源码解析","slug":"Webpack","date":"2019-07-13T11:59:16.000Z","updated":"2019-09-01T14:31:00.690Z","comments":true,"path":"2019/07/13/Webpack/","link":"","permalink":"https://wzes.github.io/2019/07/13/Webpack/","excerpt":"","text":"前言 算是一个h5开发了，虽然没写过什么完整的前端页面，但接触前端也有段时间了，对于一个合格的前端开发者而言，搞懂 webpack 打包原理还是比较重要的。 hello world 使用 commonjs 规范，lib.js 只导出一个方法 1234// lib.jsmodule.exports = function () &#123; return &quot;hello webpack!&quot;&#125; index.js 使用 require 引入，代码很简单，输入方法返回值 123456// index.jsconst func = require(&quot;./lib&quot;)const result = func()// print helloconsole.log(result) 目录结构 12345678910.├── dist│ └── main.js├── package-lock.json├── package.json├── node_modules├── src│ ├── index.js│ └── lib.js└── webpack.config.js webpack.config.js 为了方便看生成的源码，我们将 mode 设置为 development， 1234567891011var path = require(&apos;path&apos;);module.exports = &#123; context: path.resolve(__dirname, &apos;./&apos;), mode: &apos;development&apos;, entry: &apos;./src/index.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;main.js&apos; &#125;&#125;; package.json 123456789101112131415161718&#123; &quot;name&quot;: &quot;webpack-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.35.2&quot;, &quot;webpack-cli&quot;: &quot;^3.3.5&quot; &#125;, &quot;dependencies&quot;: &#123;&#125;&#125; 编译运行 12npm run buildnode dist/main.js 输出 12$ node dist/main.js hello webpack! 起源 浏览器，node 并不支持模块化，我们在项目中使用的 require、export 将会经过 webpack 后，这些 js 就会被打包整合成一个 js 文件，只需要运行 js 文件，整个模块将会运行起来了。 main.js 解析 整个文件只有 111 行，这是未经过压缩的版本，生产环境下的输出文件比这还要精简，只需要在 webpack.config.js 中将 mode 值等于 production 即可改变打包环境 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******//******/ // The require function/******/ function __webpack_require__(moduleId) &#123;/******//******/ // Check if module is in cache/******/ if(installedModules[moduleId]) &#123;/******/ return installedModules[moduleId].exports;/******/ &#125;/******/ // Create a new module (and put it into the cache)/******/ var module = installedModules[moduleId] = &#123;/******/ i: moduleId,/******/ l: false,/******/ exports: &#123;&#125;/******/ &#125;;/******//******/ // Execute the module function/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******//******/ // Flag the module as loaded/******/ module.l = true;/******//******/ // Return the exports of the module/******/ return module.exports;/******/ &#125;/******//******//******/ // expose the modules object (__webpack_modules__)/******/ __webpack_require__.m = modules;/******//******/ // expose the module cache/******/ __webpack_require__.c = installedModules;/******//******/ // define getter function for harmony exports/******/ __webpack_require__.d = function(exports, name, getter) &#123;/******/ if(!__webpack_require__.o(exports, name)) &#123;/******/ Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;);/******/ &#125;/******/ &#125;;/******//******/ // define __esModule on exports/******/ __webpack_require__.r = function(exports) &#123;/******/ if(typeof Symbol !== &apos;undefined&apos; &amp;&amp; Symbol.toStringTag) &#123;/******/ Object.defineProperty(exports, Symbol.toStringTag, &#123; value: &apos;Module&apos; &#125;);/******/ &#125;/******/ Object.defineProperty(exports, &apos;__esModule&apos;, &#123; value: true &#125;);/******/ &#125;;/******//******/ // create a fake namespace object/******/ // mode &amp; 1: value is a module id, require it/******/ // mode &amp; 2: merge all properties of value into the ns/******/ // mode &amp; 4: return value when already ns object/******/ // mode &amp; 8|1: behave like require/******/ __webpack_require__.t = function(value, mode) &#123;/******/ if(mode &amp; 1) value = __webpack_require__(value);/******/ if(mode &amp; 8) return value;/******/ if((mode &amp; 4) &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; value &amp;&amp; value.__esModule) return value;/******/ var ns = Object.create(null);/******/ __webpack_require__.r(ns);/******/ Object.defineProperty(ns, &apos;default&apos;, &#123; enumerable: true, value: value &#125;);/******/ if(mode &amp; 2 &amp;&amp; typeof value != &apos;string&apos;) for(var key in value) __webpack_require__.d(ns, key, function(key) &#123; return value[key]; &#125;.bind(null, key));/******/ return ns;/******/ &#125;;/******//******/ // getDefaultExport function for compatibility with non-harmony modules/******/ __webpack_require__.n = function(module) &#123;/******/ var getter = module &amp;&amp; module.__esModule ?/******/ function getDefault() &#123; return module[&apos;default&apos;]; &#125; :/******/ function getModuleExports() &#123; return module; &#125;;/******/ __webpack_require__.d(getter, &apos;a&apos;, getter);/******/ return getter;/******/ &#125;;/******//******/ // Object.prototype.hasOwnProperty.call/******/ __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;;/******//******/ // __webpack_public_path__/******/ __webpack_require__.p = &quot;&quot;;/******//******//******/ // Load entry module and return exports/******/ return __webpack_require__(__webpack_require__.s = &quot;./src/index.js&quot;);/******/ &#125;)/************************************************************************//******/ (&#123;/***/ &quot;./src/index.js&quot;:/*!**********************!*\\ !*** ./src/index.js ***! \\**********************//*! no static exports found *//***/ (function(module, exports, __webpack_require__) &#123;eval(&quot;// index.js\\nconst func = __webpack_require__(/*! ./lib */ \\&quot;./src/lib.js\\&quot;)\\n\\nconst result = func()\\n// print hello\\nconsole.log(result)\\n\\n//# sourceURL=webpack:///./src/index.js?&quot;);/***/ &#125;),/***/ &quot;./src/lib.js&quot;:/*!********************!*\\ !*** ./src/lib.js ***! \\********************//*! no static exports found *//***/ (function(module, exports) &#123;eval(&quot;module.exports = function () &#123;\\n return \\&quot;hello webpack!\\&quot;\\n&#125;\\n\\n//# sourceURL=webpack:///./src/lib.js?&quot;);/***/ &#125;)/******/ &#125;); 我们先将此文件的主要部分拿出来看 123456789101112131415161718192021222324252627282930313233/******/(function (modules) &#123; var installedModules = &#123;&#125; function __webpack_require__ (moduleId) &#123; if (installedModules[moduleId]) &#123; return installedModules[moduleId].exports &#125; var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125; &#125; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__) module.l = true return module.exports &#125; return __webpack_require__(__webpack_require__.s = &apos;./src/index.js&apos;)&#125;)(&#123; &apos;./src/index.js&apos;: (function (module, exports, __webpack_require__) &#123; eval( &apos;// index.js\\nconst func = __webpack_require__(/*! ./lib */ &quot;./src/lib.js&quot;)\\n\\nconst result = func()\\n// print hello\\nconsole.log(result)\\n\\n//# sourceURL=webpack:///./src/index.js?&apos;) &#125;), &apos;./src/lib.js&apos;: (function (module, exports) &#123; eval( &apos;module.exports = function () &#123;\\n return &quot;hello webpack!&quot;\\n&#125;\\n\\n//# sourceURL=webpack:///./src/lib.js?&apos;) &#125;)&#125;) 这是一个立即执行函数，首先申明了 installedModules 对象，这是已安装的模块集合，之后定义了一个函数 webpack_require ，此函数用来获取模块的引用，最后 return 了此函数，参数为入口，moduleId = ‘./src/index.js’ modules 即为 123456789101112&#123; &apos;./src/index.js&apos;: (function (module, exports, __webpack_require__) &#123; eval( &apos;// index.js\\nconst func = __webpack_require__(/*! ./lib */ &quot;./src/lib.js&quot;)\\n\\nconst result = func()\\n// print hello\\nconsole.log(result)\\n\\n//# sourceURL=webpack:///./src/index.js?&apos;) &#125;), &apos;./src/lib.js&apos;: (function (module, exports) &#123; eval( &apos;module.exports = function () &#123;\\n return &quot;hello webpack!&quot;\\n&#125;\\n\\n//# sourceURL=webpack:///./src/lib.js?&apos;) &#125;)&#125; 1modules[moduleId].call(module.exports, module, module.exports, __webpack_require__) module 即模块，modules[moduleId] 即为 1234(function (module, exports, __webpack_require__) &#123; eval( &apos;// index.js\\nconst func = __webpack_require__(/*! ./lib */ &quot;./src/lib.js&quot;)\\n\\nconst result = func()\\n// print hello\\nconsole.log(result)\\n\\n//# sourceURL=webpack:///./src/index.js?&apos;) &#125;) module.exports 为 this 上下文环境，该函数执行中，第一行即调用 1const func = __webpack_require__(&quot;./src/lib.js&quot;) webpack_require(&quot;./src/lib.js&quot;) 即调用了此函数 1234(function (module, exports) &#123; eval( &apos;module.exports = function () &#123;\\n return &quot;hello webpack!&quot;\\n&#125;\\n\\n//# sourceURL=webpack:///./src/lib.js?&apos;) &#125;) 最后返回 module.exports 即 lib 里面的导出函数。再往后执行便是 123const result = func()// print helloconsole.log(result) 此刻基本已经将关系理顺了，此后如果在调用模块，则世界从 installedModules 中直接返回。 总结 此文只是分析了简单的模块引用，需要仔细分析才能融会贯通。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"},{"name":"Webpack","slug":"Webpack","permalink":"https://wzes.github.io/tags/Webpack/"}]}]}