{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Xuantang Cun","url":"https://wzes.github.io","root":"/"},"pages":[],"posts":[{"title":"NextJS 入门指南","slug":"JavaScript/NextJS","date":"2019-11-09T10:30:16.000Z","updated":"2019-11-10T07:50:48.873Z","comments":true,"path":"2019/11/09/JavaScript/NextJS/","link":"","permalink":"https://wzes.github.io/2019/11/09/JavaScript/NextJS/","excerpt":"","text":"前言 最近在研究SSR服务端渲染，NextJS 算是比较经典的框架了，所以了解了解其用法对SSR或许能加深理解。如果能了解其实现原理，那就更好了。 服务端渲染 简单理解就是：你访问网页的时候，会一次性把完整的HTML返回给你。区别于 React，Vue 项目，HTML 文档只是一个壳子，需要运行 js 才能得到首屏的 Dom。 简介 Next.js 是一个轻量级的 React 服务端渲染应用框架。 Get Started 初始化项目，安装 next 1npm install --save next react react-dom 将下面脚本添加到 package.json 中: 1234567&#123; &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;next&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start&quot; &#125;&#125; 新建 ./pages/index.js 到你的项目中: 1export default () =&gt; &lt;div&gt;Welcome to next.js!&lt;/div&gt; 运行 npm run dev 命令并打开 http://localhost:3000。 如果你想使用其他端口，可运行 npm run dev -- -p &lt;设置端口号&gt;. 如何使用服务端渲染？ 默认支持服务端渲染，获取网络请求写在 getInitialProps 内部，就可以在 render 中获取数据，直接渲染。 12345678910111213141516import React from &apos;react&apos;export default class extends React.Component &#123; static async getInitialProps(&#123; req &#125;) &#123; const userAgent = req ? req.headers[&apos;user-agent&apos;] : navigator.userAgent return &#123; userAgent &#125; &#125; render() &#123; return ( &lt;div&gt; Hello World &#123;this.props.userAgent&#125; &lt;/div&gt; ) &#125;&#125; 原理 应用入口 使用了 node command line，能让我们仅仅写了 page 的代码，就能让整个应用跑起来。以至于我们都找不到入口。nextjs 真的是很厉害～封装的很好 可以看到，当我们使用 yarn start 的时候，应用执行了 next-start 123456789const commands: &#123; [command: string]: () =&gt; Promise&lt;cliCommand&gt; &#125; = &#123; build: async () =&gt; await import(&apos;../cli/next-build&apos;).then(i =&gt; i.nextBuild), start: async () =&gt; await import(&apos;../cli/next-start&apos;).then(i =&gt; i.nextStart), export: async () =&gt; await import(&apos;../cli/next-export&apos;).then(i =&gt; i.nextExport), dev: async () =&gt; await import(&apos;../cli/next-dev&apos;).then(i =&gt; i.nextDev), telemetry: async () =&gt; await import(&apos;../cli/next-telemetry&apos;).then(i =&gt; i.nextTelemetry),&#125; next-start 开启了一个服务 12345678910111213startServer(&#123; dir &#125;, port, args[&apos;--hostname&apos;]) .then(async app =&gt; &#123; // tslint:disable-next-line console.log( `&gt; Ready on http://$&#123;args[&apos;--hostname&apos;] || &apos;localhost&apos;&#125;:$&#123;port&#125;` ) await app.prepare() &#125;) .catch(err =&gt; &#123; // tslint:disable-next-line console.error(err) process.exit(1) &#125;) startServer 的实现，获取 next 实例，然后使用 http 创建服务，主要的请求逻辑的代码都在 next 的 getRequestHandler 里面 1234567891011121314151617export default async function start( serverOptions: any, port?: number, hostname?: string) &#123; const app = next(serverOptions) const srv = http.createServer(app.getRequestHandler()) await new Promise((resolve, reject) =&gt; &#123; // This code catches EADDRINUSE error if the port is already in use srv.on(&apos;error&apos;, reject) srv.on(&apos;listening&apos;, () =&gt; resolve()) srv.listen(port, hostname) &#125;) // It&apos;s up to caller to run `app.prepare()`, so it can notify that the server // is listening before starting any intensive operations. return app&#125; handleRequest 处理请求 123456789101112private handleRequest( req: IncomingMessage, res: ServerResponse, parsedUrl?: UrlWithParsedQuery): Promise&lt;void&gt; &#123; res.statusCode = 200 return this.run(req, res, parsedUrl).catch(err =&gt; &#123; this.logError(err) res.statusCode = 500 res.end(&apos;Internal Server Error&apos;) &#125;)&#125; run 获取 route 实例并进行处理 12345678910111213141516171819202122protected async run( req: IncomingMessage, res: ServerResponse, parsedUrl: UrlWithParsedQuery) &#123; this.handleCompression(req, res) try &#123; const fn = this.router.match(req, res, parsedUrl) if (fn) &#123; await fn() return &#125; &#125; catch (err) &#123; if (err.code === &apos;DECODE_FAILED&apos;) &#123; res.statusCode = 400 return this.renderError(null, req, res, &apos;/_error&apos;, &#123;&#125;) &#125; throw err &#125; await this.render404(req, res, parsedUrl)&#125; router 是在项目初始化的时候进行创建的，其中一个就是根据，默认都会有很多路由处理器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071protected generateRoutes(): Route[] &#123; const publicRoutes = fs.existsSync(this.publicDir) ? this.generatePublicRoutes() : [] const staticFilesRoute = fs.existsSync(join(this.dir, &apos;static&apos;)) ? [ &#123; match: route(&apos;/static/:path*&apos;), fn: async (req, res, params, parsedUrl) =&gt; &#123; const p = join(this.dir, &apos;static&apos;, ...(params.path || [])) await this.serveStatic(req, res, p, parsedUrl) &#125;, &#125; as Route, ] : [] const routes: Route[] = [ &#123; match: route(&apos;/_next/static/:path*&apos;), fn: async (req, res, params, parsedUrl) =&gt; &#123; await this.serveStatic(req, res, p, parsedUrl) &#125;, &#125;, &#123; match: route(&apos;/_next/data/:path*&apos;), fn: async (req, res, params, _parsedUrl) =&gt; &#123; await this.render( req, res, pathname, &#123; _nextSprData: &apos;1&apos; &#125;, parsedUrl ) &#125;, &#125;, &#123; match: route(&apos;/_next/:path*&apos;), fn: async (req, res, _params, parsedUrl) =&gt; &#123; await this.render404(req, res, parsedUrl) &#125;, &#125;, ...publicRoutes, ...staticFilesRoute, &#123; match: route(&apos;/api/:path*&apos;), fn: async (req, res, params, parsedUrl) =&gt; &#123; const &#123; pathname &#125; = parsedUrl await this.handleApiRequest( req as NextApiRequest, res as NextApiResponse, pathname! ) &#125;, &#125;, ] if (this.nextConfig.useFileSystemPublicRoutes) &#123; this.dynamicRoutes = this.getDynamicRoutes() routes.push(&#123; match: route(&apos;/:path*&apos;), fn: async (req, res, _params, parsedUrl) =&gt; &#123; const &#123; pathname, query &#125; = parsedUrl if (!pathname) &#123; throw new Error(&apos;pathname is undefined&apos;) &#125; await this.render(req, res, pathname, query, parsedUrl) &#125;, &#125;) &#125; return routes&#125; 默认页面路由都是走到最后，也就是执行 render，获取渲染的 html 123456789101112131415161718192021222324252627282930public async render( req: IncomingMessage, res: ServerResponse, pathname: string, query: ParsedUrlQuery = &#123;&#125;, parsedUrl?: UrlWithParsedQuery): Promise&lt;void&gt; &#123; const url: any = req.url if (isInternalUrl(url)) &#123; return this.handleRequest(req, res, parsedUrl) &#125; if (isBlockedPage(pathname)) &#123; return this.render404(req, res, parsedUrl) &#125; const html = await this.renderToHTML(req, res, pathname, query, &#123; dataOnly: (this.renderOpts.ampBindInitData &amp;&amp; Boolean(query.dataOnly)) || (req.headers &amp;&amp; (req.headers.accept || &apos;&apos;).indexOf(&apos;application/amp.bind+json&apos;) !== -1), &#125;) // Request was ended by the user if (html === null) &#123; return &#125; return this.sendHTML(req, res, html)&#125; 其中 renderToHTML 实现了具体逻辑，通过 sendHTML 返回页面 HTML renderToHTML 实现，首先通过 findPageComponents 获取路由具体页面 Compenent，然后使用renderToHTMLWithComponents 进行 React 转换为 HTML 1234567891011121314public renderToHTML( ... ): Promise&lt;string | null&gt; &#123; return this.findPageComponents(pathname, query) .then( result =&gt; &#123; return this.renderToHTMLWithComponents( .... result, &#123; ...this.renderOpts, amphtml, hasAmp, dataOnly &#125; ) &#125;, ) &#125; renderToHTML，在 renderToHTMLWithComponents 内部执行 省略了很多代码，为了了解主要逻辑。 首先会执行 loadGetInitialProps，也就是业务代码中的 props 获取，运行在服务端。 然后使用 Document 的 getInitialProps 创建 Document，并把 component 赋值，获取最终的 html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144export async function renderToHTML( req: IncomingMessage, res: ServerResponse, pathname: string, query: ParsedUrlQuery, renderOpts: RenderOpts): Promise&lt;string | null&gt; &#123; .... let props: any const AppContainer = (&#123; children &#125;: any) =&gt; ( &lt;RouterContext.Provider value=&#123;router&#125;&gt; &lt;DataManagerContext.Provider value=&#123;dataManager&#125;&gt; &lt;AmpStateContext.Provider value=&#123;ampState&#125;&gt; &lt;LoadableContext.Provider value=&#123;moduleName =&gt; reactLoadableModules.push(moduleName)&#125; &gt; &#123;children&#125; &lt;/LoadableContext.Provider&gt; &lt;/AmpStateContext.Provider&gt; &lt;/DataManagerContext.Provider&gt; &lt;/RouterContext.Provider&gt; ) try &#123; props = await loadGetInitialProps(App, &#123; AppTree: ctx.AppTree, Component, router, ctx, &#125;) ...... &#125; .... renderPage = ( options: ComponentsEnhancer = &#123;&#125; ): &#123; html: string; head: any &#125; =&gt; &#123; const renderError = renderPageError() if (renderError) return renderError const &#123; App: EnhancedApp, Component: EnhancedComponent, &#125; = enhanceComponents(options, App, Component) return render( renderElementToString, &lt;AppContainer&gt; &lt;EnhancedApp Component=&#123;EnhancedComponent&#125; router=&#123;router&#125; &#123;...props&#125; /&gt; &lt;/AppContainer&gt;, ampState ) &#125; const documentCtx = &#123; ...ctx, renderPage &#125; const docProps = await loadGetInitialProps(Document, documentCtx) // the response might be finished on the getInitialProps call if (isResSent(res) &amp;&amp; !isSpr) return null let dataManagerData = &apos;[]&apos; if (dataManager) &#123; dataManagerData = JSON.stringify([...dataManager.getData()]) &#125; if (!docProps || typeof docProps.html !== &apos;string&apos;) &#123; const message = `&quot;$&#123;getDisplayName( Document )&#125;.getInitialProps()&quot; should resolve to an object with a &quot;html&quot; prop set with a valid html string` throw new Error(message) &#125; if (docProps.dataOnly) &#123; return dataManagerData &#125; const dynamicImportIdsSet = new Set&lt;string&gt;() const dynamicImports: ManifestItem[] = [] for (const mod of reactLoadableModules) &#123; const manifestItem = reactLoadableManifest[mod] if (manifestItem) &#123; manifestItem.map(item =&gt; &#123; dynamicImports.push(item) dynamicImportIdsSet.add(item.id as string) &#125;) &#125; &#125; const dynamicImportsIds = [...dynamicImportIdsSet] const inAmpMode = isInAmpMode(ampState) const hybridAmp = ampState.hybrid // update renderOpts so export knows current state renderOpts.inAmpMode = inAmpMode renderOpts.hybridAmp = hybridAmp let html = renderDocument(Document, &#123; ...renderOpts, dangerousAsPath: router.asPath, dataManagerData, ampState, props, headTags: await headTags(documentCtx), bodyTags: await bodyTags(documentCtx), htmlProps: await htmlProps(documentCtx), docProps, pathname, ampPath, query, inAmpMode, hybridAmp, dynamicImportsIds, dynamicImports, files, devFiles, polyfillFiles, &#125;) if (inAmpMode &amp;&amp; html) &#123; // use replace to allow rendering directly to body in AMP mode html = html.replace( &apos;__NEXT_AMP_RENDER_TARGET__&apos;, `&lt;!-- __NEXT_DATA__ --&gt;$&#123;docProps.html&#125;` ) html = await optimizeAmp(html) if (renderOpts.ampValidator) &#123; await renderOpts.ampValidator(html, pathname) &#125; &#125; if (inAmpMode || hybridAmp) &#123; // fix &amp;amp being escaped for amphtml rel link html = html.replace(/&amp;amp;amp=1/g, &apos;&amp;amp=1&apos;) &#125; return html&#125; 使用 renderElementToString 渲染获取 html 12345678910111213141516function render( renderElementToString: (element: React.ReactElement&lt;any&gt;) =&gt; string, element: React.ReactElement&lt;any&gt;, ampMode: any): &#123; html: string; head: React.ReactElement[] &#125; &#123; let html let head try &#123; html = renderElementToString(element) &#125; finally &#123; head = Head.rewind() || defaultHead(isInAmpMode(ampMode)) &#125; return &#123; html, head &#125;&#125; 到这里基本就结束了 Nextjs 还可以有很多自定的东西，与 koa，express 结合～ 参考 https://nextjs.org/ 后续 博大精深啊","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"}]},{"title":"Intersection Obersever API 中文","slug":"JavaScript/IntersectionObserverAPI","date":"2019-10-26T07:30:16.000Z","updated":"2019-10-26T07:16:55.511Z","comments":true,"path":"2019/10/26/JavaScript/IntersectionObserverAPI/","link":"","permalink":"https://wzes.github.io/2019/10/26/JavaScript/IntersectionObserverAPI/","excerpt":"","text":"Intersection observer 简介 Intersection Observer API 提供了一种异步观察目标元素与祖先元素或顶级文档的视口相交的方法。 在以前，检测一个元素的可见性或两个元素相对于彼此的相对可见性一直是一项艰巨的任务，其解决方案不可靠且易于导致浏览器和用户访问的网页变慢。 随着网络的成熟，对此类功能的需求也在增长。 出于多种原因需要元素的可见性信息，例如： 滚动页面时延迟加载图像或其他内容。 实现“无限滚动”的网页，在您滚动时会加载和呈现越来越多的内容，从而使用户不必翻阅页面。 统计广告可见度，以计算广告收入。 根据用户是否会看到结果来决定是否执行任务或动画处理。 过去实现交叉检测通常涉及到事件处理程序，并且循环调用 Element.getBoundingClientRect（）之类的方法来为每个受影响的元素建立所需的信息。 由于所有这些代码都在主线程上运行，因此即使只有一个，也可能会导致性能问题。 当网站加载了这些测试时，事情可能会变得很难看。 考虑使用无限滚动的网页。它使用供应商提供的库来管理在整个页面中定期放置的广告，这些广告具有动画图形，使用自定义库绘制通知框等等。每个元素都有其自己的相交检测程序，它们均在主线程上运行。该网站的作者甚至可能没有意识到这种情况的发生，因为他们可能对所使用的两个库的内部运作了解得很少。当用户滚动页面时，这些相交检测程序在滚动处理代码期间不断触发，从而导致用户对浏览器，网站及其计算机感到崩溃。 Intersection Observer API 使代码可以注册一个回调函数，该回调函数将在他们希望监视的元素进入或退出另一个元素（或视口）时，或者当两个相交的量改变请求的量时执行。这样，站点不再需要在主线程上执行任何操作来监视这种元素交集，并且浏览器可以自由地优化交集的管理。 Intersection Observer API不能告诉您的一件事：重叠的确切像素数或确切地说是重叠像素。但是，它涵盖了更常见的用例：“如果它们相交N％左右，我需要做点什么。” Intersection observer 概念和使用 Intersection Observer API允许您配置一个 callback，只要一个元素（称为目标）与设备视口或指定元素相交，就会调用该 callback。 就此API而言，这称为根元素或根。 通常，您将需要注意与元素最接近的可滚动祖先相关的相交变化，或者，如果元素不是可滚动元素的后代，则要观察视口。 要注意相对于根元素的交点，请指定null。 无论您是使用视口还是其他元素作为根，API都以相同的方式工作，只要目标元素的可见性发生变化，以便与根交叉超过所需的交集量，就执行您提供的回调函数。 目标元素与其根之间的相交度为相交比。 这表示目标元素的百分比，该百分比可见为0.0到1.0之间的值。 创建一个 intersection observer 通过调用交集观察器的构造函数并向其传递一个回调函数来创建交集观察者，只要在一个方向或另一个方向上超过阈值，该回调函数便会运行： 1234567let options = &#123; root: document.querySelector(&apos;#scrollArea&apos;), rootMargin: &apos;0px&apos;, threshold: 1.0&#125;let observer = new IntersectionObserver(callback, options); 阈值1.0表示在root选项指定的元素中可见目标的100％时，将调用回调。 Intersection observer options 参数 传递给 IntersectionObserver（）构造函数的 options 对象使您可以控制在哪些情况下调用观察者的回调。 它具有以下字段： root 用作检查目标可见性的视口的元素。 必须是目标的祖先。 如果未指定或为null，则默认为浏览器视口。 rootMargin 围绕根的边距。可以具有类似于CSS margin属性的值，例如 &quot;10px 20px 30px 40px&quot;（（上，右，下，左）。这些值可以是百分比。这组值用于在计算相交之前增大或缩小根元素边界框的每一侧。默认为全零。 threshold 一个数字或一个数字数组，指示观察者的回调应在目标可见性的百分比上执行。如果只想检测可见性何时超过50％标记，则可以使用0.5值。如果希望每次可见性再超过25％时都运行回调，则可以指定数组[0，0.25，0.5，0.75，1]。默认值为0（意味着即使可见一个像素，回调也将运行）。值为1.0意味着直到每个像素都可见，才认为阈值已通过。 定位要观察的元素 创建观察者后，需要给它一个目标元素以进行观察： 12let target = document.querySelector(&apos;#listItem&apos;);observer.observe(target); 每当目标达到为所指定的阈值时IntersectionObserver，就会调用回调。回调接收IntersectionObserverEntry对象列表和观察者： 12345678910111213let callback = (entries, observer) =&gt; &#123; entries.forEach(entry =&gt; &#123; // Each entry describes an intersection change for one observed // target element: // entry.boundingClientRect // entry.intersectionRatio // entry.intersectionRect // entry.isIntersecting // entry.rootBounds // entry.target // entry.time &#125;);&#125;; 请注意，您的回调是在主线程上执行的。它应尽快运行；如果需要完成任何耗时的操作，请使用Window.requestIdleCallback()。 另外，请注意，如果指定了该root选项，则目标必须是根元素的后代。 如何计算交集 Intersection Observer API考虑的所有区域都是矩形。形状不规则的元素被认为占据了包围元素所有部分的最小矩形。类似地，如果元素的可见部分不是矩形，则该元素的相交矩形被解释为包含该元素所有可见部分的最小矩形。 了解一点有关提供的各种属性如何IntersectionObserverEntry描述相交的方法很有用。 交点根和根边距 在跟踪元素与容器的交集之前，我们需要知道该容器是什么。该容器是交集根或根元素。这可以是文档中的特定元素（是要观察的元素的祖先），也null可以是文档的视口作为容器。 根的相交矩形是用于所要检查的目标或目标的矩形。该矩形的确定如下： 如果相交根是隐式根（即顶级Document），则根相交矩形是视口的矩形。 如果相交根具有溢出剪辑，则根相交矩形是根元素的内容区域。 否则，根相交矩形是相交根的边界客户端矩形（通过调用getBoundingClientRect()它返回）。 创建时，可以通过设置根边缘来进一步调整根相交矩形。定义偏移量中的值添加到相交根的边界框的每一侧，以创建最终的相交根边界（在执行回调时公开）。rootMarginIntersectionObserverrootMarginIntersectionObserverEntry.rootBounds Thresholds 门槛 Intersection Observer API使用阈值，而不是报告可见的目标元素多少微小变化。创建观察者时，可以提供一个或多个数字值，这些数字值表示可见的目标元素的百分比。然后，API仅报告超过这些阈值的可见性更改。 例如，如果您希望每次目标的可见性通过每个25％标记向后或向前移动时都得到通知，则在创建观察者时，可以将数组[0，0.25，0.5，0.75，1]指定为阈值列表。您可以通过在可见性更改时检查传递给回调函数的isIntersecting属性值，来确定可见性的变化方向（即，元素变得更可见还是不可见）IntersectionObserverEntry。如果isIntersecting为true，则目标元素已变得至少与已通过的阈值一样可见。如果为false，则目标不再像给定阈值那样可见。 要了解阈值的工作原理，请尝试滚动下面的框。其中的每个彩色框都会显示其在四个角上都可见的百分比，因此您可以在滚动容器时看到这些比例随时间的变化。每个框都有不同的阈值集： 第一个框有一个针对每个可见度百分比的阈值；也就是说，IntersectionObserver.thresholds数组是[0.00, 0.01, 0.02, ..., 0.99, 1.00]。 第二个框只有一个阈值，为50％。 第三个框的阈值是可见性的每10％（0％，10％，20％等）。 最后一个框的阈值各为25％。 裁剪和交点矩形 浏览器按以下方式计算最终的相交矩形：这一切都为您完成，但是了解这些步骤有助于更好地准确把握何时发生交叉点。 通过调用getBoundingClientRect()目标，可以获得目标元素的边界矩形（即，完全包围组成该元素的每个组件的边界框的最小矩形）。这是最大的相交矩形。其余步骤将删除所有不相交的部分。 从目标的直接父块开始并向外移动，每个包含块的剪辑（如果有）都应用于相交矩形。根据两个块的交集和该overflow属性指定的剪切模式（如果有）来确定块的剪切。设置overflow为其他任何值visible都会导致发生裁剪。 如果其中一个包含元素是嵌套浏览上下文的根（例如包含在中的文档）[](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe)，则交集矩形会被裁剪到包含上下文的视口，并且向上递归通过容器继续进行到容器的包含块。到达的最高层，将相交矩形剪切到框架的视口，然后框架的父元素是向相交根递归的下一个块。 当向上递归到达相交根时，生成的矩形将映射到相交根的坐标空间。 然后，通过与根相交矩形相交来更新生成的矩形。 最后，将此矩形映射到目标的坐标空间document。 交叉变更callbacks 当在根元素中可见的目标元素的数量超过可见性阈值之一时，将IntersectionObserver执行对象的回调。回调接收所有IntersectionObserverEntry对象的数组作为输入，每个超过阈值的对象一个，以及对IntersectionObserver对象本身的引用。 阈值列表中的每个条目都是一个IntersectionObserverEntry对象，它描述一个被超过的阈值。也就是说，每个条目都描述了给定元素中有多少与根元素相交，该元素是否被认为相交以及过渡发生的方向。 下面的代码段显示了一个回调，该回调保留了元素从不相交根到相交至少75％过渡的次数的计数。 1234567891011intersectionCallback(entries) =&gt; &#123; entries.forEach(entry =&gt; &#123; if (entry.isIntersecting) &#123; let elem = entry.target; if (entry.intersectionRatio &gt;= 0.75) &#123; intersectionCounter++; &#125; &#125; &#125;);&#125; 接口 IntersectionObserver Intersection Observer API的主要接口。提供用于创建和管理观察者的方法，该观察者可以监视相同交集配置的任意数量的目标元素。每个观察者可以异步观察一个或多个目标元素和共用祖先元素之间或与它们顶层的交点变化Document的视口。祖先或视口称为根。 IntersectionObserverEntry 描述在特定过渡时刻目标元素及其根容器之间的交集。只能以两种方式获得此类型的对象：作为IntersectionObserver回调的输入，或通过调用IntersectionObserver.takeRecords()。 一个简单的例子 这个简单的示例使目标元素在变得或多或少可见时更改其颜色和透明度。在使用Intersection Observer API的“计时元素可见性”中，您可以找到一个更广泛的示例，该示例显示如何计时用户可以看到一组元素（例如广告）多长时间，以及如何通过记录统计信息或更新元素来对该信息做出反应… HTML 此示例的HTML非常简短，其中有一个主要元素，即我们将要定位的框（带有creative ID &quot;box&quot;）和该框中的一些内容。 12345&lt;div id=&quot;box&quot;&gt; &lt;div class=&quot;vertical&quot;&gt; Welcome to &lt;strong&gt;The Box!&lt;/strong&gt; &lt;/div&gt;&lt;/div&gt; CSS 就本示例而言，CSS并不是十分重要。它对元素进行了布局，并确定background-colorand border属性可以参与CSS过渡，当元素或多或少被遮盖时，我们将使用它来影响元素的更改。 12345678910111213141516171819202122232425#box &#123; background-color: rgba(40, 40, 190, 255); border: 4px solid rgb(20, 20, 120); transition: background-color 1s, border 1s; width: 350px; height: 350px; display: flex; align-items: center; justify-content: center; padding: 20px;&#125;.vertical &#123; color: white; font: 32px &quot;Arial&quot;;&#125;.extra &#123; width: 350px; height: 350px; margin-top: 10px; border: 4px solid rgb(20, 20, 120); text-align: center; padding: 20px;&#125; JavaScript 最后，让我们看一下使用Intersection Observer API进行事情的JavaScript代码。 配置 首先，我们需要准备一些变量并安装观察器。 12345678910111213const numSteps = 20.0;let boxElement;let prevRatio = 0.0;let increasingColor = &quot;rgba(40, 40, 190, ratio)&quot;;let decreasingColor = &quot;rgba(190, 40, 40, ratio)&quot;;// Set things upwindow.addEventListener(&quot;load&quot;, (event) =&gt; &#123; boxElement = document.querySelector(&quot;#box&quot;); createObserver();&#125;, false); 我们在此处设置的常量和变量是： numSteps 一个常数，指示我们希望在0.0和1.0的可见性比率之间具有多少个阈值。 prevRatio 此变量将用于记录上次超过阈值时可见性比率。这将让我们弄清楚目标元素是否变得越来越明显。 increasingColor 定义可见性比率增加时将应用于目标元素的颜色的字符串。该字符串中的“比率”一词将替换为目标的当前可见性比率，因此该元素不仅会改变颜色，而且会变得越来越不透明，因为它变得越来越模糊。 decreasingColor 同样，这是一个字符串，定义了可见率降低时将应用的颜色。 我们呼吁Window.addEventListener()开始收听load事件。一旦页面加载完成后，我们得到的元素的引用与ID &quot;box&quot;使用querySelector()，然后调用createObserver()我们将在稍后创建来处理建筑方法和安装的交叉点观测。 创建相交观察器 createObserver()一旦页面加载完成，便会调用该方法以处理实际创建新对象IntersectionObserver并开始观察目标元素的过程。 123456789101112function createObserver() &#123; let observer; let options = &#123; root: null, rootMargin: &quot;0px&quot;, threshold: buildThresholdList() &#125;; observer = new IntersectionObserver(handleIntersect, options); observer.observe(boxElement);&#125; 首先从设置一个options包含观察者设置的对象开始。我们要留意的目标元素相对于文档的视口的可见性的变化，所以root是null。我们不需要边距，因此边距偏移量rootMargin指定为“ 0px”。这使观察者可以观察目标元素的边界与视口边界之间的交集处的变化，而无需增加（或减去）任何空间。 可见度阈值列表threshold由函数构造buildThresholdList()。在此示例中，以编程方式构建阈值列表，因为存在许多阈值列表，并且该数量旨在调整。 一旦options准备好了，我们创建了新的观察员，调用IntersectionObserver()构造函数，指定一个函数被调用时，路口穿越我们的其中一个阈值，handleIntersect()和我们一组选项。然后observe()，我们调用返回的观察者，将所需的目标元素传递给它。 如果我们愿意的话，我们可以选择通过监视observer.observe()每个元素来监视多个元素是否相对于视口相交。 建立阈值比率数组 buildThresholdList()构建阈值列表的函数如下所示： 123456789101112function buildThresholdList() &#123; let thresholds = []; let numSteps = 20; for (let i=1.0; i&lt;=numSteps; i++) &#123; let ratio = i/numSteps; thresholds.push(ratio); &#125; thresholds.push(0); return thresholds;&#125; 这将构建阈值数组-通过将值介于1和之间的每个整数推i/numSteps入thresholds数组，每个阈值之间的比率为0.0和1.0 i之间numSteps。它还推0以包括该值。给定默认值numSteps（20），结果是以下阈值列表： ＃ Ratio ＃ Ratio 1个 0.05 11 0.55 2 0.1 12 0.6 3 0.15 13 0.65 4 0.2 14 0.7 5 0.25 15 0.75 6 0.3 16 0.8 7 0.35 17 0.85 8 0.4 18 0.9 9 0.45 19 0.95 10 0.5 20 1.0 当然，我们可以将阈值数组硬编码到我们的代码中，而这通常是您最终要做的。但是，此示例为添加配置控件以调整粒度提供了空间。 处理交集变更 当浏览器检测到目标元素（在我们的示例中为ID的元素&quot;box&quot;）已经被公开或模糊，以致其可见性比率超过列表中的阈值之一时，它将调用处理程序函数handleIntersect()： 1234567891011function handleIntersect(entries, observer) &#123; entries.forEach((entry) =&gt; &#123; if (entry.intersectionRatio &gt; prevRatio) &#123; entry.target.style.backgroundColor = increasingColor.replace(\"ratio\", entry.intersectionRatio); &#125; else &#123; entry.target.style.backgroundColor = decreasingColor.replace(\"ratio\", entry.intersectionRatio); &#125; prevRatio = entry.intersectionRatio; &#125;);&#125; 对于IntersectionObserverEntry列表中的每个entries条目，我们查看条目intersectionRatio是否在上升；如果是，我们将目标的设置background-color为中的字符串increasingColor（请记住，它是&quot;rgba(40, 40, 190, ratio)&quot;），将单词“ ratio”替换为条目的intersectionRatio。结果：不仅颜色改变了，目标元素的透明度也改变了；当交叉比例降低时，背景色的Alpha值随之降低，从而使元素更透明。 同样，如果intersectionRatio下降，则使用字符串，decreasingColor并intersectionRatio在设置目标元素的之前将其中的“比率”一词替换为background-color。 最后，为了跟踪交叉比率是上升还是下降，我们记住变量中的当前比率prevRatio。 浏览器兼容性 Update compatibility data on GitHub Desktop Mobile Chrome Edge Firefox Internet Explorer Opera Safari Android webview Chrome for Android Firefox for Android Opera for Android Safari on iOS Samsung Internet IntersectionObserverExperimental Full support51 Full support15 Full support55Open No supportNo Full supportYes Full support12.1 Full support51 Full support51 ? ? Full support12.2 Full support5.0 IntersectionObserver() constructorExperimental Full support51 Full support15 Full support55Open No supportNo ? Full support12.1 Full support51 Full support51 ? ? Full support12.2 Full support5.0 disconnectExperimental Full support51 Full support15NotesOpen Full support55Open No supportNo Full supportYes ? Full support51 Full support51 ? ? ? Full support5.0 observeExperimental Full support51 Full support15 Full support55Open No supportNo Full supportYes Full support12.1 Full support51 Full support51 ? ? Full support12.2 Full support5.0 rootExperimental Full support51 Full support15 Full support55Open No supportNo Full supportYes Full support12.1 Full support51 Full support51 ? ? Full support12.2 Full support5.0 rootMarginExperimental Full support51 Full support15 Full support55Open No supportNo Full supportYes Full support12.1NotesOpen Full support51 Full support51 ? ? Full support12.2NotesOpen Full support5.0 takeRecordsExperimental Full support51 Full support15NotesOpen Full support55Open No supportNo Full supportYes ? Full support51 Full support51 ? ? ? Full support5.0 thresholdsExperimental Full support51 Full support15 Full support55Open No supportNo Full supportYes Full support12.1 Full support51 Full support51 ? ? Full support12.2 Full support5.0 unobserveExperimental Full support51 Full support15NotesOpen Full support55Open No supportNo Full supportYes Full support12.1 Full support51 Full support51 ? ? Full support12.2 Full support5.0","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"}]},{"title":"iScroll 源码学习","slug":"JavaScript/iScroll","date":"2019-10-23T10:30:16.000Z","updated":"2019-10-24T06:15:03.500Z","comments":true,"path":"2019/10/23/JavaScript/iScroll/","link":"","permalink":"https://wzes.github.io/2019/10/23/JavaScript/iScroll/","excerpt":"","text":"前言 强大的 iScroll 啊，功能的确多，但我只想看看你的 flinger 滑动处理的精髓！感觉 iscroll 的滑动处理的还可以吧，虽然比不上系统的 scroll，但也不至于很难受，学会了这招，可以出去吹吹牛（招摇撞骗）了。 须知 通常如果我们给容器设置一个高度，如果子节点的高度超出了父容器的高度，那么内容就可以进行滚动，原因在于 overflow 属性默认为 auto，当然最好将父容器设置为 overflow: scroll，子内容就可以进行滚动。还可以单独设置 X 或 Y 轴的滚动，overflow-x:scroll 或 overflow-y:scroll，如果不想让内容滚动，则设置 overflow: hidden 是什么 iScroll 是一种高性能，占用空间小，无依赖的多平台 javascript 滚动器。 它适用于台式机，移动电视和智能电视。它已针对性能和尺寸进行了优化，以在现代和旧设备上提供最平滑的结果。 iScroll不仅可以滚动。它可以处理需要通过用户交互移动的任何元素。它为您的项目添加了滚动，缩放，平移，无限滚动，视差滚动，轮播，并且仅以4kb的速度做到了这一点。给它扫帚，它也会打扫你的办公室。 即使在本机滚动足以胜任的平台上，iScroll也会添加原本无法实现的功能。特别： 即使在动量期间，也可以对滚动位置进行精细控制。您始终可以获取并设置滚动条的x，y坐标。 可以使用用户定义的缓动功能（弹跳，弹性，后退…）自定义动画。 您可以轻松地挂钩到大量自定义事件（onBeforeScrollStart，onScrollStart，onScroll，onScrollEnd，flick等）。 开箱即用的多平台支持。从较旧的Android设备到最新的iPhone，从Chrome到Internet Explorer。 Get started 假设我们的元素长这个样子 1234567&lt;div id=&quot;wrapper&quot;&gt; &lt;ul&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; ... &lt;/ul&gt;&lt;/div&gt; 那我们只需要在脚本中使用 new IScroll 即可 1myScroll = new IScroll(&apos;#wrapper&apos;); 当然，他还有很多属性（只可意会） 12345678910111213141516171819this.options = &#123; disablePointer : !utils.hasPointer, disableTouch : utils.hasPointer || !utils.hasTouch, disableMouse : utils.hasPointer || utils.hasTouch, startX: 0, // 开始滚动的值 startY: 0, scrollY: true, directionLockThreshold: 5, momentum: true, // 对其 Native 的 flinger(手指放开后还会继续滚动一段距离) bounce: true, // 滚动回弹 bounceTime: 600, bounceEasing: &apos;&apos;, preventDefault: true, preventDefaultException: &#123; tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ &#125;, HWCompositing: true, useTransition: true, useTransform: true, bindToWrapper: typeof window.onmousedown === &quot;undefined&quot;&#125; 原理概括 iScroll 当然没有使用系统的 scroll，原因有很多点，上面也提到过。 iScroll 使用了 transform: translate(px, px)来实现滚动，完全是通过自己计算来实现的，当然，如果系统支持 transation，那么 iScroll 的松手后滚动将借助 transitionTimingFunction，否则就自定义动画，完成平滑滚动。 源码解析 入口 IScroll 是一个方法，调用了以后会创建属性，进行初始化，其中 this.x 和 this.y 分别记录了x 轴 与 y 轴的滚动距离。 1234567891011121314151617181920function IScroll (el, options) &#123; this.wrapper = typeof el == &apos;string&apos; ? document.querySelector(el) : el; this.scroller = this.wrapper.children[0]; this.scrollerStyle = this.scroller.style; // cache style for better performance // 此处省略了 this.options 的赋值 // Some defaults this.x = 0; this.y = 0; this.directionX = 0; this.directionY = 0; this._events = &#123;&#125;; this._init(); this.refresh(); this.scrollTo(this.options.startX, this.options.startY); this.enable();&#125; 初始化事件 在 this._init(); 中初始化了事件监听，在手机端主要是 touch 开头的事件，PC 端主要是 mouse 事件，pointer 是指针事件，此外，还会监听 transitionend 事件，用于滚动结束事件的监听。 12345678910111213141516171819202122232425262728293031323334353637_initEvents: function (remove) &#123; var eventType = remove ? utils.removeEvent : utils.addEvent, target = this.options.bindToWrapper ? this.wrapper : window; eventType(window, &apos;orientationchange&apos;, this); eventType(window, &apos;resize&apos;, this); if ( this.options.click ) &#123; eventType(this.wrapper, &apos;click&apos;, this, true); &#125; if ( !this.options.disableMouse ) &#123; eventType(this.wrapper, &apos;mousedown&apos;, this); eventType(target, &apos;mousemove&apos;, this); eventType(target, &apos;mousecancel&apos;, this); eventType(target, &apos;mouseup&apos;, this); &#125; if ( utils.hasPointer &amp;&amp; !this.options.disablePointer ) &#123; eventType(this.wrapper, utils.prefixPointerEvent(&apos;pointerdown&apos;), this); eventType(target, utils.prefixPointerEvent(&apos;pointermove&apos;), this); eventType(target, utils.prefixPointerEvent(&apos;pointercancel&apos;), this); eventType(target, utils.prefixPointerEvent(&apos;pointerup&apos;), this); &#125; if ( utils.hasTouch &amp;&amp; !this.options.disableTouch ) &#123; eventType(this.wrapper, &apos;touchstart&apos;, this); eventType(target, &apos;touchmove&apos;, this); eventType(target, &apos;touchcancel&apos;, this); eventType(target, &apos;touchend&apos;, this); &#125; eventType(this.scroller, &apos;transitionend&apos;, this); eventType(this.scroller, &apos;webkitTransitionEnd&apos;, this); eventType(this.scroller, &apos;oTransitionEnd&apos;, this); eventType(this.scroller, &apos;MSTransitionEnd&apos;, this); &#125;, 初始化变量 计算容器高度、宽度，滚动内容高度、宽度，最大滚动距离（X轴，Y轴）等等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 refresh: function () &#123; utils.getRect(this.wrapper); // Force reflow this.wrapperWidth = this.wrapper.clientWidth; this.wrapperHeight = this.wrapper.clientHeight; var rect = utils.getRect(this.scroller);/* REPLACE START: refresh */ this.scrollerWidth = rect.width; this.scrollerHeight = rect.height; this.maxScrollX = this.wrapperWidth - this.scrollerWidth; this.maxScrollY = this.wrapperHeight - this.scrollerHeight;/* REPLACE END: refresh */ this.hasHorizontalScroll = this.options.scrollX &amp;&amp; this.maxScrollX &lt; 0; this.hasVerticalScroll = this.options.scrollY &amp;&amp; this.maxScrollY &lt; 0; if ( !this.hasHorizontalScroll ) &#123; this.maxScrollX = 0; this.scrollerWidth = this.wrapperWidth; &#125; if ( !this.hasVerticalScroll ) &#123; this.maxScrollY = 0; this.scrollerHeight = this.wrapperHeight; &#125; this.endTime = 0; this.directionX = 0; this.directionY = 0; if(utils.hasPointer &amp;&amp; !this.options.disablePointer) &#123; // The wrapper should have `touchAction` property for using pointerEvent. this.wrapper.style[utils.style.touchAction] = utils.getTouchAction(this.options.eventPassthrough, true); // case. not support &apos;pinch-zoom&apos; // https://github.com/cubiq/iscroll/issues/1118#issuecomment-270057583 if (!this.wrapper.style[utils.style.touchAction]) &#123; this.wrapper.style[utils.style.touchAction] = utils.getTouchAction(this.options.eventPassthrough, false); &#125; &#125; this.wrapperOffset = utils.offset(this.wrapper); this._execEvent(&apos;refresh&apos;); this.resetPosition();// INSERT POINT: _refresh &#125;, 滚动函数 给定一个 x，y，滚动时间 time，滚动效果 easing； 如果 time 为 0，则为瞬时滚动，使用 _translate 改变位置，如果环境支持 transition , 那么将使用 transition 属性实现动画。 如果浏览器不支持 transition，time 又不为 0，那么则自定义动画实现滚动 123456789101112131415scrollTo: function (x, y, time, easing) &#123; easing = easing || utils.ease.circular; this.isInTransition = this.options.useTransition &amp;&amp; time &gt; 0; var transitionType = this.options.useTransition &amp;&amp; easing.style; if ( !time || transitionType ) &#123; if(transitionType) &#123; this._transitionTimingFunction(easing.style); this._transitionTime(time); &#125; this._translate(x, y); &#125; else &#123; this._animate(x, y, time, easing.fn); &#125;&#125;, 移动实现 如果元素支持 transform 给元素赋值 transform 属性即可，否则使用 left 属性。然后将 x , y 设置为目标位置，既目前滚动位置，通常都是为负值。 12345678910111213141516171819202122 _translate: function (x, y) &#123; if ( this.options.useTransform ) &#123;/* REPLACE START: _translate */ this.scrollerStyle[utils.style.transform] = &apos;translate(&apos; + x + &apos;px,&apos; + y + &apos;px)&apos; + this.translateZ;/* REPLACE END: _translate */ &#125; else &#123; x = Math.round(x); y = Math.round(y); this.scrollerStyle.left = x + &apos;px&apos;; this.scrollerStyle.top = y + &apos;px&apos;; &#125; this.x = x; this.y = y;// INSERT POINT: _translate &#125;, 触摸事件处理 Core 便于分析，我只考虑y方向的滑动，x方向同理（会删除掉 x 方向的代码） start（movestart，mousedown…） 其中比较重要的是 startY，startTime，记录下目前滚动位置，滚动时刻 pointY 则是点击位置 1234567891011121314151617181920212223242526272829_start: function (e) &#123; var point = e.touches ? e.touches[0] : e, pos; this.initiated = utils.eventType[e.type]; this.moved = false; this.distY = 0; this.directionY = 0; this.directionLocked = 0; this.startTime = utils.getTime(); if ( this.options.useTransition &amp;&amp; this.isInTransition ) &#123; this._transitionTime(); this.isInTransition = false; pos = this.getComputedPosition(); this._translate(Math.round(pos.x), Math.round(pos.y)); this._execEvent(&apos;scrollEnd&apos;); &#125; else if ( !this.options.useTransition &amp;&amp; this.isAnimating ) &#123; this.isAnimating = false; this._execEvent(&apos;scrollEnd&apos;); &#125; this.startY = this.y; this.absStartY = this.y; this.pointY = point.pageY; this._execEvent(&apos;beforeScrollStart&apos;);&#125;, move 通常，手指不松开，屏幕滚动是跟随手指移动的，手指怎么移动，屏幕就怎么移动。 首先会判断该次滑动是否有效，然后锁定滑动方向，最后计算 newY，需要滑动的位置 newY = this.y + deltaY 是通过 delta 来计算的。然后使用 translate 函数移动进行瞬时移动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 _move: function (e) &#123; var point = e.touches ? e.touches[0] : e, deltaY = point.pageY - this.pointY, timestamp = utils.getTime(), newY, absDistY; this.pointY = point.pageY; this.distY += deltaY; absDistY = Math.abs(this.distY); // We need to move at least 10 pixels for the scrolling to initiate if ( timestamp - this.endTime &gt; 300 &amp;&amp; (absDistX &lt; 10 &amp;&amp; absDistY &lt; 10) ) &#123; return; &#125; // If you are scrolling in one direction lock the other if ( !this.directionLocked &amp;&amp; !this.options.freeScroll ) &#123; if ( absDistX &gt; absDistY + this.options.directionLockThreshold ) &#123; this.directionLocked = &apos;h&apos;; // lock horizontally &#125; else if ( absDistY &gt;= absDistX + this.options.directionLockThreshold ) &#123; this.directionLocked = &apos;v&apos;; // lock vertically &#125; else &#123; this.directionLocked = &apos;n&apos;; // no lock &#125; &#125; if ( this.directionLocked == &apos;h&apos; ) &#123; if ( this.options.eventPassthrough == &apos;vertical&apos; ) &#123; e.preventDefault(); &#125; else if ( this.options.eventPassthrough == &apos;horizontal&apos; ) &#123; this.initiated = false; return; &#125; deltaY = 0; &#125; else if ( this.directionLocked == &apos;v&apos; ) &#123; if ( this.options.eventPassthrough == &apos;horizontal&apos; ) &#123; e.preventDefault(); &#125; else if ( this.options.eventPassthrough == &apos;vertical&apos; ) &#123; this.initiated = false; return; &#125; deltaX = 0; &#125; deltaY = this.hasVerticalScroll ? deltaY : 0; newY = this.y + deltaY; // Slow down if outside of the boundaries if ( newY &gt; 0 || newY &lt; this.maxScrollY ) &#123; newY = this.options.bounce ? this.y + deltaY / 3 : newY &gt; 0 ? 0 : this.maxScrollY; &#125; this.directionY = deltaY &gt; 0 ? -1 : deltaY &lt; 0 ? 1 : 0; if ( !this.moved ) &#123; this._execEvent(&apos;scrollStart&apos;); &#125; this.moved = true; this._translate(newX, newY);/* REPLACE START: _move */ if ( timestamp - this.startTime &gt; 300 ) &#123; this.startTime = timestamp; this.startX = this.x; this.startY = this.y; &#125;/* REPLACE END: _move */ &#125;, 其中一个比较重要的是，如果这次 move 的时刻与上一次（start）的时间超过 300 ms，会进行重置（太妙了！！）这与接下来的 end 有着非常重要的意义 1234if ( timestamp - this.startTime &gt; 300 ) &#123; this.startTime = timestamp; this.startY = this.y;&#125; end 在 end 中将进行动量滚动（松开后还能进行滚动） 动量滚动最重要的是计算两个值，松开后滚动的 时间 和 距离，也是 iscroll 最核心的部分。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 _end: function (e) &#123; var point = e.changedTouches ? e.changedTouches[0] : e, momentumY, duration = utils.getTime() - this.startTime, newY = Math.round(this.y), distanceY = Math.abs(newY - this.startY), time = 0, easing = &apos;&apos;; this.isInTransition = 0; this.initiated = 0; this.endTime = utils.getTime(); // reset if we are outside of the boundaries if ( this.resetPosition(this.options.bounceTime) ) &#123; return; &#125; this.scrollTo(newX, newY); // ensures that the last position is rounded // we scrolled less than 10 pixels if ( !this.moved ) &#123; if ( this.options.tap ) &#123; utils.tap(e, this.options.tap); &#125; if ( this.options.click ) &#123; utils.click(e); &#125; this._execEvent(&apos;scrollCancel&apos;); return; &#125; if ( this._events.flick &amp;&amp; duration &lt; 200 &amp;&amp; distanceX &lt; 100 &amp;&amp; distanceY &lt; 100 ) &#123; this._execEvent(&apos;flick&apos;); return; &#125; // start momentum animation if needed if ( this.options.momentum &amp;&amp; duration &lt; 300 ) &#123; momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : &#123; destination: newY, duration: 0 &#125;; newY = momentumY.destination; time = Math.max(momentumX.duration, momentumY.duration); this.isInTransition = 1; &#125;// INSERT POINT: _end if ( newX != this.x || newY != this.y ) &#123; // change easing function when scroller goes out of the boundaries if ( newX &gt; 0 || newX &lt; this.maxScrollX || newY &gt; 0 || newY &lt; this.maxScrollY ) &#123; easing = utils.ease.quadratic; &#125; this.scrollTo(newX, newY, time, easing); return; &#125; this._execEvent(&apos;scrollEnd&apos;); &#125;, 计算使用了 util.momentum 输入，现在的滚动位置 y，上一次开始的 startY（该位置会在 move 中重置），time（距离上一次 start 的时间），lowerMargin 最大的滚动距离，wrapperSize 容器的尺寸，deceleration 插值器 话不多说，自己欣赏吧。返回滚动时间和目标滚动位置 1234567891011121314151617181920212223242526momentum = function (current, start, time, lowerMargin, wrapperSize, deceleration) &#123; var distance = current - start, speed = Math.abs(distance) / time, destination, duration; deceleration = deceleration === undefined ? 0.0006 : deceleration; destination = current + ( speed * speed ) / ( 2 * deceleration ) * ( distance &lt; 0 ? -1 : 1 ); duration = speed / deceleration; if ( destination &lt; lowerMargin ) &#123; destination = wrapperSize ? lowerMargin - ( wrapperSize / 2.5 * ( speed / 8 ) ) : lowerMargin; distance = Math.abs(destination - current); duration = distance / speed; &#125; else if ( destination &gt; 0 ) &#123; destination = wrapperSize ? wrapperSize / 2.5 * ( speed / 8 ) : 0; distance = Math.abs(current) + destination; duration = distance / speed; &#125; return &#123; destination: Math.round(destination), duration: duration &#125;;&#125;; 然后就是使用 scrollTo 函数进行动量滚动了。this.isInTransition 标志正在进行动量滚动，如果期间存在 touchdown 事件，则会立刻停止滚动。 1234567891011if ( this.options.useTransition &amp;&amp; this.isInTransition ) &#123; this._transitionTime(); this.isInTransition = false; pos = this.getComputedPosition(); this._translate(Math.round(pos.x), Math.round(pos.y)); this._execEvent(&apos;scrollEnd&apos;); &#125; else if ( !this.options.useTransition &amp;&amp; this.isAnimating ) &#123; this.isAnimating = false; this._execEvent(&apos;scrollEnd&apos;); &#125;&#125; 至此，核心功能差不多了 但 iscroll 还有其他很多功能，比如 轮播图 放大缩小 … 最后 其实吧，iScroll 也也就那么回事。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"}]},{"title":"Gulp 入门指南","slug":"JavaScript/Gulp","date":"2019-10-20T07:30:16.000Z","updated":"2019-10-20T09:58:06.150Z","comments":true,"path":"2019/10/20/JavaScript/Gulp/","link":"","permalink":"https://wzes.github.io/2019/10/20/JavaScript/Gulp/","excerpt":"","text":"前言 明天就要晋升答辩了，今天写篇入门 Wiki 压压惊吧，正好最近想学构建工具之类的东西，Gulp 好像就很合适 Glup 是什么？ Gulp 有狼吞虎咽的意思。 官方【https://gulpjs.com/docs】解释 gulp 是一个工具包，用于在开发工作流程中自动化繁琐或耗时的任务，因此您可以避免混乱并构建一些东西。 直白来说，就是一个构建工具。常用来制作开发脚手架，生产模版～ Get Started Node 环境 首先，检查 node、npm 和 npx 是否正确安装 全局安装 1npm install gulp-cli -g 创建项目目录并进入 1mkdir gulp-project &amp; cd gulp-project 在项目目录下创建 package.json 文件 1npm init 安装 gulp，作为开发时依赖项 1npm install --save-dev gulp 创建 gulpfile 文件 利用任何文本编辑器在项目大的根目录下创建一个名为 gulpfile.js 的文件，并在文件中输入以下内容： 123456function defaultTask(cb) &#123; // place code for your default task here cb();&#125;exports.default = defaultTask 测试 在项目根目录下执行 gulp 命令： 1gulp 输出 123[17:16:32] Using gulpfile ~/WebProjects/gulp-project/gulpfile.js[17:16:32] Starting &apos;default&apos;...[17:16:32] Finished &apos;default&apos; after 1.37 ms 高级用法 文件监控和处理 使用 watch，监听文件变化，将 src 目录的 js 文件复制到 output 目录下。 1234567891011const &#123; src, dest, watch &#125; = require(&apos;gulp&apos;);const gulp = require(&apos;gulp&apos;)function streamTask() &#123; return src(&apos;src/**/*.js&apos;) .pipe(dest(&apos;output&apos;));&#125;// 创建一个任务gulp.task(&apos;watch&apos;, function () &#123; watch(&apos;src/*.js&apos;, streamTask);&#125;) 似乎非常方便，封装了 chokidar 写在最后 可以集成 rollup，webpack 等 node api，做一个 hotreload 参考 https://www.gulpjs.com.cn/docs/getting-started/quick-start/","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"}]},{"title":"JavaScript Event preventDefault和stopPropagation","slug":"JavaScript/JavaScript Event","date":"2019-09-30T07:30:16.000Z","updated":"2019-09-30T07:52:23.506Z","comments":true,"path":"2019/09/30/JavaScript/JavaScript Event/","link":"","permalink":"https://wzes.github.io/2019/09/30/JavaScript/JavaScript Event/","excerpt":"","text":"前言 对于JS的事件传递还是比较陌生，所以打算好好理一理preventDefault和stopPropagation的用法，彻底告别模糊，提升自己的前端段位！ 栗子 在以下示例中，单击Web浏览器中的超链接将触发事件的流程（执行事件监听器）和事件目标的默认操作（打开新选项卡）。 HTML： 123&lt;div id=&quot;a&quot;&gt; &lt;a id=&quot;b&quot; href=&quot;http://www.google.com/&quot; target=&quot;_blank&quot;&gt;Google&lt;/a&gt;&lt;/div&gt; JavaScript: 123456789101112131415161718var el = document.getElementById(&quot;c&quot;);function capturingOnClick1(ev) &#123; el.innerHTML += &quot;DIV event capture&lt;br&gt;&quot;;&#125;function capturingOnClick2(ev) &#123; el.innerHTML += &quot;A event capture&lt;br&gt;&quot;;&#125;function bubblingOnClick1(ev) &#123; el.innerHTML += &quot;DIV event bubbling&lt;br&gt;&quot;;&#125;function bubblingOnClick2(ev) &#123; el.innerHTML += &quot;A event bubbling&lt;br&gt;&quot;;&#125;// The 3rd parameter useCapture makes the event listener capturing (false by default)document.getElementById(&quot;a&quot;).addEventListener(&quot;click&quot;, capturingOnClick1, true);document.getElementById(&quot;b&quot;).addEventListener(&quot;click&quot;, capturingOnClick2, true);document.getElementById(&quot;a&quot;).addEventListener(&quot;click&quot;, bubblingOnClick1, false);document.getElementById(&quot;b&quot;).addEventListener(&quot;click&quot;, bubblingOnClick2, false); 输出 event captureA event captureA event bubblingDIV event bubbling1234DIV event captureA event captureA event bubblingDIV event bubbling 向capturingOnClick1函数添加stopPropagation() 1234function capturingOnClick1(ev) &#123; el.innerHTML += &quot;DIV event capture&lt;br&gt;&quot;; ev.stopPropagation();&#125; 结果只输出 1DIV event capture 事件侦听器阻止了事件的进一步向下和向上传播。但是，这并没有阻止默认操作（打开新标签页）。 向capturingOnClick2函数添加stopPropagation() 1234function capturingOnClick2(ev) &#123; el.innerHTML += &quot;A event capture&lt;br&gt;&quot;; ev.stopPropagation();&#125; 或者 1234function bubblingOnClick2(ev) &#123; el.innerHTML += &quot;A event bubbling&lt;br&gt;&quot;; ev.stopPropagation();&#125; 结果 123DIV event captureA event captureA event bubbling 这是因为两个事件侦听器都注册在同一事件目标上。事件侦听器阻止了事件的进一步向上传播。但是，它们并没有阻止默认操作（打开新标签页）。 将preventDefault()添加到任何函数中 1234function capturingOnClick1(ev) &#123; el.innerHTML += &quot;DIV event capture&lt;br&gt;&quot;; ev.preventDefault();&#125; 结果照常输出 1234DIV event captureA event captureA event bubblingDIV event bubbling 但它阻止打开新标签页 原理解析 事件顺序 基本问题很简单，假设元素内部有一个元素，如下： 1234567-----------------------------------| element1 || ------------------------- || |element2 | || ------------------------- || |----------------------------------- 两者都有一个onClick事件处理程序。如果用户单击element2，他将在element1和element2中都引起click事件。但是哪个事件首先触发？应该先执行哪个事件处理程序？换句话说，事件顺序是什么？ 两种事件模型 在过去，Netscape和Microsoft得出了不同的结论。 Netscape说，element1上的事件首先发生。这称为事件捕获***(capturing)***。 Microsoft坚持认为element2上的事件优先。这称为事件冒泡**(bubbling)**。 这两个事件顺序完全相反。 Explorer仅支持事件冒泡。 Mozilla，Opera 7和Konqueror都支持。旧版Opera和iCab都不支持。 事件捕获（capturing） 使用事件捕获时 12345678 | |---------------| |-----------------| element1 | | || -----------| |----------- || |element2 \\ / | || ------------------------- || Event CAPTURING |----------------------------------- element1的事件处理程序首先触发，element2的事件处理程序最后触发。 事件冒泡（bubbling） 使用事件冒泡时 12345678 / \\---------------| |-----------------| element1 | | || -----------| |----------- || |element2 | | | || ------------------------- || Event BUBBLING |----------------------------------- element2的事件处理程序首先触发，element1的事件处理程序最后触发。 W3C 事件模型 W3C非常明智地决定在这场斗争中处于中间位置。 W3C事件模型中发生的任何事件都首先被捕获，直到到达目标元素，然后再次冒泡。 12345678 | | / \\-----------------| |--| |-----------------| element1 | | | | || -------------| |--| |----------- || |element2 \\ / | | | || -------------------------------- || W3C event model |------------------------------------------` Web开发人员可以选择是在捕获阶段还是冒泡阶段中注册事件处理程序。这是通过“高级模型”页面上说明的addEventListener()方法完成的。如果最后一个参数为true，则为捕获阶段设置事件处理程序，如果为false，则为冒泡阶段设置事件处理程序。 假设 12element1.addEventListener(&apos;click&apos;,doSomething2,true)element2.addEventListener(&apos;click&apos;,doSomething,false) 如果用户单击element2，则会发生以下情况： 单击事件在捕获阶段开始。该事件查找element2的任何祖先元素是否具有用于捕获阶段的onclick事件处理程序。 该事件在element1上找到一个。doSomething2()被执行。 事件向下传播到目标本身，找不到用于捕获阶段的事件处理程序。该事件进入其冒泡阶段并执行doSomething()，该事件已在冒泡阶段注册到element2。 事件再次向上传播，并检查目标的任何祖先元素是否具有用于冒泡阶段的事件处理程序。事实并非如此，因此什么也没有发生。 相反 12element1.addEventListener(&apos;click&apos;,doSomething2,false)element2.addEventListener(&apos;click&apos;,doSomething,false) 现在，如果用户单击element2，则会发生以下情况： 单击事件在捕获阶段开始。该事件将查找element2的任何祖先元素是否具有用于捕获阶段的onclick事件处理程序，而找不到任何事件处理程序。 事件向下传播到目标本身。该事件进入其冒泡阶段并执行doSomething()，该事件已在冒泡阶段注册到element2。 事件再次向上传播，并检查目标的任何祖先元素是否具有用于冒泡阶段的事件处理程序。 该事件在element1上找到一个。现在执行doSomething2()。 与传统模型的兼容性 在支持W3C DOM的浏览器中，传统的事件注册 1element1.onclick = doSomething2; 被视为冒泡阶段的注册。 使用事件冒泡 很少有Web开发人员自觉使用事件捕获或冒泡。在当今的网页中，根本没有必要让冒泡事件由多个不同的事件处理程序处理。用户可能会因单击鼠标后发生的几件事而感到困惑，并且通常您希望将事件处理脚本分开。当用户单击某个元素时，会发生某些事情，而当用户单击另一个元素时，会发生其他事情。 当然，这种情况将来可能会改变，因此最好可以使用向前兼容的模型。但是，今天事件捕获和冒泡的主要实际用途是默认功能的注册。 总是会发生 您首先需要了解的是，事件捕获或冒泡总是会发生。如果您为整个document定义常规的onclick事件处理程序 12document.onclick = doSomething;if (document.captureEvents) document.captureEvents(Event.CLICK); document中任何元素上的任何click事件最终都会冒泡到document中，从而触发此常规事件处理程序。仅当以前的事件处理脚本明确命令事件停止冒泡时，它才不会冒泡到 document。 使用 因为任何事件最终都出现在 document 上，所以默认事件处理程序成为可能。假设您有此页面： 1234567891011------------------------------------| document || --------------- ------------ || | element1 | | element2 | || --------------- ------------ || |------------------------------------element1.onclick = doSomething;element2.onclick = doSomething;document.onclick = defaultFunction; 现在，如果用户单击element1或2，则将执行doSomething()。如果需要，可以在此处停止事件传播。如果您不这样做，则事件会上升到defaultFunction()。如果用户单击其他任何地方，还将执行defaultFunction()。有时这可能很有用。 在拖放脚本中，必须设置document范围的事件处理程序。通常，上层的mousedown事件会选择该层并使之响应mousemove事件。尽管通常在层上注册mousedown以避免浏览器错误，但是其他两个事件处理程序都必须在document范围内。 记住浏览器学的第一定律：任何事情都有可能发生，并且通常在您最没有准备的情况下才会发生。因此，用户可能会非常疯狂地移动鼠标，而脚本无法跟上，以至于鼠标不再位于图层上。 如果onmousemove事件处理程序已注册到图层，则该图层不再对鼠标移动做出反应，从而引起混乱。 如果onmouseup事件处理程序已在图层上注册，则不会捕获此事件，因此即使用户认为他放下了该图层，该图层也会继续对鼠标移动做出反应。这引起了更多的混乱。 因此，在这种情况下，事件冒泡非常有用，因为在文档级别注册事件处理程序可确保始终执行它们。 禁用 但是通常您想关闭所有捕获和冒泡功能，以防止功能相互干扰。此外，如果您的文档结构非常复杂（很多嵌套表等），则可以通过关闭冒泡来节省系统资源。浏览器必须遍历事件目标的每个祖先元素，以查看其是否具有事件处理程序。即使未找到，搜索仍然需要时间。 在Microsoft模型中，您必须将事件的cancelBubble属性设置为true。 1window.event.cancelBubble = true 在W3C模型中，您必须调用事件的*stopPropagation()*方法。 1e.stopPropagation() 这将停止事件在冒泡阶段的所有传播。要获得完整的跨浏览器体验，请执行 123456function doSomething(e)&#123; if (!e) var e = window.event; e.cancelBubble = true; if (e.stopPropagation) e.stopPropagation();&#125; 在不支持该功能的浏览器中设置cancelBubble属性不会有任何问题。浏览器耸耸肩并创建属性。当然，它实际上并不能消除冒泡，但是作业本身是安全的。 当前目标 如我们前面所见，事件具有一个target或srcElement，其中包含对该事件发生所在元素的引用。在我们的示例中，这是element2，因为用户单击了它。 非常重要的一点是要理解，在捕获和冒泡阶段（如果有），该目标不会改变：它始终是对element2的引用。 但是，假设我们注册了以下事件处理程序： 12element1.onclick = doSomething;element2.onclick = doSomething; 如果用户单击element2，则doSomething()将执行两次。但是，您如何知道当前正在处理该事件的HTML元素？ target / srcElement不提供任何线索，它们始终引用element2，因为它是事件的原始来源。 为了解决此问题，W3C添加了currentTarget属性。它包含对事件当前正在处理的HTML元素的引用：正是我们所需要的。不幸的是，Microsoft模型不包含类似的属性。 您也可以使用this关键字。在上面的示例中，它引用处理事件的HTML元素，就像currentTarget一样。 Microsoft模式的问题 但是，当您使用Microsoft事件注册模型时，此关键字并不引用HTML元素。加上Microsoft模型中缺少类似于currentTarget的属性，这意味着如果您这样做 12element1.attachEvent(&apos;onclick&apos;,doSomething)element2.attachEvent(&apos;onclick&apos;,doSomething) 您不知道当前哪个HTML元素处理该事件。这是Microsoft事件注册模型中最严重的问题，对我来说，这是一个从不使用它的理由，即使在仅IE / Win的应用程序中也是如此。 我希望微软能尽快添加类似于currentTarget的属性，甚至可以遵循该标准？ Web开发人员需要此信息。 参考 Event Order","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"}]},{"title":"Browser Window 扫盲","slug":"JavaScript/BrowserWindow","date":"2019-09-22T10:56:00.000Z","updated":"2019-09-21T14:18:05.202Z","comments":true,"path":"2019/09/22/JavaScript/BrowserWindow/","link":"","permalink":"https://wzes.github.io/2019/09/22/JavaScript/BrowserWindow/","excerpt":"","text":"前言 作为一个 Node 开发工程师，似乎对于 Window 并不需要关心，但作为一个前端工程师，Window 是个啥子东东，还是需要花时间理一理的。本期看点，深入了解 Window 的 API ～ Window 所有的浏览器都有 Window 对象，每个窗口都会具有一个 Window，通常在浏览器开发者模式中，可以使用 window 拿到这个对象。 1window window 具有很多属性和方法，常见的有 navigator 导航器 screen 显示器 history 历史对象 location 位置对象 document 文档对象 方法 open close setTimeout setInterval … 在浏览器中，我们使用这些对象和方法，完整的用法是 window.xx，但我们可以省略 window，直接使用 xx 即可，对于新手来说可能觉得很奇怪。 复习一下方法调用， Javascript 的方法执行最终都会是以 xx.call(this, args…) 的形式，这里的 this 就是方法的上下文，通常是调用的对象 在浏览器里，如果我们直接使用一个属性或者方法，那么执行这个方法的上下文通常都是 window 对象，所以我们可以直接使用这些对象和方法，因为上下文环境就是 window，最后取的都是 window 的属性和方法。 放一张比较完整的图～ document document 是我们的文档对象，我们可以使用开发者模式直接打印 document，document 打印出来（toString）就是我们的 html，实际上 document 对象也具有很多方法和属性。 createElement 创建元素 12const div = document.createElement(&apos;div&apos;)div.appendChild() getElementById 获取元素 12const div = document.getElementById(&apos;id&apos;)div.appendChild() 利用这些方法创建元素，然后将元素挂载到已有的 dom (app)上，React，Vue 框架最核心的原理不过如此 cookie cookie 对象是 document 的属性，当访问同源的网站是，浏览器会自动帮我们吧 cookie 对象传过去，cookie 对象通常包含了用户信息，服务端可以通过 cookie 判断用户的状态，cookie 默认是持久化保存的 location location 对象即 window 的 location 对象 12document.location == window.location// true URL 返回当前的 url open 与 window 的 open 不同， document 的 open 是操作 document 对象，打开一个 document 的输入流，open 将会清空当前的文档 close 关闭文档流 12345document.open(); document.write(&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;);document.write(&quot;&lt;p&gt;I am a fish&lt;/p&gt;&quot;);document.write(&quot;&lt;p&gt;The number is 42&lt;/p&gt;&quot;); document.close(); 总结 window 对象博大精深～","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"}]},{"title":"koa-bodyparser 源码解析","slug":"JavaScript/koa-bodyparser","date":"2019-09-08T10:56:00.000Z","updated":"2019-09-08T15:31:51.951Z","comments":true,"path":"2019/09/08/JavaScript/koa-bodyparser/","link":"","permalink":"https://wzes.github.io/2019/09/08/JavaScript/koa-bodyparser/","excerpt":"","text":"前言 前面我们已经把【裸配】 Koa 学习了一下，学完了以后好像并没有什么好用的东西，然而这玩意就像一个巨大的平台，容易集成各种小插件，来达到各种各样的功能。接下来我们学习一个 koa-bodyparser 这歌短小精悍的库！ HelloWorld 当我的 hello world 如此简单的时候，我想发一个 POST 请求，那么我怎么拿到 POST 请求的参数呢，我们 ctx.request.body 是空的，Koa 原声的框架并没有帮我们解析 POST 的请求数据。所以我们就需要加入 koa-bodyparser 中间件，这样我们就可以通过 ctx.request.body 拿到数据了。 1234567const Koa = require(&apos;koa&apos;);const app = new Koa();app.use(async ctx =&gt; &#123; // ctx.body = ctx.query.param; console.log( ctx.request.body)&#125;);app.listen(3000); 首先安装这个库： 1npm install koa-bodyparser --save 然后再代码中加入这个中间件： 12345678910111213const Koa = require(&apos;koa&apos;);const bodyParser = require(&apos;koa-bodyparser&apos;)const app = new Koa();app.use(bodyParser());app.use(async ctx =&gt; &#123; ctx.body = ctx.request.body.param; console.log(ctx.request.body)&#125;);app.listen(3000); 这时候 ctx.request.body 便是一个解析好的对象了，直接取对象的属性就可以了 题外话 原声的 NodeJS 通过 createServer 也是没有办法直接取到 post 的参数的，还是需要做一些读取数据的操作才可以 源码解析 bodyParser 作为一个中间件，需要返回一个 async 函数，在这个函数的最后调用 next()，关键部分是 parseBody 函数，将 request 进行解析，并将结果返回赋值给 ctx.request.body 12345678910111213141516return async function bodyParser(ctx, next) &#123; if (ctx.request.body !== undefined) return await next(); if (ctx.disableBodyParser) return await next(); try &#123; const res = await parseBody(ctx); ctx.request.body = &apos;parsed&apos; in res ? res.parsed : &#123;&#125;; if (ctx.request.rawBody === undefined) ctx.request.rawBody = res.raw; &#125; catch (err) &#123; if (onerror) &#123; onerror(err, ctx); &#125; else &#123; throw err; &#125; &#125; await next(); &#125;; parseBody ctx.request.is 可以检查 request 【Content-Type】 请求的类型是否是当中的一个，一般情况下以 form 居多，即 application/x-www-form-urlencoded 123456789101112async function parseBody(ctx) &#123; if (enableJson &amp;&amp; ((detectJSON &amp;&amp; detectJSON(ctx)) || ctx.request.is(jsonTypes))) &#123; return await parse.json(ctx, jsonOpts); &#125; if (enableForm &amp;&amp; ctx.request.is(formTypes)) &#123; return await parse.form(ctx, formOpts); &#125; if (enableText &amp;&amp; ctx.request.is(textTypes)) &#123; return await parse.text(ctx, textOpts) || &apos;&apos;; &#125; return &#123;&#125;; &#125; parse.form 主要是 raw(inflate(req), opts) 方法，将请求的参数转化为一个 string 1234567891011121314151617181920212223242526module.exports = async function(req, opts) &#123; req = req.req || req; opts = utils.clone(opts); const queryString = opts.queryString || &#123;&#125;; // keep compatibility with qs@4 if (queryString.allowDots === undefined) queryString.allowDots = true; // defaults const len = req.headers[&apos;content-length&apos;]; const encoding = req.headers[&apos;content-encoding&apos;] || &apos;identity&apos;; if (len &amp;&amp; encoding === &apos;identity&apos;) opts.length = ~~len; opts.encoding = opts.encoding || &apos;utf8&apos;; opts.limit = opts.limit || &apos;56kb&apos;; opts.qs = opts.qs || qs; const str = await raw(inflate(req), opts); try &#123; const parsed = opts.qs.parse(str, queryString); return opts.returnRawBody ? &#123; parsed, raw: str &#125; : parsed; &#125; catch (err) &#123; err.status = 400; err.body = str; throw err; &#125;&#125;; raw 读取 body 数据， 123456789function getRawBody (stream, options, callback) &#123; return new Promise(function executor (resolve, reject) &#123; readStream(stream, encoding, length, limit, function onRead (err, buf) &#123; if (err) return reject(err) resolve(buf) &#125;) &#125;)&#125; 选取了 onData 函数，可以接受流数据，以字符串形式，结束后直接返回 字符串即可，数据为 buffer，使用 buffer.toString() 就可以转化为字符串。 123456789101112131415161718192021222324252627282930313233343536373839404142434445function readStream (stream, encoding, length, limit, callback) &#123; // attach listeners stream.on(&apos;aborted&apos;, onAborted) stream.on(&apos;close&apos;, cleanup) stream.on(&apos;data&apos;, onData) stream.on(&apos;end&apos;, onEnd) stream.on(&apos;error&apos;, onEnd) function onData (chunk) &#123; if (complete) return received += chunk.length if (limit !== null &amp;&amp; received &gt; limit) &#123; done(createError(413, &apos;request entity too large&apos;, &#123; limit: limit, received: received, type: &apos;entity.too.large&apos; &#125;)) &#125; else if (decoder) &#123; buffer += decoder.write(chunk) &#125; else &#123; buffer.push(chunk) &#125; &#125; function onEnd (err) &#123; if (complete) return if (err) return done(err) if (length !== null &amp;&amp; received !== length) &#123; done(createError(400, &apos;request size did not match content length&apos;, &#123; expected: length, length: length, received: received, type: &apos;request.size.invalid&apos; &#125;)) &#125; else &#123; var string = decoder ? buffer + (decoder.end() || &apos;&apos;) : Buffer.concat(buffer) done(null, string) &#125; &#125;&#125; 在 onEnd 中返回字符串 写在最后 koa-bodyparser 不仅做了 post 的转化，还有一些可选的参数，比如说传输类型，大小限制，这些都是可以通过参数进行配置的。源码博大精深啊！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"},{"name":"Node","slug":"Node","permalink":"https://wzes.github.io/tags/Node/"},{"name":"Koa","slug":"Koa","permalink":"https://wzes.github.io/tags/Koa/"}]},{"title":"JavaScript Array 的 1 个属性，35 个方法","slug":"JavaScript/JavaScript Array","date":"2019-09-01T07:30:16.000Z","updated":"2019-09-07T04:15:12.383Z","comments":true,"path":"2019/09/01/JavaScript/JavaScript Array/","link":"","permalink":"https://wzes.github.io/2019/09/01/JavaScript/JavaScript Array/","excerpt":"","text":"前言 这周呢，彻底学习一下 Array 的所有方法。学习地址 MDN，里面还有各个函数实现的源码！数组作为 JavaScript 的一种特殊的对象类型，与 Number，Boolean，Null，String，Undefined，Symbol 七大数据类型有所不一样。了解 Array 的所有方法，能帮助我们最快找到适合自己的函数。 Create an Array 创建一个数组很简单，直接赋值，或者使用 [] 创建空数组 12var fruits = [&apos;Apple&apos;, &apos;Banana&apos;];console.log(fruits.length); // 2 Properties Array.length 123456var clothing = [&apos;shoes&apos;, &apos;shirts&apos;, &apos;socks&apos;, &apos;sweaters&apos;];console.log(clothing.length);// expected output: 4var array = new Array(2) Methods 首先看一下 Array 的三个静态方法 #####1. Array.from() Array.from() 方法从类似数组或可迭代的对象创建一个新的，浅拷贝的 Array 实例，或者从 {length: 3} 对象中创建固定长度的 undefined 数组 Array.from(arrayLike[, mapFn[, thisArg]]) 12345678console.log(Array.from(&apos;foo&apos;));// expected output: Array [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]console.log(Array.from([1, 2, 3], x =&gt; x + x));// expected output: Array [2, 4, 6]console.log(Array.from(&#123;length: 3&#125;));// expected output: Array [undefined, undefined, undefined] 2. Array.isArray() Array.isArray() 方法确定传递的值是否为 Array，由于 typeof Array = ‘object’ ，所以判断是否是一个数组使用 isArray 才可以 Array.isArray(value) 1234Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray(&apos;foobar&apos;); // falseArray.isArray(undefined); // false 3. Array.of() Array.of() 方法从可变数量的参数创建一个新的Array实例，无论参数的数量或类型如何 注意它与构造函数的不同之处 Array.of(element0[, element1[, …[, elementN]]]) 12345Array.of(7); // [7] Array.of(1, 2, 3); // [1, 2, 3]Array(7); // array of 7 empty slotsArray(1, 2, 3); // [1, 2, 3] 接下来看 Array 的对象方法 4. Array.prototype.concat() concat() 方法用于合并两个或多个数组。 此方法不会更改现有数组，而是返回一个新数组 var new_array = old_array.concat([value1[, value2[, …[, valueN]]]]) 12345var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];var array2 = [&apos;d&apos;, &apos;e&apos;, &apos;f&apos;];console.log(array1.concat(array2));// expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] 5. Array.prototype.copyWithin() copyWithin() 方法浅析将数组的一部分复制到同一数组中的另一个位置，并返回它而不修改其长度 arr.copyWithin(target[, start[, end]]) 123456789var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];// copy to index 0 the element at index 3console.log(array1.copyWithin(0, 3, 4));// expected output: Array [&quot;d&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]// copy to index 1 all elements from index 3 to the endconsole.log(array1.copyWithin(1, 3));// expected output: Array [&quot;d&quot;, &quot;d&quot;, &quot;e&quot;, &quot;d&quot;, &quot;e&quot;] 6. Array.prototype.entries() entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。 array.entries() 1234567891011121314151617181920var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];var iterator1 = array1.entries();console.log(iterator1.next().value);// expected output: Array [0, &quot;a&quot;]console.log(iterator1.next().value);// expected output: Array [1, &quot;b&quot;]// 使用 for of 遍历var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];var iterator = a.entries();for (let e of iterator) &#123; console.log(e);&#125;// [0, &apos;a&apos;]// [1, &apos;b&apos;]// [2, &apos;c&apos;] 7. Array.prototype.every() every() 方法测试数组中的所有元素是否都通过了由提供的函数实现的测试。 它返回一个布尔值 arr.every(callback(element[, index[, array]])[, thisArg]) 12345678function isBelowThreshold(currentValue) &#123; return currentValue &lt; 40;&#125;var array1 = [1, 30, 39, 29, 10, 13];console.log(array1.every(isBelowThreshold));// expected output: true 8. Array.prototype.fill() fill() 方法使用静态值从开始索引（默认为零）到结束索引（默认数组长度）填充（修改）数组的所有元素。 它返回修改后的数组，原数组会改变～ arr.fill(value[, start[, end]]) 123456789101112 var array1 = [1, 2, 3, 4];// fill with 0 from position 2 until position 4console.log(array1.fill(0, 2, 4));// expected output: [1, 2, 0, 0]// fill with 5 from position 1console.log(array1.fill(5, 1));// expected output: [1, 5, 5, 5]console.log(array1.fill(6));// expected output: [6, 6, 6, 6] 9. Array.prototype.filter() filter() 方法创建一个新数组，其中包含所有传递由提供的函数实现的测试的元素 var newArray = arr.filter(callback(element[, index[, array]])[, thisArg]) 123456var words = [&apos;spray&apos;, &apos;limit&apos;, &apos;elite&apos;, &apos;exuberant&apos;, &apos;destruction&apos;, &apos;present&apos;];const result = words.filter(word =&gt; word.length &gt; 6);console.log(result);// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;] 10. Array.prototype.find() find() 方法返回数组中第一个满足提供的测试函数的元素的值。 否则返回undefined arr.find(callback(element[, index[, array]])[, thisArg]) 12345678var array1 = [5, 12, 8, 130, 44];var found = array1.find(function(element) &#123; return element &gt; 10;&#125;);console.log(found);// expected output: 12 11. Array.prototype.findIndex() findIndex() 方法返回数组中第一个满足提供的测试函数的元素的索引。 否则，它返回-1，表示没有元素通过测试 arr.findIndex(callback(element[, index[, array]])[, thisArg]) 1234567var array1 = [5, 12, 8, 130, 44];function isLargeNumber(element) &#123; return element &gt; 13;&#125;console.log(array1.findIndex(isLargeNumber)); 12. Array.prototype.flat() flat() 方法创建一个新数组，所有子数组元素以递归方式连接到指定的深度。 var newArray = arr.flat([depth]); 123456789101112131415var arr1 = [1, 2, [3, 4]];arr1.flat(); // [1, 2, 3, 4]var arr2 = [1, 2, [3, 4, [5, 6]]];arr2.flat();// [1, 2, 3, 4, [5, 6]]var arr3 = [1, 2, [3, 4, [5, 6]]];arr3.flat(2);// [1, 2, 3, 4, 5, 6]var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];arr4.flat(Infinity);// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 13. Array.prototype.flatMap() flatMap() 方法首先使用映射函数映射每个元素，然后将结果展平为新数组。 它与map（）后跟深度为1的flat（）相同，但flatMap（）通常非常有用，因为将两者合并到一个方法中效率稍高 var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) { // return element for new_array }[, thisArg]) 1234567let arr1 = [&quot;it&apos;s Sunny in&quot;, &quot;&quot;, &quot;California&quot;];arr1.map(x =&gt; x.split(&quot; &quot;));// [[&quot;it&apos;s&quot;,&quot;Sunny&quot;,&quot;in&quot;],[&quot;&quot;],[&quot;California&quot;]]arr1.flatMap(x =&gt; x.split(&quot; &quot;));// [&quot;it&apos;s&quot;,&quot;Sunny&quot;,&quot;in&quot;, &quot;&quot;, &quot;California&quot;] 14. Array.prototype.forEach() forEach() 方法为每个数组元素执行一次提供的函数 arr.forEach(callback(currentValue [, index [, array]])[, thisArg]); 123456789var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];array1.forEach(function(element) &#123; console.log(element);&#125;);// expected output: &quot;a&quot;// expected output: &quot;b&quot;// expected output: &quot;c&quot; 15. Array.prototype.includes() includes() 方法确定数组是否在其条目中包含某个值，并在适当时返回true或false arr.includes(valueToFind[, fromIndex]) 123456789101112var array1 = [1, 2, 3];console.log(array1.includes(2));// expected output: truevar pets = [&apos;cat&apos;, &apos;dog&apos;, &apos;bat&apos;];console.log(pets.includes(&apos;cat&apos;));// expected output: trueconsole.log(pets.includes(&apos;at&apos;));// expected output: false 16. Array.prototype.indexOf() indexOf() 方法返回可在数组中找到给定元素的第一个索引，如果不存在则返回-1 arr.indexOf(searchElement[, fromIndex]) 1234567891011var beasts = [&apos;ant&apos;, &apos;bison&apos;, &apos;camel&apos;, &apos;duck&apos;, &apos;bison&apos;];console.log(beasts.indexOf(&apos;bison&apos;));// expected output: 1// start from index 2console.log(beasts.indexOf(&apos;bison&apos;, 2));// expected output: 4console.log(beasts.indexOf(&apos;giraffe&apos;));// expected output: -1 17. Array.prototype.join() join() 方法通过连接数组（或类数组对象）中的所有元素（用逗号或指定的分隔符字符串分隔）来创建并返回一个新字符串。 如果数组只有一个项目，那么将返回该项目而不使用分隔符 arr.join([separator]) 12345678910ar elements = [&apos;Fire&apos;, &apos;Air&apos;, &apos;Water&apos;];console.log(elements.join());// expected output: &quot;Fire,Air,Water&quot;console.log(elements.join(&apos;&apos;));// expected output: &quot;FireAirWater&quot;console.log(elements.join(&apos;-&apos;));// expected output: &quot;Fire-Air-Water&quot; 18. Array.prototype.keys() keys() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键 123456var array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];var iterator = array1.keys(); for (let key of iterator) &#123; console.log(key); // expected output: 0 1 2&#125; 19. Array.prototype.lastIndexOf() lastIndexOf() 方法返回可在数组中找到给定元素的最后一个索引，如果不存在则返回-1。 从fromIndex开始向后搜索数组 arr.lastIndexOf(searchElement[, fromIndex]) 1234567var animals = [&apos;Dodo&apos;, &apos;Tiger&apos;, &apos;Penguin&apos;, &apos;Dodo&apos;];console.log(animals.lastIndexOf(&apos;Dodo&apos;));// expected output: 3console.log(animals.lastIndexOf(&apos;Penguin&apos;, 1));// expected output: -1 20. Array.prototype.map() map() 方法创建一个新数组，其结果是在调用数组中的每个元素上调用提供的函数 var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg]) 1234567var array1 = [1, 4, 9, 16];// pass a function to mapconst map1 = array1.map(x =&gt; x * 2);console.log(map1);// expected output: Array [2, 8, 18, 32] 21. Array.prototype.pop() pop() 方法从数组中删除最后一个元素并返回该元素。 此方法更改数组的长度。 arr.pop() 123456789101112var plants = [&apos;broccoli&apos;, &apos;cauliflower&apos;, &apos;cabbage&apos;, &apos;kale&apos;, &apos;tomato&apos;];console.log(plants.pop());// expected output: &quot;tomato&quot;console.log(plants);// expected output: Array [&quot;broccoli&quot;, &quot;cauliflower&quot;, &quot;cabbage&quot;, &quot;kale&quot;]plants.pop();console.log(plants);// expected output: Array [&quot;broccoli&quot;, &quot;cauliflower&quot;, &quot;cabbage&quot;] 22. Array.prototype.push() push() 方法将一个或多个元素添加到数组的末尾，并返回数组的新长度 arr.push(element1[, …[, elementN]]) 123456789101112var animals = [&apos;pigs&apos;, &apos;goats&apos;, &apos;sheep&apos;];console.log(animals.push(&apos;cows&apos;));// expected output: 4console.log(animals);// expected output: Array [&quot;pigs&quot;, &quot;goats&quot;, &quot;sheep&quot;, &quot;cows&quot;]animals.push(&apos;chickens&apos;);console.log(animals);// expected output: Array [&quot;pigs&quot;, &quot;goats&quot;, &quot;sheep&quot;, &quot;cows&quot;, &quot;chickens&quot;] 23. Array.prototype.reduce() reduce() 方法在数组的每个元素上执行reducer函数（您提供），从而产生单个输出值 arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) 12345678910const array1 = [1, 2, 3, 4];const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;// 1 + 2 + 3 + 4console.log(array1.reduce(reducer));// expected output: 10// 5 + 1 + 2 + 3 + 4console.log(array1.reduce(reducer, 5));// expected output: 15 24. Array.prototype.reduceRight() reduceRight() 方法对累加器和数组的每个值（从右到左）应用函数以将其减少为单个值 arr.reduceRight(callback(accumulator, currentValue[, index[, array]])[, initialValue]) 123456const array1 = [[0, 1], [2, 3], [4, 5]].reduceRight( (accumulator, currentValue) =&gt; accumulator.concat(currentValue));console.log(array1);// expected output: Array [4, 5, 2, 3, 0, 1] 25. Array.prototype.reverse() reverse() 方法将数组反转到位。 第一个数组元素成为最后一个，最后一个数组元素成为第一个 a.reverse() 123456789101112var array1 = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;];console.log(&apos;array1: &apos;, array1);// expected output: Array [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]var reversed = array1.reverse(); console.log(&apos;reversed: &apos;, reversed);// expected output: Array [&apos;three&apos;, &apos;two&apos;, &apos;one&apos;]/* Careful: reverse is destructive. It also changesthe original array */ console.log(&apos;array1: &apos;, array1);// expected output: Array [&apos;three&apos;, &apos;two&apos;, &apos;one&apos;] 26. Array.prototype.shift() shift() 方法从数组中删除第一个元素并返回已删除的元素。 此方法更改数组的长度 arr.shift() 123456789var array1 = [1, 2, 3];var firstElement = array1.shift();console.log(array1);// expected output: Array [2, 3]console.log(firstElement);// expected output: 1 27. Array.prototype.slice() slice() 方法将数组的一部分的浅表副本返回到从头到尾选择的新数组对象（不包括结尾），其中begin和end表示该数组中项的索引。 原始数组不会被修改 arr.slice([begin[, end]]) 12345678910var animals = [&apos;ant&apos;, &apos;bison&apos;, &apos;camel&apos;, &apos;duck&apos;, &apos;elephant&apos;];console.log(animals.slice(2));// expected output: Array [&quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]console.log(animals.slice(2, 4));// expected output: Array [&quot;camel&quot;, &quot;duck&quot;]console.log(animals.slice(1, 5));// expected output: Array [&quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;] 28. # Array.prototype.some() some() 方法测试数组中是否至少有一个元素通过了由提供的函数实现的测试。 它返回一个布尔值 arr.some(callback(element[, index[, array]])[, thisArg]) 123456789var array = [1, 2, 3, 4, 5];var even = function(element) &#123; // checks whether an element is even return element % 2 === 0;&#125;;console.log(array.some(even));// expected output: true 29. Array.prototype.sort() sort() 方法对数组中的元素进行排序并返回已排序的数组。 默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的。 由于取决于实现，因此无法保证排序的时间和空间复杂性。 arr.sort([compareFunction]) 123456789var months = [&apos;March&apos;, &apos;Jan&apos;, &apos;Feb&apos;, &apos;Dec&apos;];months.sort();console.log(months);// expected output: Array [&quot;Dec&quot;, &quot;Feb&quot;, &quot;Jan&quot;, &quot;March&quot;]var array1 = [1, 30, 4, 21, 100000];array1.sort();console.log(array1);// expected output: Array [1, 100000, 21, 30, 4] 30. Array.prototype.splice() splice() 方法通过删除或替换现有元素和/或在适当位置添加新元素来更改数组的内容 var arrDeletedItems = array.splice(start[, deleteCount[, item1[, item2[, …]]]]) 12345678910var months = [&apos;Jan&apos;, &apos;March&apos;, &apos;April&apos;, &apos;June&apos;];months.splice(1, 0, &apos;Feb&apos;);// inserts at index 1console.log(months);// expected output: Array [&apos;Jan&apos;, &apos;Feb&apos;, &apos;March&apos;, &apos;April&apos;, &apos;June&apos;]months.splice(4, 1, &apos;May&apos;);// replaces 1 element at index 4console.log(months);// expected output: Array [&apos;Jan&apos;, &apos;Feb&apos;, &apos;March&apos;, &apos;April&apos;, &apos;May&apos;] 31. Array.prototype.unshift() unshift() 方法将一个或多个元素添加到数组的开头并返回数组的新长度 arr.unshift(element1[, …[, elementN]]) 1234567var array1 = [1, 2, 3];console.log(array1.unshift(4, 5));// expected output: 5console.log(array1);// expected output: Array [4, 5, 1, 2, 3] 32. Array.prototype.values() values() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的值 arr.values() 123456const array1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];const iterator = array1.values();for (const value of iterator) &#123; console.log(value); // expected output: &quot;a&quot; &quot;b&quot; &quot;c&quot;&#125; 33. Array.prototype.toLocaleString() toLocaleString() 方法返回表示数组元素的字符串。 使用toLocaleString方法将元素转换为字符串，并且这些字符串由特定于语言环境的字符串（例如逗号“，”）分隔 arr.toLocaleString([locales[, options]]); 123456var array1 = [1, &apos;a&apos;, new Date(&apos;21 Dec 1997 14:12:00 UTC&apos;)];var localeString = array1.toLocaleString(&apos;en&apos;, &#123;timeZone: &quot;UTC&quot;&#125;);console.log(localeString);// expected output: &quot;1,a,12/21/1997, 2:12:00 PM&quot;,// This assumes &quot;en&quot; locale and UTC timezone - your results may vary 34. Array.prototype.toString() toString() 方法返回表示指定数组及其元素的字符串 arr.toString() 1234var array1 = [1, 2, &apos;a&apos;, &apos;1a&apos;];console.log(array1.toString());// expected output: &quot;1,2,a,1a&quot; 35. Array.prototype@@iterator @@iterator 属性的初始值与values（）属性的初始值是相同的函数对象。 arrSymbol.iterator 12345678var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];var eArr = arr[Symbol.iterator]();// your browser must support for..of loop// and let-scoped variables in for loops// const and var could also be usedfor (let letter of eArr) &#123; console.log(letter);&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"},{"name":"Array","slug":"Array","permalink":"https://wzes.github.io/tags/Array/"}]},{"title":"React Redux v0.2.1 源码学习","slug":"JavaScript/Redux V0.2.1","date":"2019-08-25T11:30:16.000Z","updated":"2019-09-02T12:16:07.731Z","comments":true,"path":"2019/08/25/JavaScript/Redux V0.2.1/","link":"","permalink":"https://wzes.github.io/2019/08/25/JavaScript/Redux V0.2.1/","excerpt":"","text":"前言 这周突然想学习一下状态管理的写法。看看业界是怎么实现的，之前使用过 redux，那就先从 redux 下手吧，但是，一上来就看最新版本的代码，不太适合新手学习，一方面最新版本已经发展n多年了，功能已经非常完善（代码多难懂），另一方面直接看最新的不了解这个工具是怎么设计出来的。于是就打算学习最早的发布版本 v0.2.1 先来说下我认识的一般的状态管理的基本路子： 全局只存在 唯一state，而前端不直接改变 state，而是通过 action 去改变 state HelloWorld 一个计数器的栗子，目录结构如下： 123456789101112counter├── App.js├── Counter.js├── actions│ ├── CounterActions.js│ └── index.js├── constants│ └── ActionTypes.js├── dispatcher.js└── stores ├── CounterStore.js └── index.js actions 函数，返回一个带 type 的对象，或者返回一个函数 123456789101112131415161718192021222324import &#123; INCREMENT_COUNTER, DECREMENT_COUNTER&#125; from &apos;../constants/ActionTypes&apos;;export function increment() &#123; return &#123; type: INCREMENT_COUNTER &#125;;&#125;export function incrementAsync() &#123; return dispatch =&gt; &#123; setTimeout(() =&gt; &#123; dispatch(increment()); &#125;, 1000); &#125;;&#125;export function decrement() &#123; return &#123; type: DECREMENT_COUNTER &#125;;&#125; store 返回一个函数，参数 state 和 action，当 state 为空时返回初始值，表示初始化。根据 action 的 type 值，进行相应的做法，返回一个新的 state。 1234567891011121314151617181920212223242526272829import &#123; INCREMENT_COUNTER, DECREMENT_COUNTER&#125; from &apos;../constants/ActionTypes&apos;;const initialState = &#123; counter: 0 &#125;;function incremenent(&#123; counter &#125;) &#123; return &#123; counter: counter + 1 &#125;;&#125;function decremenent(&#123; counter &#125;) &#123; return &#123; counter: counter - 1 &#125;;&#125;export default function CounterStore(state, action) &#123; if (!state) &#123; return initialState; &#125; switch (action.type) &#123; case INCREMENT_COUNTER: return incremenent(state, action); case DECREMENT_COUNTER: return decremenent(state, action); default: return state; &#125;&#125; 入口 App.js 你会发现 @provides(dispatcher) 这个奇怪的东西，在 React 里面还经常出现，装饰器。 12345678910111213import React, &#123; Component &#125; from &apos;react&apos;;import Counter from &apos;./Counter&apos;;import &#123; provides &#125; from &apos;redux&apos;;import dispatcher from &apos;./dispatcher&apos;;@provides(dispatcher)export default class App extends Component &#123; render() &#123; return ( &lt;Counter /&gt; ); &#125;&#125; Couter.js，同样，也出现 performs（方法），observes（观察者）等关键字。使用 state 直接使用 this.props 解构赋值即可。 12345678910111213141516171819import React from &apos;react&apos;;import &#123; performs, observes &#125; from &apos;redux&apos;;@performs(&apos;increment&apos;, &apos;decrement&apos;)@observes(&apos;CounterStore&apos;)export default class Counter &#123; render() &#123; const &#123; increment, decrement &#125; = this.props; return ( &lt;p&gt; Clicked: &#123;this.props.counter&#125; times &#123;&apos; &apos;&#125; &lt;button onClick=&#123;() =&gt; increment()&#125;&gt;+&lt;/button&gt; &#123;&apos; &apos;&#125; &lt;button onClick=&#123;() =&gt; decrement()&#125;&gt;-&lt;/button&gt; &lt;/p&gt; ); &#125;&#125; 这些关键字是早起 Redux 状态管理的关键，现在的版本应该已经不使用这种方式了。 解析 dispatcher 通过 provides 将 dispatcher 注入到 App 中，其中，dispatcher 是通过 createDispatcher 创建，并调用了 dispatcher.receive(stores, actions) 进行绑定。 123456789101112131415import * as stores from &apos;./stores/index&apos;;import * as actions from &apos;./actions/index&apos;;import &#123; createDispatcher &#125; from &apos;redux&apos;;const dispatcher = module.hot &amp;&amp; module.hot.data &amp;&amp; module.hot.data.dispatcher || createDispatcher();dispatcher.receive(stores, actions);module.hot.dispose(data =&gt; &#123; data.dispatcher = dispatcher;&#125;);export default dispatcher; receive 方法，actionCreator 将 action 进行封装， 123456789101112131415161718// Provide a way to receive new stores and actions function receive(nextStores, nextActionCreators) &#123; stores = nextStores; actionCreators = mapValues(nextActionCreators, wrapActionCreator); // Merge the observers observers = mapValues(stores, (store, key) =&gt; observers[key] || [] ); // Dispatch to initialize stores if (currentTransaction) &#123; updateState(committedState); currentTransaction.forEach(dispatch); &#125; else &#123; dispatch(BOOTSTRAP_STORE); &#125; &#125; action 进行转化返回一个 dispatchAction 函数，如果 action 为函数，则先执行函数，把 dispatchInTransaction 作为参数传入，这样可以在 action 内部使用该函数了，否则使用 dispatchInTransaction 函数调用。 12345678910111213// Bind action creator to the dispatcher function wrapActionCreator(actionCreator) &#123; return function dispatchAction(...args) &#123; const action = actionCreator(...args); if (typeof action === &apos;function&apos;) &#123; // Async action creator action(dispatchInTransaction); &#125; else &#123; // Sync action creator dispatchInTransaction(action); &#125; &#125;; &#125; dispatchInTransaction ，执行 dispatch ，计算 nextState，执行 updateState 更新。 1234567891011121314151617 // Dispatch in the context of current transaction function dispatchInTransaction(action) &#123; if (currentTransaction) &#123; currentTransaction.push(action); &#125; dispatch(action); &#125;// Reassign the current state on each dispatch function dispatch(action) &#123; if (typeof action.type !== &apos;string&apos;) &#123; throw new Error(&apos;Action type must be a string.&apos;); &#125; const nextState = computeNextState(currentState, action); updateState(nextState); &#125; 获取 store，也就是 CounterStore，把参数传入，获取新的 state 123456// To compute the next state, combine the next states of every storefunction computeNextState(state, action) &#123; return mapValues(stores, (store, key) =&gt; store(state[key], action) );&#125; updateState 实现，计算变化的 changedKeys，执行 emitChange 进行更新。 123456789101112// Update state and emit change if neededfunction updateState(nextState) &#123; // Swap the state const previousState = currentState; currentState = nextState; // Notify the observers const changedKeys = Object.keys(currentState).filter(key =&gt; currentState[key] !== previousState[key] ); emitChange(changedKeys);&#125; emitChange，获取需要通知的 observers，调用通知函数。 12345678910111213141516171819// Notify observers about the changed stores function emitChange(changedKeys) &#123; if (!changedKeys.length) &#123; return; &#125; // Gather the affected observers const notifyObservers = []; changedKeys.forEach(key =&gt; &#123; observers[key].forEach(o =&gt; &#123; if (notifyObservers.indexOf(o) === -1) &#123; notifyObservers.push(o); &#125; &#125;); &#125;); // Emit change notifyObservers.forEach(o =&gt; o()); &#125; 这里可能有点疑问，obersevers 是什么，从哪来？往下看～ observes.js 将 组件进行装饰，构造函数中有一个 this.unobserve = this.context.observeStores(storeKeys, this.handleChange); context 就是 dispatcher， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;import pick from &apos;lodash/object/pick&apos;;import identity from &apos;lodash/utility/identity&apos;;const contextTypes = &#123; observeStores: PropTypes.func.isRequired&#125;;export default function connect(...storeKeys) &#123; let mapState = identity; // Last argument may be a custom mapState function const lastIndex = storeKeys.length - 1; if (typeof storeKeys[lastIndex] === &apos;function&apos;) &#123; [mapState] = storeKeys.splice(lastIndex, 1); &#125; return function (DecoratedComponent) &#123; const wrappedDisplayName = DecoratedComponent.displayName || DecoratedComponent.name || &apos;Component&apos;; return class extends Component &#123; static displayName = `ReduxObserves($&#123;wrappedDisplayName&#125;)`; static contextTypes = contextTypes; constructor(props, context) &#123; super(props, context); this.handleChange = this.handleChange.bind(this); this.unobserve = this.context.observeStores(storeKeys, this.handleChange); &#125; .... componentWillUnmount() &#123; this.unobserve(); &#125; render() &#123; return ( &lt;DecoratedComponent &#123;...this.props&#125; &#123;...this.state&#125; /&gt; ); &#125; &#125;; &#125;;&#125; dispatcher observeStores 方法，将需要监听的组件传入，以及 onChange 函数，作为回调使用。最后返回一个函数，移除监听，这个也太妙了吧。 1234567891011121314151617181920212223// Provide subscription and unsubscription function observeStores(observedKeys, onChange) &#123; // Emit the state update function handleChange() &#123; onChange(currentState); &#125; // Synchronously emit the initial value handleChange(); // Register the observer for each relevant key observedKeys.forEach(key =&gt; observers[key].push(handleChange) ); // Let it unregister when the time comes return () =&gt; &#123; observedKeys.forEach(key =&gt; &#123; const index = observers[key].indexOf(handleChange); observers[key].splice(index, 1); &#125;); &#125;; &#125; 当计算好 nextState 后，就会调用 observe 的 onChange 方法， onChange 方法也就是 装饰器里面的方法。最后调用自身的 updateState，使用 setState 进行组件更新。而这些 state 作为 props 传入了我们自己的组件，也就可以通过 this.props 拿到。完美～～～ 1234567891011121314151617181920212223handleChange(stateFromStores) &#123; this.currentStateFromStores = pick(stateFromStores, storeKeys); this.updateState(stateFromStores, this.props);&#125;componentWillReceiveProps(nextProps) &#123; this.updateState(this.currentStateFromStores, nextProps);&#125;updateState(stateFromStores, props) &#123; if (storeKeys.length === 1) &#123; // Just give it the particular store state for convenience stateFromStores = stateFromStores[storeKeys[0]]; &#125; const state = mapState(stateFromStores, props); if (this.state) &#123; this.setState(state); &#125; else &#123; this.state = state; &#125;&#125; performs 组件 action 绑定到组件，可以通过 this.props ，通过 this.context.getActions() 拿到 actions 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;import pick from &apos;lodash/object/pick&apos;;import identity from &apos;lodash/utility/identity&apos;;const contextTypes = &#123; getActions: PropTypes.func.isRequired&#125;;export default function performs(...actionKeys) &#123; let mapActions = identity; // Last argument may be a custom mapState function const lastIndex = actionKeys.length - 1; if (typeof actionKeys[lastIndex] === &apos;function&apos;) &#123; [mapActions] = actionKeys.splice(lastIndex, 1); &#125; return function (DecoratedComponent) &#123; const wrappedDisplayName = DecoratedComponent.displayName || DecoratedComponent.name || &apos;Component&apos;; return class extends Component &#123; static displayName = `ReduxPerforms($&#123;wrappedDisplayName&#125;)`; static contextTypes = contextTypes; constructor(props, context) &#123; super(props, context); this.updateActions(props); &#125; componentWillReceiveProps(nextProps) &#123; this.updateActions(nextProps); &#125; updateActions(props) &#123; this.actions = mapActions( pick(this.context.getActions(), actionKeys), props ); &#125; render() &#123; return ( &lt;DecoratedComponent &#123;...this.props&#125; &#123;...this.actions&#125; /&gt; ); &#125; &#125;; &#125;;&#125; 到这里就差不多了～ 额外收获 Lodash pick 12345var object = &#123; &apos;user&apos;: &apos;fred&apos;, &apos;age&apos;: 40 &#125;;_.pick(object, &apos;user&apos;);// =&gt; &#123; &apos;user&apos;: &apos;fred&apos; &#125;_.pick(object, _.isString);// =&gt; &#123; &apos;user&apos;: &apos;fred&apos; &#125; identity 123function identity(value) &#123; return value;&#125; mapValues 1234_.mapValues(&#123; &apos;a&apos;: 1, &apos;b&apos;: 2 &#125;, function(n) &#123; return n * 3;&#125;);// =&gt; &#123; &apos;a&apos;: 3, &apos;b&apos;: 6 &#125; 最后 麻雀虽小，却能看透精髓～","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://wzes.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://wzes.github.io/tags/Redux/"}]},{"title":"Node KoaJs 源码解析","slug":"JavaScript/KoaJs","date":"2019-08-18T10:56:00.000Z","updated":"2019-09-02T12:15:48.563Z","comments":true,"path":"2019/08/18/JavaScript/KoaJs/","link":"","permalink":"https://wzes.github.io/2019/08/18/JavaScript/KoaJs/","excerpt":"","text":"前言 又是一周过去了，常规学习不能断！但是选择什么主题呢？一时间不知道选什么好，于是又想起简单的 koajs 非常愉快的就选择他了 https://koajs.com/，了解一下？ 他是个什么东西呢？ Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。 hello world 首先新建一个 node 项目，其实很简单，只需要一个 package.json 文件， 12345678910111213141516&#123; &quot;name&quot;: &quot;koa-hello&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;node src/index.js&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;koa&quot;: &quot;^2.7.0&quot; &#125;&#125; 然后执行 1npm i koa 代码 index.js 文件，新建一个 koa 实例，使用 app.use 写一个 async 方法，设置 ctx.body 的值就可以了。最后使用 app.listen 启动。 12345678const Koa = require(&apos;koa&apos;);const app = new Koa();app.use(async ctx =&gt; &#123; ctx.body = &apos;Hello World&apos;;&#125;);app.listen(3000); 这样的话，一个 web 服务器就搭建好了，访问 http://localhost:3000/ 就会得到 hello world 返回结果了。你可以尝试更改字段从而得到不同的返回结果。 源码解析 koa 的源码只有四个文件，不包含其他引用的话 12345678910 .├── History.md├── LICENSE├── Readme.md├── lib│ ├── application.js│ ├── context.js│ ├── request.js│ └── response.js└── package.json 主入口可以在 package.json 的 main 中得到，是 application.js，暂时先知道 middleware 是中间接，通常一个请求过来就会依次执行中间件的方法。 构造函数 12345678910111213141516171819202122module.exports = class Application extends Emitter &#123; /** * Initialize a new `Application`. * * @api public */ constructor() &#123; super(); this.proxy = false; this.middleware = []; this.subdomainOffset = 2; this.env = process.env.NODE_ENV || &apos;development&apos;; this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); if (util.inspect.custom) &#123; this[util.inspect.custom] = this.inspect; &#125; &#125;&#125; app.use 其实就是添加一个中间件，我们通常使用 async 的函数，generator 被抛弃了！ 123456789101112use(fn) &#123; if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;middleware must be a function!&apos;); if (isGeneratorFunction(fn)) &#123; deprecate(&apos;Support for generators will be removed in v3. &apos; + &apos;See the documentation for examples of how to convert old middleware &apos; + &apos;https://github.com/koajs/koa/blob/master/docs/migration.md&apos;); fn = convert(fn); &#125; debug(&apos;use %s&apos;, fn._name || fn.name || &apos;-&apos;); this.middleware.push(fn); return this;&#125; app.listen 创建一个服务器，监听 3000 端口，http.createServer 是 node 的服务器。 12345listen(...args) &#123; debug(&apos;listen&apos;); const server = http.createServer(this.callback()); return server.listen(...args);&#125; callback 是提供一个函数，所有请求都会走到这个函数里面进行处理。每次请求过来都会调用这个函数，所以，我们可以看到，每次请求都会创建一个 ctx 的对象。 compose 的作用就是将所有的中间件整合成一个函数，使用 next 函数继续调用下一个函数。 123456789101112callback() &#123; const fn = compose(this.middleware); if (!this.listenerCount(&apos;error&apos;)) this.on(&apos;error&apos;, this.onerror); const handleRequest = (req, res) =&gt; &#123; const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn); &#125;; return handleRequest;&#125; 初始化 ctx 对象，这里 this.request 将会把原生的 request 参数进行解析，方便我们进行相关参数获取。 1234567891011121314151617181920/** * Initialize a new context. * * @api private */createContext(req, res) &#123; const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.state = &#123;&#125;; return context;&#125; 比如我们之后就可以使用 ** ctx.query.key ** 来获取 http://localhost:3000?key=value，为什么可以使用 ctx.query 又可以获取参数呢，这个要靠 Object.create 的本事了，它相当于创造了一个对象，继承了原来的对象，而 this.request 有 query 的参数，而最为重要的是 this.context = Object.create(context); context 委托（使用了 Delegator）了这些 request 的相关属性和方法。【第一次体会到 js 委托，以前知识听说不知道是啥】 12345678910/** * Request delegation. */delegate(proto, &apos;request&apos;) .access(&apos;method&apos;) .access(&apos;query&apos;) .access(&apos;path&apos;) .access(&apos;url&apos;) ....... // 省略 handleRequest 请求处理，fnMiddleware 就是所有的中间件， 12345678handleRequest(ctx, fnMiddleware) &#123; const res = ctx.res; res.statusCode = 404; const onerror = err =&gt; ctx.onerror(err); const handleResponse = () =&gt; respond(ctx); onFinished(res, onerror); return fnMiddleware(ctx).then(handleResponse).catch(onerror);&#125; 调用完中间件以后，就执行 handleResponse 将数据返回，返回数据也就是将 ctx.body 拿出来，使用 response.end 返回数据，返回时，会对数据进行处理，在最后面可以体会到～ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Response helper. */function respond(ctx) &#123; // allow bypassing koa if (false === ctx.respond) return; if (!ctx.writable) return; const res = ctx.res; let body = ctx.body; const code = ctx.status; // ignore body if (statuses.empty[code]) &#123; // strip headers ctx.body = null; return res.end(); &#125; if (&apos;HEAD&apos; == ctx.method) &#123; if (!res.headersSent &amp;&amp; isJSON(body)) &#123; ctx.length = Buffer.byteLength(JSON.stringify(body)); &#125; return res.end(); &#125; // status body if (null == body) &#123; if (ctx.req.httpVersionMajor &gt;= 2) &#123; body = String(code); &#125; else &#123; body = ctx.message || String(code); &#125; if (!res.headersSent) &#123; ctx.type = &apos;text&apos;; ctx.length = Buffer.byteLength(body); &#125; return res.end(body); &#125; // responses if (Buffer.isBuffer(body)) return res.end(body); if (&apos;string&apos; == typeof body) return res.end(body); if (body instanceof Stream) return body.pipe(res); // body: json body = JSON.stringify(body); if (!res.headersSent) &#123; ctx.length = Buffer.byteLength(body); &#125; res.end(body);&#125; 到这里，基本的请求已经清楚了～～ End 再来看一眼最简单的 http server 代码，对比一下，比 koa 代码的 hello world 相比并没有多复杂 123456var http = require(&apos;http&apos;);http.createServer(function (req, res) &#123; res.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); res.write(&apos;Hello World!&apos;); res.end();&#125;).listen(8080); 但是，获取参数，使用路由等等插件，koa 生态做了很多，非常方便，快来体验吧！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"},{"name":"Node","slug":"Node","permalink":"https://wzes.github.io/tags/Node/"},{"name":"Koa","slug":"Koa","permalink":"https://wzes.github.io/tags/Koa/"}]},{"title":"Android 一个滑动组件的原理浅析","slug":"Android/一个滑动组件的原理浅析","date":"2019-08-11T06:47:16.000Z","updated":"2019-09-02T12:19:37.016Z","comments":true,"path":"2019/08/11/Android/一个滑动组件的原理浅析/","link":"","permalink":"https://wzes.github.io/2019/08/11/Android/一个滑动组件的原理浅析/","excerpt":"","text":"前言 一个好的滑动不止能够响应手指的移动，而且还能响应 Fling（抛） 事件，响应手指的移动比较简单，手指移动多少距离，布局就移动多少距离；当快速滑动时，手指离开后，不能马上停止滑动，而是应该计算手指的移动速度，产生一个【抛】（Fling ）的动作，让内容继续滚动一段距离。这才是好的滑动组件。那么其中具体的设计究竟是如何呢，今天就来分析一波，借鉴 Android OverScroller 的实现。 Demo 12345678if (mOverScroller.computeScrollOffset()) &#123; // 获取 scrollY int y = mOverScroller.getCurrY(); // 此处省略一堆控制滚动的代码 ..... // 更新 postInvalidate();&#125; 解析 总体逻辑先梳理下，首先内容跟随手指移动而【移动】，手指离开时产生一个 【速度】，根据这个速度计算一个，此次滑动的【总时间】和【总距离】，之后可以计算每一个【时刻】对应的【位置】。那其中时刻与距离的对应关系是如何呢？看了一下 Android 的源码，计算关系之复杂，惨绝人寰，欲研又止！但这不重要，重要的是掌握全局。 一起来欣赏一下代码吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * Update the current position and velocity for current time. Returns * true if update has been done and false if animation duration has been * reached. */ boolean update() &#123; final long time = AnimationUtils.currentAnimationTimeMillis(); final long currentTime = time - mStartTime; if (currentTime == 0) &#123; // Skip work but report that we&apos;re still going if we have a nonzero duration. return mDuration &gt; 0; &#125; if (currentTime &gt; mDuration) &#123; return false; &#125; double distance = 0.0; switch (mState) &#123; case SPLINE: &#123; final float t = (float) currentTime / mSplineDuration; final int index = (int) (NB_SAMPLES * t); float distanceCoef = 1.f; float velocityCoef = 0.f; if (index &lt; NB_SAMPLES) &#123; final float t_inf = (float) index / NB_SAMPLES; final float t_sup = (float) (index + 1) / NB_SAMPLES; final float d_inf = SPLINE_POSITION[index]; final float d_sup = SPLINE_POSITION[index + 1]; velocityCoef = (d_sup - d_inf) / (t_sup - t_inf); distanceCoef = d_inf + (t - t_inf) * velocityCoef; &#125; distance = distanceCoef * mSplineDistance; mCurrVelocity = velocityCoef * mSplineDistance / mSplineDuration * 1000.0f; break; &#125; case BALLISTIC: &#123; final float t = currentTime / 1000.0f; mCurrVelocity = mVelocity + mDeceleration * t; distance = mVelocity * t + mDeceleration * t * t / 2.0f; break; &#125; ..... &#125; mCurrentPosition = mStart + (int) Math.round(distance); return true; &#125; mCurrentPosition 就是某个时刻对应的位置，有趣的是 BALLISTIC 模式，还记得高中物理的重力加速度时间与距离的公式吗？是不是似曾相识？这算比较简单的公式，但我们今天但主角是 SPLINE 模式，ScrollView 但滑动正是使用了这个模式进行滑动，体验非常好！！！！公式有点复杂，就不洗洗研究了，喜欢的同学自行研究吧 总结 简单一个滚动，蕴藏的道理生不可测，一不小心就出现了物理知识点…学习还是挺有用的吧","categories":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/tags/Android/"}]},{"title":"JavaScript Babel-Loader 自定义入门","slug":"JavaScript/Babel Loader","date":"2019-08-04T05:42:00.000Z","updated":"2019-09-02T12:14:06.673Z","comments":true,"path":"2019/08/04/JavaScript/Babel Loader/","link":"","permalink":"https://wzes.github.io/2019/08/04/JavaScript/Babel Loader/","excerpt":"","text":"前言 突然觉得 babel-loader https://github.com/babel/babel-loader 很好玩，比较贴近AST，然而编译原理一直是噩梦，没学懂，好在这东西不需要什么编译原理的知识。但还是涉及到语法解析等操作，所以拿过来学一学还是挺好的。 什么是 Babel Babel 是一个工具链，主要用于将 ECMAScript 2015+ 代码转换为当前和旧版浏览器或环境中的向后兼容版本的 JavaScript。 以下是 Babel 可以为您做的主要事情： 转换语法 目标环境中缺少Polyfill功能（通过@ babel / polyfill）源代码转换（codemods） 更多 1234567// Babel Input: ES2015 arrow function[1, 2, 3].map((n) =&gt; n + 1);// Babel Output: ES5 equivalent[1, 2, 3].map(function(n) &#123; return n + 1;&#125;); 代码转化就涉及到了语法解析，这便是我们的重点 自定义 首先新建一个项目 webpack 项目 babel-demo 目录结构如下 1234567891011.├── README.md├── babel-plugin-transform-class│ └── index.js├── dist│ └── bundle.js├── package-lock.json├── package.json├── src│ └── index.js└── webpack.config.js 新建 package.json 并使用 npm install 安装所需插件 1npm install -D babel-loader @babel/core @babel/preset-env webpack package.json 123456789101112&#123; &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot; &#125;, &quot;dependencies&quot;: &#123;&#125;, &quot;devDependencies&quot;: &#123; &quot;@babel/core&quot;: &quot;^7.5.5&quot;, &quot;@babel/preset-env&quot;: &quot;^7.5.5&quot;, &quot;babel-loader&quot;: &quot;^8.0.6&quot;, &quot;webpack&quot;: &quot;^4.39.1&quot; &#125;&#125; 新建 webpack 文件 1234567891011121314151617181920212223var path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./src/index.js&apos;, mode: &apos;development&apos;, output: &#123; path: path.join(__dirname, &apos;dist&apos;), filename: &apos;bundle.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, loader: &apos;babel-loader&apos;, options: &#123; plugins: [ &quot;transform-class&quot; ] &#125; &#125; ] &#125;&#125; module 里面的 rule 便是配置我们自定义的 babel 插件，transform-class 是插件名。 手写插件 下面是一个简单的插件 babel-plugin-transform-class/index.js 1234567891011// A plugin is just a functionmodule.exports = function (&#123; types: t &#125;) &#123; return &#123; visitor: &#123; Identifier(path) &#123; let name = path.node.name; // reverse the name: JavaScript -&gt; tpircSavaJ path.node.name = name.split(&apos;&apos;).reverse().join(&apos;&apos;); &#125; &#125; &#125;;&#125; 将 babel-plugin-transform-class 文件夹移动到 node-modules 目录下即可。当运行 webpack 的时候，便会运行这个插件，这个插件会把 node 的 name 做反转。 我们的 demo 1234function babel() &#123; let javascript = &apos;hello babel&apos;; console.log(javascript);&#125; 打包后 1eval(&quot;function lebab() &#123;\\n let tpircsavaj = &apos;hello babel&apos;;\\n elosnoc.gol(tpircsavaj);\\n&#125;\\n\\n//# sourceURL=webpack:///./src/index.js?&quot;); 我们看到变量名都反转了。 我们还可以实现更多·····更多属性，方法在这里 https://babeljs.io/docs/en/next/babel-types.html 参考 AST https://astexplorer.net/","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"},{"name":"Babel","slug":"Babel","permalink":"https://wzes.github.io/tags/Babel/"},{"name":"Node","slug":"Node","permalink":"https://wzes.github.io/tags/Node/"}]},{"title":"React Lazyload 源码解析","slug":"JavaScript/React Lazyload","date":"2019-07-28T03:59:00.000Z","updated":"2019-09-02T12:17:04.380Z","comments":true,"path":"2019/07/28/JavaScript/React Lazyload/","link":"","permalink":"https://wzes.github.io/2019/07/28/JavaScript/React Lazyload/","excerpt":"","text":"前言 早在多年前，lazyload 已经出现了，懒加载在前端里边同样具有十分重要的意义。react-lazyload 的作用是当组件未出现在屏幕内时，不去挂载该组件，而是使用 placeholder 去渲染，让滚动使内容出现后，组件会被挂载。就是这么简单！例如，一个复杂的组件（非首屏内容），使用了懒加载后，渲染首屏就会节省很多资源，从而减少首屏渲染时间。 Demo 源码地址 react-lazyload Demo地址 Demo HelloWorld 将需要懒加载的组件使用 LazyLoad 包裹即可，最好使用 height 进行站位，否则该组件位置将会为 0 1234567&lt;LazyLoad height=&#123;200&#125;&gt; &lt;img src=&quot;tiger.jpg&quot; /&gt; /* Lazy loading images is supported out of box, no extra config needed, set `height` for better experience */ &lt;/LazyLoad&gt; 解析 从源码角度分析～ 一览核心 本小节摘取了最核心的代码，目的在于对 LazyLoad 组件有个最核心的认识，它的核心就是监听滚动事件，检查组件是否在屏幕内，如果在的话就显示，不在的话就不显示～ 12345678910111213class LazyLoad extends Component &#123; componentDidMount() &#123; on(scrollport, &apos;scroll&apos;, finalLazyLoadHandler, passiveEvent); &#125; render() &#123; return this.visible ? this.props.children : this.props.placeholder ? this.props.placeholder : &lt;div style=&#123;&#123; height: this.props.height &#125;&#125; className=&quot;lazyload-placeholder&quot; ref=&#123;this.setRef&#125; /&gt;; &#125;&#125; LazyLoad 的属性，透过属性，我们可以知道它大概有些什么功能。 12345678910111213141516171819202122232425LazyLoad.propTypes = &#123; once: PropTypes.bool, height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]), offset: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]), overflow: PropTypes.bool, // 不是 window 滚动，而使用了 overflow: scroll resize: PropTypes.bool, // 是否监听 resize scroll: PropTypes.bool, // 是否监听滚动 children: PropTypes.node, throttle: PropTypes.oneOfType([PropTypes.number, PropTypes.bool]), debounce: PropTypes.oneOfType([PropTypes.number, PropTypes.bool]), placeholder: PropTypes.node, scrollContainer: PropTypes.oneOfType([PropTypes.string, PropTypes.object]), unmountIfInvisible: PropTypes.bool, preventLoading: PropTypes.bool&#125;;// 默认值LazyLoad.defaultProps = &#123; once: false, offset: 0, overflow: false, resize: false, scroll: true, unmountIfInvisible: false, preventLoading: false,&#125;; 完整的 componentDidMount，scrollport 是滚动试图，默认是 window，如果 props 传入了 scrollContainer，那么滚动试图将是自定义的。needResetFinalLazyLoadHandler 是控制是否重置滚动监听。debounce 和 throttle 分别是用来控制滚动事件的监听触发频率，默认都是 undefine，needResetFinalLazyLoadHandler 初始值为 false。finalLazyLoadHandler 初始值也为 undefine，而 overflow 也为 false，scroll 为 true，listeners 是需要懒加载的组件集合，初始大小肯定为0，componentDidMount 最后才会进行添加，因此最终会走到 **on(scrollport, ‘scroll’, finalLazyLoadHandler, passiveEvent)，事件只需要一次绑定即可。 ** 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061componentDidMount() &#123; // It&apos;s unlikely to change delay type on the fly, this is mainly // designed for tests let scrollport = window; const &#123; scrollContainer, &#125; = this.props; if (scrollContainer) &#123; if (isString(scrollContainer)) &#123; scrollport = scrollport.document.querySelector(scrollContainer); &#125; &#125; const needResetFinalLazyLoadHandler = (this.props.debounce !== undefined &amp;&amp; delayType === &apos;throttle&apos;) || (delayType === &apos;debounce&apos; &amp;&amp; this.props.debounce === undefined); if (needResetFinalLazyLoadHandler) &#123; off(scrollport, &apos;scroll&apos;, finalLazyLoadHandler, passiveEvent); off(window, &apos;resize&apos;, finalLazyLoadHandler, passiveEvent); finalLazyLoadHandler = null; &#125; if (!finalLazyLoadHandler) &#123; if (this.props.debounce !== undefined) &#123; finalLazyLoadHandler = debounce(lazyLoadHandler, typeof this.props.debounce === &apos;number&apos; ? this.props.debounce : 300); delayType = &apos;debounce&apos;; &#125; else if (this.props.throttle !== undefined) &#123; finalLazyLoadHandler = throttle(lazyLoadHandler, typeof this.props.throttle === &apos;number&apos; ? this.props.throttle : 300); delayType = &apos;throttle&apos;; &#125; else &#123; finalLazyLoadHandler = lazyLoadHandler; &#125; &#125; if (this.props.overflow) &#123; const parent = scrollParent(this.ref); if (parent &amp;&amp; typeof parent.getAttribute === &apos;function&apos;) &#123; const listenerCount = 1 + (+parent.getAttribute(LISTEN_FLAG)); if (listenerCount === 1) &#123; parent.addEventListener(&apos;scroll&apos;, finalLazyLoadHandler, passiveEvent); &#125; parent.setAttribute(LISTEN_FLAG, listenerCount); &#125; &#125; else if (listeners.length === 0 || needResetFinalLazyLoadHandler) &#123; const &#123; scroll, resize &#125; = this.props; if (scroll) &#123; on(scrollport, &apos;scroll&apos;, finalLazyLoadHandler, passiveEvent); &#125; if (resize) &#123; on(window, &apos;resize&apos;, finalLazyLoadHandler, passiveEvent); &#125; &#125; listeners.push(this); checkVisible(this); &#125; 通常 finalLazyLoadHandler 就是 lazyLoadHandler，不会对滚动事件进行 debounce 或 throttle，我们一般为了性能，会使用 throttle 进行处理。函数会对每一个懒加载组件进行 checkVisible，之后会移除 once component 12345678const lazyLoadHandler = () =&gt; &#123; for (let i = 0; i &lt; listeners.length; ++i) &#123; const listener = listeners[i]; checkVisible(listener); &#125; // Remove `once` component in listeners purgePending();&#125;; checkVisible，检查组件是否出现在 viewport 中，如果出现了就吧 visible 设置为 true，当然如果设置了 unmountIfInvisible = true，那么不可见时组件将被移除，如果之前已经渲染了，需要避免再次渲染。 12345678910111213141516171819202122232425262728293031const checkVisible = function checkVisible(component) &#123; const node = component.ref; if (!(node instanceof HTMLElement)) &#123; return; &#125; const parent = scrollParent(node); const isOverflow = component.props.overflow &amp;&amp; parent !== node.ownerDocument &amp;&amp; parent !== document &amp;&amp; parent !== document.documentElement; const visible = isOverflow ? checkOverflowVisible(component, parent) : checkNormalVisible(component); if (visible) &#123; // Avoid extra render if previously is visible if (!component.visible &amp;&amp; !component.preventLoading) &#123; if (component.props.once) &#123; pending.push(component); &#125; component.visible = true; component.forceUpdate(); &#125; &#125; else if (!(component.props.once &amp;&amp; component.visible)) &#123; component.visible = false; if (component.props.unmountIfInvisible) &#123; component.forceUpdate(); &#125; &#125;&#125;; checkNormalVisible 检查组件是否 visible 的函数，判断组件的getgetBoundingClientRect 的 top - offset（相对于屏幕顶部的距离） 与 window 的 height 之间的关系 12345678910111213141516171819202122232425const checkNormalVisible = function checkNormalVisible(component) &#123; const node = component.ref; // If this element is hidden by css rules somehow, it&apos;s definitely invisible if (!(node.offsetWidth || node.offsetHeight || node.getClientRects().length)) return false; let top; let elementHeight; try &#123; // 这个语法 node 也是支持的 (&#123; top, height: elementHeight &#125; = node.getBoundingClientRect()); &#125; catch (e) &#123; (&#123; top, height: elementHeight &#125; = defaultBoundingClientRect); &#125; const windowInnerHeight = window.innerHeight || document.documentElement.clientHeight; const offsets = Array.isArray(component.props.offset) ? component.props.offset : [component.props.offset, component.props.offset]; // Be compatible with previous API return (top - offsets[0] &lt;= windowInnerHeight) &amp;&amp; (top + elementHeight + offsets[1] &gt;= 0);&#125;; 12(top - offsets[0] &lt;= windowInnerHeight) &amp;&amp; (top + elementHeight + offsets[1] &gt;= 0); 一张图解析！ 到这里解析的差不多了 欣赏一下 throttle 12345678910111213141516171819202122export default function throttle(fn, threshhold, scope) &#123; threshhold || (threshhold = 250); var last, deferTimer; return function () &#123; var context = scope || this; var now = +new Date, args = arguments; if (last &amp;&amp; now &lt; last + threshhold) &#123; // hold on to it clearTimeout(deferTimer); deferTimer = setTimeout(function () &#123; last = now; fn.apply(context, args); &#125;, threshhold); &#125; else &#123; last = now; fn.apply(context, args); &#125; &#125;;&#125; 再欣赏一下 debounce 12345678910111213141516171819202122232425262728293031323334353637383940414243export default function debounce(func, wait, immediate) &#123; let timeout; let args; let context; let timestamp; let result; const later = function later() &#123; const last = +(new Date()) - timestamp; if (last &lt; wait &amp;&amp; last &gt;= 0) &#123; timeout = setTimeout(later, wait - last); &#125; else &#123; timeout = null; if (!immediate) &#123; result = func.apply(context, args); if (!timeout) &#123; context = null; args = null; &#125; &#125; &#125; &#125;; return function debounced() &#123; context = this; args = arguments; timestamp = +(new Date()); const callNow = immediate &amp;&amp; !timeout; if (!timeout) &#123; timeout = setTimeout(later, wait); &#125; if (callNow) &#123; result = func.apply(context, args); context = null; args = null; &#125; return result; &#125;;&#125; 获取 scrollParent 12345678910111213141516171819202122232425262728293031323334export default (node) =&gt; &#123; if (!(node instanceof HTMLElement)) &#123; return document.documentElement; &#125; const excludeStaticParent = node.style.position === &apos;absolute&apos;; const overflowRegex = /(scroll|auto)/; let parent = node; while (parent) &#123; if (!parent.parentNode) &#123; return node.ownerDocument || document.documentElement; &#125; const style = window.getComputedStyle(parent); const position = style.position; const overflow = style.overflow; const overflowX = style[&apos;overflow-x&apos;]; const overflowY = style[&apos;overflow-y&apos;]; if (position === &apos;static&apos; &amp;&amp; excludeStaticParent) &#123; parent = parent.parentNode; continue; &#125; if (overflowRegex.test(overflow) &amp;&amp; overflowRegex.test(overflowX) &amp;&amp; overflowRegex.test(overflowY)) &#123; return parent; &#125; parent = parent.parentNode; &#125; return node.ownerDocument || node.documentElement || document.documentElement;&#125;; 总结思考 我们可以看到，Lazyload 并不能实现类似客户端的图片懒加载，Lazyload 加载图片也会出现白屏时间，解决办法是使用 image.onload，当图片资源请求关闭后，再显示图片，就可以做到类似客户端的效果。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://wzes.github.io/tags/React/"},{"name":"Lazyload","slug":"Lazyload","permalink":"https://wzes.github.io/tags/Lazyload/"}]},{"title":"JavaScript Swipe-js-ios 源码解析","slug":"JavaScript/Swipe-js-ios","date":"2019-07-20T06:38:00.000Z","updated":"2019-09-02T12:16:32.909Z","comments":true,"path":"2019/07/20/JavaScript/Swipe-js-ios/","link":"","permalink":"https://wzes.github.io/2019/07/20/JavaScript/Swipe-js-ios/","excerpt":"","text":"前言 Swipe，常用来做轮播图，需要翻页的场景，最经典的开源库 swipe-js-iso ，不过更推荐使用 React 组件 react-swipe，它封装了 swipe-js-ios 组件，而 swipe-js-ios 组件则封装了 Swipe HelloWord 如果单独使用的化，创建一个 swipe，dom 必须是三层结构，最里面一层是放 slide 的。 1234567&lt;div id=&quot;slider&quot; class=&quot;swipe&quot;&gt; &lt;div class=&quot;swipe-wrap&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS 子元素 float: left; container 的宽度为自定义，swipe-wrap 的宽度为子页面数 * container 的 width，每一个 slide 的宽度为 container 的 width 1234567891011121314.swipe &#123; overflow: hidden; visibility: hidden; position: relative;&#125;.swipe-wrap &#123; overflow: hidden; position: relative;&#125;.swipe-wrap &gt; div &#123; float: left; width: 100%; position: relative;&#125; load 以后，创建 Swipe 即可 1const mySwipe = Swipe(document.getElementById(&apos;slider&apos;)); 源码解析 swipe-js-ios 使用立即函数导出了一个 Swipe 模块，使用 typeof module !== ‘undefined’ &amp;&amp; module.exports 兼容 Node 和 浏览器环境，如果是 Node 环境，将会有 module.export 那么则使用 module.export 导出，否则使用 root.Swipe 全局变量导出 123456789101112(function(root, factory) &#123; if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123; module.exports = factory(); &#125; else &#123; root.Swipe = factory(); &#125;&#125;)(this, function() &#123; &apos;use strict&apos;; return function Swipe(container, options) &#123; .... &#125;;&#125;); 检查浏览器的环境，算是一种规范吧，风别检查触摸事件和 transition 的支持 ⚠️在浏览器，手机模式下，触摸事件是存在的，而普通浏览器下是不存在的，所以该组件不能在普通浏览器中使用。 123456789101112131415161718var browser = &#123; addEventListener: !!window.addEventListener, touch: &apos;ontouchstart&apos; in window || (window.DocumentTouch &amp;&amp; document instanceof window.DocumentTouch), transitions: (function(temp) &#123; var props = [ &apos;transitionProperty&apos;, &apos;WebkitTransition&apos;, &apos;MozTransition&apos;, &apos;OTransition&apos;, &apos;msTransition&apos; ]; for (var i in props) if (temp.style[props[i]] !== undefined) return true; return false; &#125;)(document.createElement(&apos;swipe&apos;)) &#125;; 创建时会调用 setup，继而添加事件，touch 触摸事件、transitionend 移动事件，resize 重新布局事件 1234567891011121314151617181920212223242526272829// trigger setupsetup();// start auto slideshow if applicableif (delay) begin();// add event listenersif (browser.addEventListener) &#123; // set touchstart event on element if (browser.touch) &#123; element.addEventListener(&apos;touchstart&apos;, events, false); element.addEventListener(&apos;touchforcechange&apos;, function() &#123;&#125;, false); &#125; if (browser.transitions) &#123; element.addEventListener(&apos;webkitTransitionEnd&apos;, events, false); element.addEventListener(&apos;msTransitionEnd&apos;, events, false); element.addEventListener(&apos;oTransitionEnd&apos;, events, false); element.addEventListener(&apos;otransitionend&apos;, events, false); element.addEventListener(&apos;transitionend&apos;, events, false); &#125; // set resize event on window window.addEventListener(&apos;resize&apos;, events, false);&#125; else &#123; window.onresize = function() &#123; setup(); &#125;; // to play nice with old IE&#125; setup 函数的实现，slides 就是容器里面的页面，continuous 是否自动轮播，slidePos 记录了每一个页面的位置，width 是每一个页面的宽度，此处需要剪掉widthOfSiblingSlidePreview 的大小，可以预览前后页。element 的宽度是 **页数 * width ** 1234567891011121314151617181920function setup() &#123; // cache slides slides = element.children; length = slides.length; // set continuous to false if only one slide continuous = slides.length &lt; 2 ? false : options.continuous; // create an array to store current positions of each slide slidePos = new Array(slides.length); // determine width of each slide width = Math.round( container.getBoundingClientRect().width || container.offsetWidth ) - widthOfSiblingSlidePreview * 2; element.style.width = slides.length * width + &apos;px&apos;; &#125; 初始化时，需要更新页面的位置 123456789101112var pos = slides.length;while (pos--) &#123; var slide = slides[pos]; slide.style.width = width + &apos;px&apos;; slide.setAttribute(&apos;data-index&apos;, pos); if (browser.transitions) &#123; slide.style.left = pos * -width + widthOfSiblingSlidePreview + &apos;px&apos;; move(pos, index &gt; pos ? -width : index &lt; pos ? width : 0, 0); &#125;&#125; 如果支持轮播的化，需要把左边和右边也填充，然后把 container.style.visibility 设置为 visible，如果不支持 transition 的话，只需要设置 element.style.left 即可 12345678910// reposition elements before and after index if (continuous &amp;&amp; browser.transitions) &#123; move(circle(index - 1), -width, 0); move(circle(index + 1), width, 0); &#125; if (!browser.transitions) element.style.left = index * -width + widthOfSiblingSlidePreview + &apos;px&apos;; container.style.visibility = &apos;visible&apos;; move 的实现，translate，更新 slidePos 的位置 1234function move(index, dist, speed) &#123; translate(index, dist, speed); slidePos[index] = dist;&#125; translate 三个参数，index：需要移动的页，dist：移动的位置，speed：移动速度，移动只需要给 页面设置 style 的 transform 就OK了，之后就会以动画移动过去了 12345678910111213function translate(index, dist, speed) &#123; var slide = slides[index]; var style = slide &amp;&amp; slide.style; if (!style) return; style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration = speed + &apos;ms&apos;; style.webkitTransform = &apos;translate(&apos; + dist + &apos;px,0)&apos; + &apos;translateZ(0)&apos;; style.msTransform = style.MozTransform = style.OTransform = &apos;translateX(&apos; + dist + &apos;px)&apos;; &#125; prev 对外提供接口，手动翻页使用 1234function prev() &#123; if (continuous) slide(index - 1); else if (index) slide(index - 1);&#125; slide 移动函数，指定移动的页 index 和速度 12345678910111213141516171819202122232425262728293031323334353637383940414243function slide(to, slideSpeed) &#123; // do nothing if already on requested slide if (index == to) return; if (browser.transitions) &#123; var direction = Math.abs(index - to) / (index - to); // 1: backward, -1: forward // get the actual position of the slide if (continuous) &#123; var natural_direction = direction; direction = -slidePos[circle(to)] / width; // if going forward but to &lt; index, use to = slides.length + to // if going backward but to &gt; index, use to = -slides.length + to if (direction !== natural_direction) to = -direction * slides.length + to; &#125; var diff = Math.abs(index - to) - 1; // move all the slides between index and to in the right direction while (diff--) move( circle((to &gt; index ? to : index) - diff - 1), width * direction, 0 ); to = circle(to); move(index, width * direction, slideSpeed || speed); move(to, 0, slideSpeed || speed); if (continuous) move(circle(to - direction), -(width * direction), 0); // we need to get the next in place &#125; else &#123; to = circle(to); animate(index * -width, to * -width, slideSpeed || speed); //no fallback for a circular continuous if the browser does not accept transitions &#125; index = to; offloadFn(options.callback &amp;&amp; options.callback(index, slides[index])); &#125; 如果浏览器不支持 transition，那么则使用 setInterval 实现渐进移动， animation 是对整个页面进行移动，而 move 是移动每一个子页面 123456789101112131415161718192021222324252627282930function animate(from, to, speed) &#123; // if not an animation, just reposition if (!speed) &#123; element.style.left = to + &apos;px&apos;; return; &#125; var start = +new Date(); var timer = setInterval(function() &#123; var timeElap = +new Date() - start; if (timeElap &gt; speed) &#123; element.style.left = to + &apos;px&apos;; if (delay) begin(); options.transitionEnd &amp;&amp; options.transitionEnd.call(event, index, slides[index]); clearInterval(timer); return; &#125; element.style.left = (to - from) * (Math.floor((timeElap / speed) * 100) / 100) + from + &apos;px&apos;; &#125;, 4); &#125; 接下来研究一下触摸事件的处理，首先是 start，start 事件会记录起始触摸位置以及时间，并且添加 touchmove 和 touchend 事件，如果没有 start 事件，触摸事件是不存在的， end 的时候会被移除。 1234567891011121314151617181920212223start: function(event) &#123; var touches = event.touches[0]; // measure start values start = &#123; // get initial touch coords x: touches.pageX, y: touches.pageY, // store time to determine touch duration time: +new Date() &#125;; // used for testing first move event isScrolling = undefined; // reset delta and end measurements delta = &#123;&#125;; // attach touchmove and touchend listeners element.addEventListener(&apos;touchmove&apos;, this, false); element.addEventListener(&apos;touchend&apos;, this, false); &#125;, move 事件，delta 将手指移动距离记下，最后视同 translate 移动 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162move: function(event) &#123; // ensure swiping with one touch and not pinching if (event.touches.length &gt; 1 || (event.scale &amp;&amp; event.scale !== 1)) return; if (options.disableScroll) return; var touches = event.touches[0]; // measure change in x and y delta = &#123; x: touches.pageX - start.x, y: touches.pageY - start.y &#125;; // determine if scrolling test has run - one time test if (typeof isScrolling == &apos;undefined&apos;) &#123; isScrolling = !!( isScrolling || Math.abs(delta.x) &lt; Math.abs(delta.y) ); &#125; // if user is not trying to scroll vertically if (!isScrolling) &#123; // prevent native scrolling event.preventDefault(); // stop slideshow stop(); // increase resistance if first or last slide if (continuous) &#123; // we don&apos;t add resistance at the end translate( circle(index - 1), delta.x + slidePos[circle(index - 1)], 0 ); translate(index, delta.x + slidePos[index], 0); translate( circle(index + 1), delta.x + slidePos[circle(index + 1)], 0 ); &#125; else &#123; delta.x = delta.x / ((!index &amp;&amp; delta.x &gt; 0) || // if first slide and sliding left (index == slides.length - 1 &amp;&amp; // or if last slide and sliding right delta.x &lt; 0) // and if sliding at all ? Math.abs(delta.x) / width + 1 // determine resistance level : 1); // no resistance if false // translate 1:1 translate(index - 1, delta.x + slidePos[index - 1], 0); translate(index, delta.x + slidePos[index], 0); translate(index + 1, delta.x + slidePos[index + 1], 0); &#125; options.swiping &amp;&amp; options.swiping(-delta.x / width); &#125; &#125;, end 事件，主要判断本次触摸滑动是否有效，并持续接下来的操作，最后将会 remove 掉监听事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778end: function(event) &#123; // measure duration var duration = +new Date() - start.time; // determine if slide attempt triggers next/prev slide var isValidSlide = (Number(duration) &lt; 250 &amp;&amp; // if slide duration is less than 250ms Math.abs(delta.x) &gt; 20) || // and if slide amt is greater than 20px Math.abs(delta.x) &gt; width / 2; // or if slide amt is greater than half the width // determine if slide attempt is past start and end var isPastBounds = (!index &amp;&amp; delta.x &gt; 0) || // if first slide and slide amt is greater than 0 (index == slides.length - 1 &amp;&amp; delta.x &lt; 0); // or if last slide and slide amt is less than 0 if (continuous) isPastBounds = false; // determine direction of swipe (true:right, false:left) var direction = delta.x &lt; 0; // if not scrolling vertically if (!isScrolling) &#123; if (isValidSlide &amp;&amp; !isPastBounds) &#123; if (direction) &#123; if (continuous) &#123; // we need to get the next in this direction in place move(circle(index - 1), -width, 0); move(circle(index + 2), width, 0); &#125; else &#123; move(index - 1, -width, 0); &#125; move(index, slidePos[index] - width, speed); move( circle(index + 1), slidePos[circle(index + 1)] - width, speed ); index = circle(index + 1); &#125; else &#123; if (continuous) &#123; // we need to get the next in this direction in place move(circle(index + 1), width, 0); move(circle(index - 2), -width, 0); &#125; else &#123; move(index + 1, width, 0); &#125; move(index, slidePos[index] + width, speed); move( circle(index - 1), slidePos[circle(index - 1)] + width, speed ); index = circle(index - 1); &#125; options.callback &amp;&amp; options.callback(index, slides[index]); &#125; else &#123; if (continuous) &#123; move(circle(index - 1), -width, speed); move(index, 0, speed); move(circle(index + 1), width, speed); &#125; else &#123; move(index - 1, -width, speed); move(index, 0, speed); move(index + 1, width, speed); &#125; &#125; &#125; // kill touchmove and touchend event listeners until touchstart called again element.removeEventListener(&apos;touchmove&apos;, events, false); element.removeEventListener(&apos;touchend&apos;, events, false); element.removeEventListener(&apos;touchforcechange&apos;, function() &#123;&#125;, false); &#125;, 总结 总的来说，swipe-js-ios 充分利用了 transition，来实现移动动画，搞清楚触摸事件就比较容易能写出来可滑动的 swipe","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://wzes.github.io/tags/HTML/"},{"name":"DOM","slug":"DOM","permalink":"https://wzes.github.io/tags/DOM/"}]},{"title":"JavaScript Webpack 源码解析","slug":"JavaScript/Webpack","date":"2019-07-13T11:59:16.000Z","updated":"2019-09-02T12:17:16.955Z","comments":true,"path":"2019/07/13/JavaScript/Webpack/","link":"","permalink":"https://wzes.github.io/2019/07/13/JavaScript/Webpack/","excerpt":"","text":"前言 算是一个h5开发了，虽然没写过什么完整的前端页面，但接触前端也有段时间了，对于一个合格的前端开发者而言，搞懂 webpack 打包原理还是比较重要的 hello world 使用 commonjs 规范，lib.js 只导出一个方法 1234// lib.jsmodule.exports = function () &#123; return &quot;hello webpack!&quot;&#125; index.js 使用 require 引入，代码很简单，输入方法返回值 123456// index.jsconst func = require(&quot;./lib&quot;)const result = func()// print helloconsole.log(result) 目录结构 12345678910.├── dist│ └── main.js├── package-lock.json├── package.json├── node_modules├── src│ ├── index.js│ └── lib.js└── webpack.config.js webpack.config.js 为了方便看生成的源码，我们将 mode 设置为 development， 1234567891011var path = require(&apos;path&apos;);module.exports = &#123; context: path.resolve(__dirname, &apos;./&apos;), mode: &apos;development&apos;, entry: &apos;./src/index.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;main.js&apos; &#125;&#125;; package.json 123456789101112131415161718&#123; &quot;name&quot;: &quot;webpack-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;webpack&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.35.2&quot;, &quot;webpack-cli&quot;: &quot;^3.3.5&quot; &#125;, &quot;dependencies&quot;: &#123;&#125;&#125; 编译运行 12npm run buildnode dist/main.js 输出 12$ node dist/main.js hello webpack! 起源 浏览器，node 并不支持模块化，我们在项目中使用的 require、export 将会经过 webpack 后，这些 js 就会被打包整合成一个 js 文件，只需要运行 js 文件，整个模块将会运行起来了。 main.js 解析 整个文件只有 111 行，这是未经过压缩的版本，生产环境下的输出文件比这还要精简，只需要在 webpack.config.js 中将 mode 值等于 production 即可改变打包环境 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/******/ (function(modules) &#123; // webpackBootstrap/******/ // The module cache/******/ var installedModules = &#123;&#125;;/******//******/ // The require function/******/ function __webpack_require__(moduleId) &#123;/******//******/ // Check if module is in cache/******/ if(installedModules[moduleId]) &#123;/******/ return installedModules[moduleId].exports;/******/ &#125;/******/ // Create a new module (and put it into the cache)/******/ var module = installedModules[moduleId] = &#123;/******/ i: moduleId,/******/ l: false,/******/ exports: &#123;&#125;/******/ &#125;;/******//******/ // Execute the module function/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******//******/ // Flag the module as loaded/******/ module.l = true;/******//******/ // Return the exports of the module/******/ return module.exports;/******/ &#125;/******//******//******/ // expose the modules object (__webpack_modules__)/******/ __webpack_require__.m = modules;/******//******/ // expose the module cache/******/ __webpack_require__.c = installedModules;/******//******/ // define getter function for harmony exports/******/ __webpack_require__.d = function(exports, name, getter) &#123;/******/ if(!__webpack_require__.o(exports, name)) &#123;/******/ Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;);/******/ &#125;/******/ &#125;;/******//******/ // define __esModule on exports/******/ __webpack_require__.r = function(exports) &#123;/******/ if(typeof Symbol !== &apos;undefined&apos; &amp;&amp; Symbol.toStringTag) &#123;/******/ Object.defineProperty(exports, Symbol.toStringTag, &#123; value: &apos;Module&apos; &#125;);/******/ &#125;/******/ Object.defineProperty(exports, &apos;__esModule&apos;, &#123; value: true &#125;);/******/ &#125;;/******//******/ // create a fake namespace object/******/ // mode &amp; 1: value is a module id, require it/******/ // mode &amp; 2: merge all properties of value into the ns/******/ // mode &amp; 4: return value when already ns object/******/ // mode &amp; 8|1: behave like require/******/ __webpack_require__.t = function(value, mode) &#123;/******/ if(mode &amp; 1) value = __webpack_require__(value);/******/ if(mode &amp; 8) return value;/******/ if((mode &amp; 4) &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; value &amp;&amp; value.__esModule) return value;/******/ var ns = Object.create(null);/******/ __webpack_require__.r(ns);/******/ Object.defineProperty(ns, &apos;default&apos;, &#123; enumerable: true, value: value &#125;);/******/ if(mode &amp; 2 &amp;&amp; typeof value != &apos;string&apos;) for(var key in value) __webpack_require__.d(ns, key, function(key) &#123; return value[key]; &#125;.bind(null, key));/******/ return ns;/******/ &#125;;/******//******/ // getDefaultExport function for compatibility with non-harmony modules/******/ __webpack_require__.n = function(module) &#123;/******/ var getter = module &amp;&amp; module.__esModule ?/******/ function getDefault() &#123; return module[&apos;default&apos;]; &#125; :/******/ function getModuleExports() &#123; return module; &#125;;/******/ __webpack_require__.d(getter, &apos;a&apos;, getter);/******/ return getter;/******/ &#125;;/******//******/ // Object.prototype.hasOwnProperty.call/******/ __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;;/******//******/ // __webpack_public_path__/******/ __webpack_require__.p = &quot;&quot;;/******//******//******/ // Load entry module and return exports/******/ return __webpack_require__(__webpack_require__.s = &quot;./src/index.js&quot;);/******/ &#125;)/************************************************************************//******/ (&#123;/***/ &quot;./src/index.js&quot;:/*!**********************!*\\ !*** ./src/index.js ***! \\**********************//*! no static exports found *//***/ (function(module, exports, __webpack_require__) &#123;eval(&quot;// index.js\\nconst func = __webpack_require__(/*! ./lib */ \\&quot;./src/lib.js\\&quot;)\\n\\nconst result = func()\\n// print hello\\nconsole.log(result)\\n\\n//# sourceURL=webpack:///./src/index.js?&quot;);/***/ &#125;),/***/ &quot;./src/lib.js&quot;:/*!********************!*\\ !*** ./src/lib.js ***! \\********************//*! no static exports found *//***/ (function(module, exports) &#123;eval(&quot;module.exports = function () &#123;\\n return \\&quot;hello webpack!\\&quot;\\n&#125;\\n\\n//# sourceURL=webpack:///./src/lib.js?&quot;);/***/ &#125;)/******/ &#125;); 我们先将此文件的主要部分拿出来看 123456789101112131415161718192021222324252627282930313233/******/(function (modules) &#123; var installedModules = &#123;&#125; function __webpack_require__ (moduleId) &#123; if (installedModules[moduleId]) &#123; return installedModules[moduleId].exports &#125; var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125; &#125; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__) module.l = true return module.exports &#125; return __webpack_require__(__webpack_require__.s = &apos;./src/index.js&apos;)&#125;)(&#123; &apos;./src/index.js&apos;: (function (module, exports, __webpack_require__) &#123; eval( &apos;// index.js\\nconst func = __webpack_require__(/*! ./lib */ &quot;./src/lib.js&quot;)\\n\\nconst result = func()\\n// print hello\\nconsole.log(result)\\n\\n//# sourceURL=webpack:///./src/index.js?&apos;) &#125;), &apos;./src/lib.js&apos;: (function (module, exports) &#123; eval( &apos;module.exports = function () &#123;\\n return &quot;hello webpack!&quot;\\n&#125;\\n\\n//# sourceURL=webpack:///./src/lib.js?&apos;) &#125;)&#125;) 这是一个立即执行函数，首先申明了 installedModules 对象，这是已安装的模块集合，之后定义了一个函数 webpack_require ，此函数用来获取模块的引用，最后 return 了此函数，参数为入口，moduleId = ‘./src/index.js’ modules 即为 123456789101112&#123; &apos;./src/index.js&apos;: (function (module, exports, __webpack_require__) &#123; eval( &apos;// index.js\\nconst func = __webpack_require__(/*! ./lib */ &quot;./src/lib.js&quot;)\\n\\nconst result = func()\\n// print hello\\nconsole.log(result)\\n\\n//# sourceURL=webpack:///./src/index.js?&apos;) &#125;), &apos;./src/lib.js&apos;: (function (module, exports) &#123; eval( &apos;module.exports = function () &#123;\\n return &quot;hello webpack!&quot;\\n&#125;\\n\\n//# sourceURL=webpack:///./src/lib.js?&apos;) &#125;)&#125; 1modules[moduleId].call(module.exports, module, module.exports, __webpack_require__) module 即模块，modules[moduleId] 即为 1234(function (module, exports, __webpack_require__) &#123; eval( &apos;// index.js\\nconst func = __webpack_require__(/*! ./lib */ &quot;./src/lib.js&quot;)\\n\\nconst result = func()\\n// print hello\\nconsole.log(result)\\n\\n//# sourceURL=webpack:///./src/index.js?&apos;) &#125;) module.exports 为 this 上下文环境，该函数执行中，第一行即调用 1const func = __webpack_require__(&quot;./src/lib.js&quot;) webpack_require(&quot;./src/lib.js&quot;) 即调用了此函数 1234(function (module, exports) &#123; eval( &apos;module.exports = function () &#123;\\n return &quot;hello webpack!&quot;\\n&#125;\\n\\n//# sourceURL=webpack:///./src/lib.js?&apos;) &#125;) 最后返回 module.exports 即 lib 里面的导出函数。再往后执行便是 123const result = func()// print helloconsole.log(result) 此刻基本已经将关系理顺了，此后如果在调用模块，则世界从 installedModules 中直接返回。 总结 此文只是分析了简单的模块引用，需要仔细分析才能融会贯通。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wzes.github.io/tags/JavaScript/"},{"name":"Webpack","slug":"Webpack","permalink":"https://wzes.github.io/tags/Webpack/"}]},{"title":"Android PageTransformer 源码解析","slug":"Android/PageTransformer","date":"2019-07-05T12:35:00.000Z","updated":"2019-09-02T12:19:17.763Z","comments":true,"path":"2019/07/05/Android/PageTransformer/","link":"","permalink":"https://wzes.github.io/2019/07/05/Android/PageTransformer/","excerpt":"","text":"前言 作为一个很久没写过 Android 业务的人，心里有点慌了，于是拿起 Android Studio，还是找点东西学习一下，并且记录一下。一直觉得 ViewPager 是个好东西，偶然间看到一些很好的案例，很酷炫的翻页效果。直到了解了这个东西的实现原来没有想象中的那么复杂，但如果没有深刻理解，还是很难写出酷炫的效果的。于是， ViewPager Transformer 的学习就提上了日程。 Hello World 首先我们来实现一个场景，很简单，只需要一个 ViewPager，然后给他设置几页用来展现效果就行了 Layout 文件 只需要放入一个 ViewPager 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;androidx.viewpager.widget.ViewPager android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/view_pager&quot;&gt; &lt;/androidx.viewpager.widget.ViewPager&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 之后，我们创建一个 PageAdapter，可以直接使用 FragmentPagerAdapter，getItem 返回一个 Fragment 就好了 12345678910111213141516171819202122232425262728293031class PageAdapter(fm: FragmentManager) : FragmentPagerAdapter(fm) &#123; override fun getItem(position: Int): Fragment &#123; return PageFragment(&quot;Fragment $position&quot;, position) &#125; override fun getCount(): Int &#123; return 4 &#125; @SuppressLint(&quot;ValidFragment&quot;) class PageFragment(private var content: String, private var position: Int) : Fragment() &#123; private val colors = Arrays.asList(Color.GRAY, Color.RED, Color.BLUE, Color.YELLOW)!! override fun onActivityCreated(savedInstanceState: Bundle?) &#123; super.onActivityCreated(savedInstanceState) text_view.text = content &#125; override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? &#123; val view = inflater.inflate(R.layout.tab_item, container, false) view.setBackgroundColor(colors[position % colors.size]) view.tag = &quot;$position&quot; return view &#125; &#125;&#125; 在我们的 Activity 中，设置 view_pager，这里需要注意的是，由于我们使用了 FragmentPagerAdapter，所以我们在展示是如果需要展示多页的话，必须设置为 offscreenPageLimit 一个比较大的值，以便 ViewPager 能够渲染足够多的页面满足我们的需求。 最后为 ViewPager 设置一个 PageTransformer 12345678910111213class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) view_pager.adapter = PageAdapter(supportFragmentManager) view_pager.offscreenPageLimit = 4 view_pager.setPageTransformer(true, ViewPagerTransformer(TransformType.DEPTH)) &#125;&#125; 一个比较简单的 PageTransformer 的实现如下 12345class ViewPagerTransformer : ViewPager.PageTransformer &#123; override fun transformPage(page: View, position: Float) &#123; page.rotationY = position * -30f &#125;&#125; 效果如下，翻页时会根据位置修改页面的显示，页面将会绕 Y 轴进行旋转一定的角度，效果很赞吧！！！只用了一点代码 ViewPager.PageTransformer 定义 PageTransfomer 接口只有一个方法，该方法有两个参数，一个是 page，指的是 ViewPage 的一个内容页 1234567891011public interface PageTransformer &#123; /** * Apply a property transformation to the given page. * * @param page Apply the transformation to this page * @param position Position of page relative to the current front-and-center * position of the pager. 0 is front and center. 1 is one full * page position to the right, and -1 is one page position to the left. */ void transformPage(@NonNull View page, float position);&#125; position 指的是该内容页的位置偏移，该偏移是相对的，具体表示请看一张图，页面静止时，以屏幕左边界为 0，屏幕内的页面 position 为0，左边为-1，依次递减，右侧为1，依次递增。当屏幕滑动时，page2只出现一半，此时，page2 的 position 为-0.5，page3 为0.5，依次类推可得出其他page 回调的 position 值 实践 1、淡入淡出 效果 页面随着位置改变透明度，alpha = 0 是透明，alpha = 1 是不透明 1234567if (position &lt;= -1.0f || position &gt;= 1.0f) &#123; page.alpha = 0.0f&#125; else if (position == 0.0f) &#123; page.alpha = 1.0f&#125; else &#123; page.alpha = 1.0f - Math.abs(position)&#125; 2、缩放变大效果 同时改变位移与透明度 123456789if (position &gt; 0 &amp;&amp; position &lt; 1) &#123; page.alpha = 1 - position page.scaleXY = 0.85f + (1 - 0.85f) * (1 - Math.abs(position)) page.translationX = page.width * -position&#125; else &#123; page.alpha = 1f page.scaleXY = 1f page.translationX = 0f&#125; 更多效果 等你去发现 源码解析 其实这个原理很简单，在每一次滚动的时候，在 ViewPager 内部，计算出 每一个view 的 position ，并且调用这个接口的方法就可以实现了 源码如下 12345678910111213141516protected void onPageScrolled(int position, float offset, int offsetPixels) &#123; // 省略....... if (mPageTransformer != null) &#123; final int scrollX = getScrollX(); final int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = getChildAt(i); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); if (lp.isDecor) continue; final float transformPos = (float) (child.getLeft() - scrollX) / getClientWidth(); mPageTransformer.transformPage(child, transformPos); &#125; &#125; // .... &#125; 首先判断 mPageTransformer 是否存在，存在的话就可以调用了，获取 scrollX，根据 childCount 对每一个 view 执行 mPageTransformer.transformPage 方法 transformPos 是由 (float) (child.getLeft() - scrollX) / getClientWidth() 计算得出。此处使用 getLeft - scrollX 计算验证了我们对想法。 demo 总结 看似复杂的功能，其实没那么复杂，静下心来研究，原来这么简单","categories":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/tags/Android/"},{"name":"ViewPager","slug":"ViewPager","permalink":"https://wzes.github.io/tags/ViewPager/"}]},{"title":"Android TabLayout 源码解析","slug":"Android/TabLayout","date":"2019-02-21T07:36:00.000Z","updated":"2019-09-02T12:19:29.232Z","comments":true,"path":"2019/02/21/Android/TabLayout/","link":"","permalink":"https://wzes.github.io/2019/02/21/Android/TabLayout/","excerpt":"","text":"前言 很久很久没写过源码解析了，不是自己没有看了，只是没有记录了，却发现不记录的话，似懂非懂，时间久了就忘得差不多了，用到了还是得再学一遍，忍住提笔一篇 TabLayout 源码学习。 Hello World 依赖 添加 support design 包 1implementation &apos;com.android.support:design:27.1.1&apos; xml 添加一个 TabLayout 就可以了 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.TabLayoutActivity&quot;&gt; &lt;android.support.design.widget.TabLayout android:id=&quot;@+id/tab_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; MainActivity.java 1234567891011121314151617181920import android.support.design.widget.TabLayout;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class TabLayoutActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_tab_layout); TabLayout mTabLayout = findViewById(R.id.tab_layout); // 添加 tab item mTabLayout.addTab(mTabLayout.newTab().setText(&quot;TAB1&quot;)); mTabLayout.addTab(mTabLayout.newTab().setText(&quot;TAB2&quot;)); mTabLayout.addTab(mTabLayout.newTab().setText(&quot;TAB3&quot;)); mTabLayout.addTab(mTabLayout.newTab().setText(&quot;TAB4&quot;)); &#125;&#125; 效果 源码学习 其实，实现这样一个布局并不难，让我们来看看里面所有的内容 前世今生 继承自 HorizontalScrollView 因为他支持滚动 1public class TabLayout extends HorizontalScrollView TabLayout 支持两种模式，一种是固定的，一种是可滚动的（tab 太多，一屏显示不下，可使用这种模式，否则默认为平分） 123456789101112131415161718192021222324252627/** * Scrollable tabs display a subset of tabs at any given moment, and can contain longer tab * labels and a larger number of tabs. They are best used for browsing contexts in touch * interfaces when users don’t need to directly compare the tab labels. * * @see #setTabMode(int) * @see #getTabMode() */public static final int MODE_SCROLLABLE = 0;/** * Fixed tabs display all tabs concurrently and are best used with content that benefits from * quick pivots between tabs. The maximum number of tabs is limited by the view’s width. * Fixed tabs have equal width, based on the widest tab label. * * @see #setTabMode(int) * @see #getTabMode() */public static final int MODE_FIXED = 1;/** * @hide */@RestrictTo(LIBRARY_GROUP)@IntDef(value = &#123;MODE_SCROLLABLE, MODE_FIXED&#125;)@Retention(RetentionPolicy.SOURCE)public @interface Mode &#123;&#125; Tab 的位置有两种，一种是居中，一种是平分 123456789101112131415161718192021222324/** * Gravity used to fill the &#123;@link TabLayout&#125; as much as possible. This option only takes effect * when used with &#123;@link #MODE_FIXED&#125;. * * @see #setTabGravity(int) * @see #getTabGravity() */public static final int GRAVITY_FILL = 0;/** * Gravity used to lay out the tabs in the center of the &#123;@link TabLayout&#125;. * * @see #setTabGravity(int) * @see #getTabGravity() */public static final int GRAVITY_CENTER = 1;/** * @hide */@RestrictTo(LIBRARY_GROUP)@IntDef(flag = true, value = &#123;GRAVITY_FILL, GRAVITY_CENTER&#125;)@Retention(RetentionPolicy.SOURCE)public @interface TabGravity &#123;&#125; 居中模式 创建 Tab 使用代码创建 Tab 123456789public Tab newTab() &#123; Tab tab = sTabPool.acquire(); if (tab == null) &#123; tab = new Tab(); &#125; tab.mParent = this; tab.mView = createTabView(tab); return tab;&#125; Tab 还使用了 Pool，还是挺细心的 1private static final Pools.Pool&lt;Tab&gt; sTabPool = new Pools.SynchronizedPool&lt;&gt;(16); 可滑动的指示条形图 自定义 ViewGroup 1private class SlidingTabStrip extends LinearLayout onMeasure 如果设置了 MODE_FIXED 和 GRAVITY_CENTER 则需要重新测量，目的就是让居中，每个 ITEM 的宽度都是一样的，而且等于最大的一个，如果一屏放得下则需要重新设置每个 ITEM 的大小，并且重新测量。如果发不下，那么侧设置GRAVITY_FILL 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Override protected void onMeasure(final int widthMeasureSpec, final int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); if (MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY) &#123; // HorizontalScrollView will first measure use with UNSPECIFIED, and then with // EXACTLY. Ignore the first call since anything we do will be overwritten anyway return; &#125; // 重新测量 if (mMode == MODE_FIXED &amp;&amp; mTabGravity == GRAVITY_CENTER) &#123; final int count = getChildCount(); // First we&apos;ll find the widest tab int largestTabWidth = 0; for (int i = 0, z = count; i &lt; z; i++) &#123; View child = getChildAt(i); if (child.getVisibility() == VISIBLE) &#123; largestTabWidth = Math.max(largestTabWidth, child.getMeasuredWidth()); &#125; &#125; if (largestTabWidth &lt;= 0) &#123; // If we don&apos;t have a largest child yet, skip until the next measure pass return; &#125; // 间隔 final int gutter = dpToPx(FIXED_WRAP_GUTTER_MIN); boolean remeasure = false; // 一屏放得下 if (largestTabWidth * count &lt;= getMeasuredWidth() - gutter * 2) &#123; // If the tabs fit within our width minus gutters, we will set all tabs to have // the same width for (int i = 0; i &lt; count; i++) &#123; final LinearLayout.LayoutParams lp = (LayoutParams) getChildAt(i).getLayoutParams(); if (lp.width != largestTabWidth || lp.weight != 0) &#123; lp.width = largestTabWidth; lp.weight = 0; remeasure = true; &#125; &#125; &#125; else &#123; // If the tabs will wrap to be larger than the width minus gutters, we need // to switch to GRAVITY_FILL mTabGravity = GRAVITY_FILL; updateTabViews(false); remeasure = true; &#125; if (remeasure) &#123; // Now re-measure after our changes super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; &#125; &#125; 如何实现动画？ 通过移动 IndicatorView onLayout mIndicatorAnimator 是动画辅助类，在 onLayout 中，非空而且正在运行则看取消，然后调用 animateIndicatorToPosition，动画调用，否则直接设置位置，不支持动画 12345678910111213141516@Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; super.onLayout(changed, l, t, r, b); if (mIndicatorAnimator != null &amp;&amp; mIndicatorAnimator.isRunning()) &#123; // If we&apos;re currently running an animation, lets cancel it and start a // new animation with the remaining duration mIndicatorAnimator.cancel(); final long duration = mIndicatorAnimator.getDuration(); animateIndicatorToPosition(mSelectedPosition, Math.round((1f - mIndicatorAnimator.getAnimatedFraction()) * duration)); &#125; else &#123; // If we&apos;ve been layed out, update the indicator position updateIndicatorPosition(); &#125; &#125; updateIndicatorPosition 首先获取选中的 View，然后看 mSelectionOffset 是否大于零，说明发生滚动，则需要重新计算新位置 12345678910111213141516171819202122232425262728293031private void updateIndicatorPosition() &#123; final View selectedTitle = getChildAt(mSelectedPosition); int left, right; if (selectedTitle != null &amp;&amp; selectedTitle.getWidth() &gt; 0) &#123; left = selectedTitle.getLeft(); right = selectedTitle.getRight(); if (mSelectionOffset &gt; 0f &amp;&amp; mSelectedPosition &lt; getChildCount() - 1) &#123; // Draw the selection partway between the tabs View nextTitle = getChildAt(mSelectedPosition + 1); left = (int) (mSelectionOffset * nextTitle.getLeft() + (1.0f - mSelectionOffset) * left); right = (int) (mSelectionOffset * nextTitle.getRight() + (1.0f - mSelectionOffset) * right); &#125; &#125; else &#123; left = right = -1; &#125; setIndicatorPosition(left, right); &#125; // mIndicatorLeft 和 mIndicatorRight 控制了线的起始位置void setIndicatorPosition(int left, int right) &#123; if (left != mIndicatorLeft || right != mIndicatorRight) &#123; // If the indicator&apos;s left/right has changed, invalidate mIndicatorLeft = left; mIndicatorRight = right; ViewCompat.postInvalidateOnAnimation(this); &#125; &#125; 移动动画，移动间隔大的话，并不会从当前位置直接移动，而是跳跃一段距离再移动，通过 startLeft 和 startRight 控制，并且使用 ValueAnimator 来实现动画 这个不错，同意了 fraction 0-1 ，通过函数计算进度 123setIndicatorPosition( AnimationUtils.lerp(startLeft, targetLeft, fraction), AnimationUtils.lerp(startRight, targetRight, fraction)); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void animateIndicatorToPosition(final int position, int duration) &#123; if (mIndicatorAnimator != null &amp;&amp; mIndicatorAnimator.isRunning()) &#123; mIndicatorAnimator.cancel(); &#125; final boolean isRtl = ViewCompat.getLayoutDirection(this) == ViewCompat.LAYOUT_DIRECTION_RTL; final View targetView = getChildAt(position); if (targetView == null) &#123; // If we don&apos;t have a view, just update the position now and return updateIndicatorPosition(); return; &#125; final int targetLeft = targetView.getLeft(); final int targetRight = targetView.getRight(); final int startLeft; final int startRight; if (Math.abs(position - mSelectedPosition) &lt;= 1) &#123; // If the views are adjacent, we&apos;ll animate from edge-to-edge startLeft = mIndicatorLeft; startRight = mIndicatorRight; &#125; else &#123; // Else, we&apos;ll just grow from the nearest edge final int offset = dpToPx(MOTION_NON_ADJACENT_OFFSET); if (position &lt; mSelectedPosition) &#123; // We&apos;re going end-to-start if (isRtl) &#123; startLeft = startRight = targetLeft - offset; &#125; else &#123; startLeft = startRight = targetRight + offset; &#125; &#125; else &#123; // We&apos;re going start-to-end if (isRtl) &#123; startLeft = startRight = targetRight + offset; &#125; else &#123; startLeft = startRight = targetLeft - offset; &#125; &#125; &#125; // 开始移动位置 if (startLeft != targetLeft || startRight != targetRight) &#123; ValueAnimator animator = mIndicatorAnimator = new ValueAnimator(); animator.setInterpolator(AnimationUtils.FAST_OUT_SLOW_IN_INTERPOLATOR); animator.setDuration(duration); animator.setFloatValues(0, 1); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animator) &#123; final float fraction = animator.getAnimatedFraction(); setIndicatorPosition( AnimationUtils.lerp(startLeft, targetLeft, fraction), AnimationUtils.lerp(startRight, targetRight, fraction)); &#125; &#125;); animator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animator) &#123; mSelectedPosition = position; mSelectionOffset = 0f; &#125; &#125;); animator.start(); &#125; &#125; onDraw 很简单 12345678910@Override public void draw(Canvas canvas) &#123; super.draw(canvas); // Thick colored underline below the current selection if (mIndicatorLeft &gt;= 0 &amp;&amp; mIndicatorRight &gt; mIndicatorLeft) &#123; canvas.drawRect(mIndicatorLeft, getHeight() - mSelectedIndicatorHeight, mIndicatorRight, getHeight(), mSelectedIndicatorPaint); &#125; &#125; TabView 接下来再看看上面的内容 1234567891011class TabView extends LinearLayout &#123; private Tab mTab; private TextView mTextView; private ImageView mIconView; private View mCustomView; private TextView mCustomTextView; private ImageView mCustomIconView; private int mDefaultMaxLines = 2; &#125; 如何实现监听的，对每个 TabView 设置点击事件，重写了 performClick，其中调用 mTab.select，mTab 拥有 TabLayout 的引用， 1234567891011121314151617181920212223@Override public boolean performClick() &#123; final boolean handled = super.performClick(); if (mTab != null) &#123; if (!handled) &#123; playSoundEffect(SoundEffectConstants.CLICK); &#125; mTab.select(); return true; &#125; else &#123; return handled; &#125; &#125; /** * Select this tab. Only valid if the tab has been added to the action bar. */ public void select() &#123; if (mParent == null) &#123; throw new IllegalArgumentException(&quot;Tab not attached to a TabLayout&quot;); &#125; mParent.selectTab(this); &#125; tabLayout 回调事件， 1234567891011121314151617181920212223242526272829303132333435void selectTab(Tab tab) &#123; selectTab(tab, true); &#125; void selectTab(final Tab tab, boolean updateIndicator) &#123; final Tab currentTab = mSelectedTab; if (currentTab == tab) &#123; if (currentTab != null) &#123; dispatchTabReselected(tab); animateToTab(tab.getPosition()); &#125; &#125; else &#123; final int newPosition = tab != null ? tab.getPosition() : Tab.INVALID_POSITION; if (updateIndicator) &#123; if ((currentTab == null || currentTab.getPosition() == Tab.INVALID_POSITION &amp;&amp; newPosition != Tab.INVALID_POSITION) &#123; // If we don&apos;t currently have a tab, just draw the indicator setScrollPosition(newPosition, 0f, true); &#125; else &#123; animateToTab(newPosition); &#125; if (newPosition != Tab.INVALID_POSITION) &#123; setSelectedTabView(newPosition); &#125; &#125; if (currentTab != null) &#123; dispatchTabUnselected(currentTab); &#125; mSelectedTab = tab; if (tab != null) &#123; dispatchTabSelected(tab); &#125; &#125; &#125; 移动 Tab，动画 1234567891011121314151617181920212223242526private void animateToTab(int newPosition) &#123; if (newPosition == Tab.INVALID_POSITION) &#123; return; &#125; if (getWindowToken() == null || !ViewCompat.isLaidOut(this) || mTabStrip.childrenNeedLayout()) &#123; // If we don&apos;t have a window token, or we haven&apos;t been laid out yet just dra // position now setScrollPosition(newPosition, 0f, true); return; &#125; final int startScrollX = getScrollX(); final int targetScrollX = calculateScrollXForTab(newPosition, 0); if (startScrollX != targetScrollX) &#123; ensureScrollAnimator(); mScrollAnimator.setIntValues(startScrollX, targetScrollX); mScrollAnimator.start(); &#125; // Now animate the indicator mTabStrip.animateIndicatorToPosition(newPosition, ANIMATION_DURATION); &#125; 计算移动的距离，让选中的 tab 位于中间位置，由于 Android ScrollView 默认不会滚动超出边界，所以如果到达边界也不会继续滚动了 1234567891011121314151617181920private int calculateScrollXForTab(int position, float positionOffset) &#123; if (mMode == MODE_SCROLLABLE) &#123; final View selectedChild = mTabStrip.getChildAt(position); final View nextChild = position + 1 &lt; mTabStrip.getChildCount() ? mTabStrip.getChildAt(position + 1) : null; final int selectedWidth = selectedChild != null ? selectedChild.getWidth() : 0; final int nextWidth = nextChild != null ? nextChild.getWidth() : 0; // base scroll amount: places center of tab in center of parent int scrollBase = selectedChild.getLeft() + (selectedWidth / 2) - (getWidth() / 2); // offset amount: fraction of the distance between centers of tabs int scrollOffset = (int) ((selectedWidth + nextWidth) * 0.5f * positionOffset); return (ViewCompat.getLayoutDirection(this) == ViewCompat.LAYOUT_DIRECTION_LTR) ? scrollBase + scrollOffset : scrollBase - scrollOffset; &#125; return 0; &#125; ViewPager 其实很简单，就是给 ViewPager 添加一个 OnPageChangeListener 就行了，代码也很简单，在 onPageScrolled 中改变 指示条 的位置，在 onPageSelected 中改变 选中状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static class TabLayoutOnPageChangeListener implements ViewPager.OnPageChangeListener &#123; private final WeakReference&lt;TabLayout&gt; mTabLayoutRef; private int mPreviousScrollState; private int mScrollState; public TabLayoutOnPageChangeListener(TabLayout tabLayout) &#123; mTabLayoutRef = new WeakReference&lt;&gt;(tabLayout); &#125; @Override public void onPageScrollStateChanged(final int state) &#123; mPreviousScrollState = mScrollState; mScrollState = state; &#125; @Override public void onPageScrolled(final int position, final float positionOffset, final int positionOffsetPixels) &#123; final TabLayout tabLayout = mTabLayoutRef.get(); if (tabLayout != null) &#123; // Only update the text selection if we&apos;re not settling, or we are settling after // being dragged final boolean updateText = mScrollState != SCROLL_STATE_SETTLING || mPreviousScrollState == SCROLL_STATE_DRAGGING; // Update the indicator if we&apos;re not settling after being idle. This is caused // from a setCurrentItem() call and will be handled by an animation from // onPageSelected() instead. final boolean updateIndicator = !(mScrollState == SCROLL_STATE_SETTLING &amp;&amp; mPreviousScrollState == SCROLL_STATE_IDLE); tabLayout.setScrollPosition(position, positionOffset, updateText, updateIndicator); &#125; &#125; @Override public void onPageSelected(final int position) &#123; final TabLayout tabLayout = mTabLayoutRef.get(); if (tabLayout != null &amp;&amp; tabLayout.getSelectedTabPosition() != position &amp;&amp; position &lt; tabLayout.getTabCount()) &#123; // Select the tab, only updating the indicator if we&apos;re not being dragged/settled // (since onPageScrolled will handle that). final boolean updateIndicator = mScrollState == SCROLL_STATE_IDLE || (mScrollState == SCROLL_STATE_SETTLING &amp;&amp; mPreviousScrollState == SCROLL_STATE_IDLE); tabLayout.selectTab(tabLayout.getTabAt(position), updateIndicator); &#125; &#125; void reset() &#123; mPreviousScrollState = mScrollState = SCROLL_STATE_IDLE; &#125;&#125; 小结 基本上看完了，但对于一些细节，滚动边界问题还没有深刻的理解，只知道大概的逻辑","categories":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/tags/Android/"},{"name":"TabLayout","slug":"TabLayout","permalink":"https://wzes.github.io/tags/TabLayout/"}]},{"title":"Android Recycview 分割线","slug":"Android/Android Recycview Devider","date":"2018-10-12T12:35:00.000Z","updated":"2019-09-02T12:17:39.545Z","comments":true,"path":"2018/10/12/Android/Android Recycview Devider/","link":"","permalink":"https://wzes.github.io/2018/10/12/Android/Android Recycview Devider/","excerpt":"","text":"最近有一个需求需要做分割线，网上有一些大致的做法，但感觉都不是那么通俗易懂，然后自己想了想，干脆自己弄吧，后面发现了一个比较好的，非常简洁，分享给大家 效果 代码 123456789101112131415161718192021222324252627class GridSpanDecoration extends RecyclerView.ItemDecoration &#123; private Paint mPaint; GridSpanDecoration(int color) &#123; mPaint = new Paint(); mPaint.setColor(color); mPaint.setStyle(Paint.Style.STROKE); &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); &#125; @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; drawVertical(c, parent); &#125; private void drawVertical(Canvas c, RecyclerView parent) &#123; final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); c.drawRect(child.getLeft(), child.getTop(), child.getRight(), child.getBottom(), mPaint); &#125; &#125;&#125; 原理就是给每个子view画一个边框就行了！是不是很简单","categories":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/tags/Android/"}]},{"title":"Effective Java3 介绍（翻译）","slug":"Book Notes/Effective Java3 介绍","date":"2018-09-30T14:18:00.000Z","updated":"2019-09-02T12:22:04.691Z","comments":true,"path":"2018/09/30/Book Notes/Effective Java3 介绍/","link":"","permalink":"https://wzes.github.io/2018/09/30/Book Notes/Effective Java3 介绍/","excerpt":"","text":"Introduction 本书旨在帮助您有效地使用 Java 编程语言及其基础库：java.lang，java.util 和 java.io，以及 java.util.concurrent 和 java.util.function等子包。 也会涉及到其他的类库。 本书一共九十小节，每个小节讲述了一条规则。 这些规则实践通常会使那些最优秀和最富有经验的程序员从中受益。 所有的内容分为11章，每章都涉及软件设计的一个广泛方面。 本书不打算从头到尾阅读：每个小节都或多或少地独立存在。 这些小节有很多交叉引用，因此您可以通过本书轻松绘制自己的课程。 自本书上一版出版以来，该平台增加了许多新功能。 本书中的大多数项目都以某种方式使用这些功能。 此表显示了主要功能的主要覆盖范围: 大多数项目都用程序示例说明。 本书的一个关键特性是它包含说明许多设计模式和习语的代码示例。 在适当的情况下，它们与该领域的标准参考工作[Gamma95]相互参照。 许多小节包含一个或多个程序示例，说明了要避免的一些实践。 这样的例子，有时被称为反模式，清楚地标有评论，例如 //never do this！ 在每种情况下，该项目都解释了为什么示例不好并提出了另一种方法。 本书不适合初学者：它假设您已经熟悉Java。 如果不是，请考虑许多优秀的入门级书籍之一，例如Peter Sestoft的Java Precisely [Sestoft16]。 虽然Effective Java旨在让任何具有该语言工作知识的人都可以阅读，但它应该为高级程序员提供思考的空间。 本书中的大多数规则都源于一些基本原则。 清晰和简洁至关重要。 组件的用户不应该对其行为感到惊讶。 组件应尽可能小，但不能小。 （正如本书中所使用的，术语组件是指任何可重用的软件元素，从单个方法到由多个包组成的复杂框架。）代码应该被重用而不是被复制。 组件之间的依赖关系应保持最小。 错误应该在发生后尽快检测到，理想情况是在编译时。 虽然本书中的规则并非100％适用，但在绝大多数情况下，它们都是最佳编程实践的特征。你不应该盲目地遵守这些规则，而只是偶尔并且有充分的理由违反这些规则。像大多数其他学科一样，学习编程艺术包括首先学习规则，然后学习何时打破规则。 在大多数情况下，本书不涉及性能。它是关于编写清晰，正确，可用，健壮，灵活和可维护的程序。如果你能做到这一点，那么获得所需的性能通常是一件相对简单的事情（第67条）。有些项目确实讨论了性能问题，其中一些项目提供了性能数据。使用短语“在我的机器上”引入的这些数字应该被认为是最近的。 值得一提的是，我的机器是老旧的自制3.5GHz四核英特尔酷睿i7-4770K，配备16千兆位DDR3-1866 CL9内存，运行Azul的Zulu 9.0.0.15版本的OpenJDK，在Microsoft Windows 7 Professional SP1（64-位）。 在讨论Java编程语言及其库的功能时，有时需要参考特定版本。 为方便起见，本书使用昵称而不是正式版本名称。 此表显示版本名称和昵称之间的映射： 这些例子相当完整，但有利于完整性的可读性。他们可以自由地使用java.util和java.io包中的类。为了编译示例，您可能必须添加一个或多个导入声明或其他此类样板。该书的网站http://joshbloch.com/effectivejava包含每个示例的扩展版本，您可以编译和运行它。 在大多数情况下，本书使用了Java语言规范Java SE 8 Edition [JLS]中定义的技术术语。一些术语值得特别提及。该语言支持四种类型：接口（包括注释），类（包括枚举），数组和基元。前三个被称为参考类型。类实例和数组是对象;原始值不是。类的成员由其字段，方法，成员类和成员接口组成。方法的签名由其名称和形式参数的类型组成;签名不包括方法的返回类型。 本书使用的几个术语与Java语言规范不同。与Java语言规范不同，本书使用继承 inheritance 作为子类 subclassing 的同义词。本书不是对接口使用术语继承，而是简单地声明一个类实现一个接口或一个接口扩展另一个接口。要描述在未指定时应用的访问级别，本书使用传统的package-private而不是技术上正确的包访问[JLS，6.6.1]。 本书使用了一些未在Java语言规范中定义的技术术语。术语“导出API”或简称“API”是指程序员访问类，接口或包时所使用的类，接口，构造函数，成员和序列化形式。 （API是应用程序编程接口的缩写，优先于其他优选的术语接口，以避免与该名称的语言结构混淆。）编写使用API​​的程序的程序员被称为作为API的用户。其实现使用API​​的类是API的客户端。 类，接口，构造函数，成员和序列化表单被统称为API元素。导出的API包含可在定义API的包之外访问的API元素。这些是任何客户端都可以使用的API元素，并且API的作者承诺支持。并非巧合的是，它们也是Javadoc实用程序以其默认操作模式生成文档的元素。简而言之，包的导出API由包中每个公共类或接口的公共成员和受保护成员以及构造函数组成。 在Java 9中，模块系统被添加到平台中。如果库使用模块系统，则其导出的API是库的模块声明导出的所有包的导出API的并集。","categories":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"Java8 Unsafe 解开你神秘的面纱","slug":"Java/Java8 Unsafe 解开你神秘的面纱","date":"2018-09-16T16:05:00.000Z","updated":"2019-09-02T12:21:22.388Z","comments":true,"path":"2018/09/17/Java/Java8 Unsafe 解开你神秘的面纱/","link":"","permalink":"https://wzes.github.io/2018/09/17/Java/Java8 Unsafe 解开你神秘的面纱/","excerpt":"","text":"前言 Unsafe 类一直是个很神秘的角色，我们普通开发者几乎不会碰到，顶多也是使用了并发包之类的系统类库，间接使用到了而已。那它到底是用来做什么的呢？它提供了我们直接操作内存的接口。Java 本身作为一个内存自动管理的工具，内存的开辟释放由虚拟机代为管理，然而，HotSpot 的设计者留下了 Unsafe 的类，用于扩展，它可以直接开辟内存，释放内存，读取任意地址的内存，而不受 Java 堆内存的限制。尽管如此，它并不能为我们所用，加载这个类只能由系统的类加载器执行，但我们可以通过反射获取到它的实例对象，Java 反射的确很牛啊。 如何获取实例对象 第一个问题：为什么我们需要通过 Field 获取，不能使用 newInstance 获取呢？ 通过 newInstance 的方法获取实力需要构造函数是 public 的，否则会抛异常，及时 getUnsafe 是静态函数，我们也不能通过这个去获取，因为这时候类加载不是系统的，会抛异常 123456789101112private Unsafe() &#123;&#125;@CallerSensitivepublic static Unsafe getUnsafe() &#123; Class var0 = Reflection.getCallerClass(); if (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123; throw new SecurityException(&quot;Unsafe&quot;); &#125; else &#123; return theUnsafe; &#125;&#125; 1Unsafe unsafe = Unsafe.class.newInstance(); 由于 Unsafe 是单例，当类加载时，theUnsafe 实例会被加载，这样我们就可以通过反射获取这个实例 123456static &#123; registerNatives(); Reflection.registerMethodsToFilter(Unsafe.class, new String[]&#123;&quot;getUnsafe&quot;&#125;); // 重点 theUnsafe = new Unsafe();&#125; 通过 Field 获取 12345public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123; Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); theUnsafe.setAccessible(true); Unsafe unsafe = (Unsafe) theUnsafe.get(null);&#125; 获取到这实例，就可以干很多事情了… 先来看看 API 图 太多了，眼睛都看瞎了 归个类吧 直接操作内存，将某个对象的值更改，读取，比如将 String 的 value 更改，是不是很神奇，这个是用反射也可以更改哦！下次面试的时候可以考考别人 String 的 value 怎么才能改的掉，看他会几种。 123456789101112String str = &quot;Hello Unsafe&quot;;Field value = str.getClass().getDeclaredField(&quot;value&quot;);unsafe.putObject(str, unsafe.objectFieldOffset(value), new char[]&#123;&apos;M&apos;, &apos;a&apos;, &apos;j&apos;, &apos;i&apos;, &apos;c&apos;&#125;);]System.out.println(str);// output: Majic// throw exceptionString str = &quot;Hello Unsafe&quot;;Field value = str.getClass().getDeclaredField(&quot;value&quot;);value.setAccessible(true);value.set(str, new char[] &#123;&apos;f&apos;, &apos;i&apos;, &apos;n&apos;, &apos;a&apos;, &apos;l&apos;&#125;); CompareAndSwap 著名的 CAS 为了保证并发安全， CAS 涉及到的变量应该使用 volatile 修饰，保证读到的值最新 allocateInstance 新建一个没有初始化的实例，各个值都是默认值 compareAndSwapLong 第一个参数是 object，第二个参数是变量内存偏移值，可以用 unsafe 类获取实际偏移值，第三个参数是 期望值，第四个三叔目标值，大致的语义就是：如果内存中是期望值，我就更新为目标值，否则不更新 12345678910111213141516171819202122232425public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123; Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); theUnsafe.setAccessible(true); Unsafe unsafe = (Unsafe) theUnsafe.get(null); InnerClass o = (InnerClass)unsafe.allocateInstance(InnerClass.class); o.print(); // print 100 Field a = o.getClass().getDeclaredField(&quot;value&quot;); unsafe.putLong(o, unsafe.objectFieldOffset(a), 10000); o.print(); // print 10000 unsafe.compareAndSwapLong(o, unsafe.objectFieldOffset(a), 10000, 1111); o.print(); // print 1111 unsafe.compareAndSwapLong(o, unsafe.objectFieldOffset(a), 1000, 10000); o.print(); // print 1111&#125; static class InnerClass &#123; // 保证内存可见性 private volatile long value; InnerClass() &#123; value = 100L; &#125; void print() &#123; System.err.println(&quot;value==&gt;&quot; + value); &#125;&#125; 线程挂起，取消 使用 unsafe.unpark 可以取消 Thread.sleep() 后者 park 的线程 使用 unsafe.park(false, 1000000000) 可以挂起当前线程，第一个参数表示是isAbsolute，是否是绝对时间，后一个参数为时间，flase 表示相对时间，0表示一直挂起，单位为纳秒；true 表示绝对时间，单位为毫秒，System.currentThreadMillis 搭配使用 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InstantiationException, InterruptedException &#123; Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); theUnsafe.setAccessible(true); Unsafe unsafe = (Unsafe) theUnsafe.get(null); InnerThread innerThread = new InnerThread(unsafe); innerThread.run(); Thread.sleep(20); // 取消挂起 unsafe.unpark(innerThread);&#125;static class InnerThread extends Thread &#123; Unsafe unsafe; InnerThread(Unsafe unsafe) &#123; this.unsafe = unsafe; &#125; @Override public void run() &#123; System.out.println(&quot;start&quot;); try &#123; Thread.sleep(1000L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //unsafe.park(false, 1000000000L); System.out.println(&quot;end&quot;); &#125;&#125; 小结 以后又可以吹一波了，一箭双雕，反射，Unsafe","categories":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"Java8 ArrayList & LinkedList 要点","slug":"Java/Java8 ArrayList&LinkedList 要点","date":"2018-09-13T11:03:00.000Z","updated":"2019-09-02T12:20:44.088Z","comments":true,"path":"2018/09/13/Java/Java8 ArrayList&LinkedList 要点/","link":"","permalink":"https://wzes.github.io/2018/09/13/Java/Java8 ArrayList&LinkedList 要点/","excerpt":"","text":"前言 为什么会想写这东西呢？这是我们都非常常用的数据结构，然而平时除了添加，遍历操作，很少使用其他功能，即使是这样，我们也存在万般理由搞清楚他们的 API，这对于我们在编程时如何选择二者具有良好的指导意义。所以，我觉得好好看看这二者的区别，之前一直以为只是 ArrayList 和 LinkedList 只是数组和链表的区别，我已经大错特错了， Java8 的实现远远不止于此，LinkedList 还有双端队列的功能，之前一直没注意到，最近发现 ArrayDeque，却没有看到 LinkedDeque，恍然想起 LinkedList 实现了 Deque 接口，这才恍然大悟～～ ArrayList &amp; LinkedList 他们的区别从实现的接口上也可以看出来， LinkedList 多实现了一个接口，下次面试官再问到，我们可以谈谈这个问题，面试官会另眼相看的，面试官就喜欢深入研究的 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable ArrayList 原理 初始大小为 10，transient Object[] elementData 用来存储元素 1234567891011121314151617181920212223242526272829/** * Default initial capacity. */private static final int DEFAULT_CAPACITY = 10;/** * Shared empty array instance used for empty instances. */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; transient Object[] elementData; // non-private to simplify nested class accessprivate int size;public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125;&#125;public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; add 方法，首先检查容量，检查的时候首先在是否是空的，获取一个最小容量，才去执行扩容，为 elementData 赋值 123456789101112131415161718192021public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 扩容策略，每次增长 1/2 1234567891011private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 如果你想在数组中确定某一个元素的话，那么需要遍历，有两种遍历方式，可根据场景自行选择 12345678910111213141516171819202122232425public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; toArray 通常需要进行类型强转 123public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125; 获取某个索引的元素，我们看到也是强转类型 12345678910111213141516E elementData(int index) &#123; return (E) elementData[index];&#125;/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; 还有 set 方法，覆盖之前的值，返回旧值 1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 插入，需要移动之后的所有元素 123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 删除某个索引的元素，同样需要移动元素 1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 删除某个 object，看到了 fastRemove，只不过是去除了边界验证 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; LinkedList 由于是链表，很多首尾节点的插入删除操作，方便了很多 属性 很简单的三个属性 123456789101112131415transient int size = 0;/** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */transient Node&lt;E&gt; first;/** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */transient Node&lt;E&gt; last; node 静态内部类，根据 Effective Java 的描述，这种设计是比较好的。 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 我们简单看一些方法即可，由于实现了 Deque，大部分操作非常相似 add 在尾部添加元素，无需边界检查 12345678910111213141516public boolean add(E e) &#123; linkLast(e); return true;&#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; 获取元素，需要注意的是为了加快速度，会判断更接近后边还是前边，这样能省一般时间 12345678910111213141516171819public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 而 indexOf(Object o) 就没这个幸运了，必须老老实实从头开始 1234567891011121314151617public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125; 一些关于队列的操作，注意方法的返回值，如果出现为空是否会抛出异常呢，像 element pop remove 会抛异常，而 peek，poll 则不会，这些都要注意，否则一不小心就会引发惨案！！！ 12345678910111213141516171819202122232425262728293031323334353637public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125;/** * Retrieves, but does not remove, the head (first element) of this list. * * @return the head of this list * @throws NoSuchElementException if this list is empty * @since 1.5 */public E element() &#123; return getFirst();&#125;public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125;/** * Retrieves and removes the head (first element) of this list. * * @return the head of this list, or &#123;@code null&#125; if this list is empty * @since 1.5 */public E poll() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125;public E pop() &#123; return removeFirst();&#125; 其它的便不贴代码了，都很好理解了 小结 总的来说，对这两个东西的用法更加清晰了，来龙去脉摸得更准确了～","categories":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"Java8 ArrayDeque 源码解析","slug":"Java/Java8 ArrayDeque 源码解析","date":"2018-09-12T15:36:00.000Z","updated":"2019-09-02T12:20:38.220Z","comments":true,"path":"2018/09/12/Java/Java8 ArrayDeque 源码解析/","link":"","permalink":"https://wzes.github.io/2018/09/12/Java/Java8 ArrayDeque 源码解析/","excerpt":"","text":"前言 今天我们来看看 ArrayDeque，可以说，之前使用的队列的场景不多，所以也没有深入研究队列，但最近在做 LeetCode 的时候，很多时候使用队列会有想不到的功效，比如我们在写 BFS 广度优先遍历的时候，或者在写 二叉树的层次遍历，非递归前序，中序，后序遍历，都会用到这个结构，如果还不会的同学，赶紧去复习一波吧，非常总要，也能为你的笔面试加不少分，很多时候当面试官问道我分析过的源码时，心里那个叫酸爽啊，令面试官刮目相看。闲话不多说了，让我们深入了解一下我们的主角 前世今生 实现了 Deque 接口，Deque 继承了 Queue 1234public class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Deque&lt;E&gt;, Cloneable, Serializable &#123;&#125;public interface Deque&lt;E&gt; extends Queue&lt;E&gt; &#123;&#125; Queue 在了解 ArrayDeque 之前，我们先来看看 Queue 有些什么东西，谈到队列，我们会想到先进先出等特性，我把接口贴出来给大家看一下，如果你还不熟悉这几个方法的区别，是该反省一下了！！！一定要熟记，这是基本功 1234567891011boolean add(E e);boolean offer(E e);E remove();E poll();E element();E peek(); Deque 由于是双端队列，多了很多接口，一张图真相，你可能会说，记住这些所有的太难了，太多了，但总结起来，也并不多，在之前的Queue的接口的基础上，加了 First，Last 的接口，是不是一下子变少了 ArrayDeque 终于到了我们的主角了，然而你可能会想，是不是也有LinkedDeque，当初我也这样想过，然而我并没有在 jdk 里找到这个数据结构，但是 LinkedList 却实现了 Deque 也就是说它取代了自己LinkedDeque，也就没有必要多此一举了 属性 既然是 Array，那么里面势必用数组存储，记住，使用 Object[] elements,而不是T[] elements,聪明的你能否想到这样做的目的呢？哈哈。然后是一个head，tail 的指针。 1234567891011121314transient Object[] elements; // non-private to simplify nested class access /** * The index of the element at the head of the deque (which is the * element that would be removed by remove() or pop()); or an * arbitrary number equal to tail if the deque is empty. */ transient int head; /** * The index at which the next element would be added to the tail * of the deque (via addLast(E), add(E), or push(E)). */ transient int tail; 构造函数 默认开辟了 16 的数组，一般都是这样，预先开辟空间，不够了再扩容。如果自己指定了大小，那么将调用 allocateElements函数，获取一个 2 的幂次方的大小的容量，如果你知道 Hashmap的初始化，那么这个初始化你一定不陌生！至于怎么做到，你可以自己实践一下，这样会理解的更加透彻！ 12345678910111213141516171819202122232425262728293031323334public ArrayDeque() &#123; elements = new Object[16];&#125;public ArrayDeque(int numElements) &#123; allocateElements(numElements);&#125; public ArrayDeque(Collection&lt;? extends E&gt; c) &#123; allocateElements(c.size()); addAll(c);&#125;private void allocateElements(int numElements) &#123; elements = new Object[calculateSize(numElements)];&#125;private static int calculateSize(int numElements) &#123; int initialCapacity = MIN_INITIAL_CAPACITY; // Find the best power of two to hold elements. // Tests &quot;&lt;=&quot; because arrays aren&apos;t kept full. if (numElements &gt;= initialCapacity) &#123; initialCapacity = numElements; initialCapacity |= (initialCapacity &gt;&gt;&gt; 1); initialCapacity |= (initialCapacity &gt;&gt;&gt; 2); initialCapacity |= (initialCapacity &gt;&gt;&gt; 4); initialCapacity |= (initialCapacity &gt;&gt;&gt; 8); initialCapacity |= (initialCapacity &gt;&gt;&gt; 16); initialCapacity++; if (initialCapacity &lt; 0) // Too many elements, must back off initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements &#125; return initialCapacity;&#125; 普通的方法 add 使用 addLast 在末尾追加元素 1234public boolean add(E e) &#123; addLast(e); return true;&#125; addLast，直接给数组的末尾元素赋值，之后便是移动tail 指针，这里的扩容实现的很有意思，这也对应了为什么容量要为 2的幂次方，当数组大小刚好为 2 的幂次方时，(tail = (tail + 1) &amp; (elements.length - 1) 为零，也就是说如果head也为0，那么就需要扩容了 1234567public void addLast(E e) &#123; if (e == null) throw new NullPointerException(); elements[tail] = e; if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity();&#125; doubleCapacity 函数，新数组的大小为两倍，使用 System.arraycopy 函数复制，效率极高。因为 head 不一定为零，所以在扩容的时候，需要恢复head = 0；这里我们应该推测出整个数组都是存储数据，为了方便删除数组而不移动元素，便使用了指针记录状态，这一实现必须要好好琢磨，下次面试别人的时候可以问一下别人，哈哈，有点小坏 123456789101112131415private void doubleCapacity() &#123; assert head == tail; int p = head; int n = elements.length; int r = n - p; // number of elements to the right of p int newCapacity = n &lt;&lt; 1; if (newCapacity &lt; 0) throw new IllegalStateException(&quot;Sorry, deque too big&quot;); Object[] a = new Object[newCapacity]; System.arraycopy(elements, p, a, 0, r); System.arraycopy(elements, 0, a, r, p); elements = a; head = 0; tail = n;&#125; pollFirst 获取元素，当然是从 head 位置获取元素，这里需要注意的是，head 如果到了数组末尾，那么又会通过 (h + 1) &amp; (elements.length - 1) 变为 0 了 1234567891011public E pollFirst() &#123; int h = head; @SuppressWarnings(&quot;unchecked&quot;) E result = (E) elements[h]; // Element is null if deque empty if (result == null) return null; elements[h] = null; // Must null out slot head = (h + 1) &amp; (elements.length - 1); return result;&#125; pollLast 获取队尾元素，如果队尾元素此时为 0，那么将回到了 数组末尾，别问我怎么知道，老师叫你好好学二进制！ 12345678910public E pollLast() &#123; int t = (tail - 1) &amp; (elements.length - 1); @SuppressWarnings(&quot;unchecked&quot;) E result = (E) elements[t]; if (result == null) return null; elements[t] = null; tail = t; return result;&#125; 其他的不涉及到删除，添加到操作就显得尤为简单了，直接获取，就不必多说了 123456789101112131415161718public E getFirst() &#123; @SuppressWarnings(&quot;unchecked&quot;) E result = (E) elements[head]; if (result == null) throw new NoSuchElementException(); return result;&#125;/** * @throws NoSuchElementException &#123;@inheritDoc&#125; */public E getLast() &#123; @SuppressWarnings(&quot;unchecked&quot;) E result = (E) elements[(tail - 1) &amp; (elements.length - 1)]; if (result == null) throw new NoSuchElementException(); return result;&#125; pop 根据先进先出，pop 应该移除队首的元素，注意，这里会抛出异常，如果队首为空的话 12345 * @throws NoSuchElementException &#123;@inheritDoc&#125; */public E pop() &#123; return removeFirst();&#125; 小结 ArrayDeque 看起来不大，但也有不少东西，知道大概容易，弄懂每一个细节很难，如果你做到了，成功便是你的~","categories":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"Android IntentService 源码解析","slug":"Android/IntentService","date":"2018-09-06T15:04:00.000Z","updated":"2019-09-02T12:18:51.162Z","comments":true,"path":"2018/09/06/Android/IntentService/","link":"","permalink":"https://wzes.github.io/2018/09/06/Android/IntentService/","excerpt":"","text":"前言 顾名思义，是一个 Service，先说和普通的 Service 的区别吧，普通的 Service 通常运行在主线程，而 IntentService 的处理逻辑在子线程里，另外 Service 需要自己去 destroy，而 IntentService 在处理完自己的逻辑时会自动结束，那他是怎么实现线程切换，主要还是 Handler 机制，内部有一个 HandleThread，关于这个，可以查看 [HandlerThread 源码解析] (https://www.jianshu.com/p/5ff83236c8e2) 前世今生 1public abstract class IntentService extends Service &#123;&#125; 继承自 Service，拥有 Service 的特性，不熟悉 Service 的同学可以自行百度，面试必问的，然而感觉我还是不想深入了解，以后再说吧 记住 12onCreate -&gt; onStartCommand -&gt; onDestroyonCreate -&gt; onBind -&gt; onUnbind 自己写一个 IntentService 1public class MyIntentService extends IntentService &#123;&#125; 源码解析 很熟悉的 Looper 和 ServiceHandler 12345678910111213141516private volatile Looper mServiceLooper;private volatile ServiceHandler mServiceHandler;private String mName;private boolean mRedelivery;private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125;&#125; 看一下 onCreate，初始化了一个 HandlerThread，然后再把他的 Looper 拿出来，然后抛弃了它，这个 Looper 是子线程的 Looper，因此事件处理也发生在子线程。利用这个 Looper 新建了一个 Handler 12345678910111213@Override public void onCreate() &#123; // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; 启动以后调用 onStart，发送一个消息，onHandleIntent((Intent)msg.obj) 里面进行处理，我们要重写这个方法，通常这个在子线程中运行 12345678910111213 @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; &#125;@Override public void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); &#125; 处理完即关闭，不需要手动关闭 12345678910111213141516171819public final void stopSelf() &#123; stopSelf(-1);&#125;/** * Old version of &#123;@link #stopSelfResult&#125; that doesn&apos;t return a result. * * @see #stopSelfResult */public final void stopSelf(int startId) &#123; if (mActivityManager == null) &#123; return; &#125; try &#123; mActivityManager.stopServiceToken( new ComponentName(this, mClassName), mToken, startId); &#125; catch (RemoteException ex) &#123; &#125;&#125; 在我们自己的 IntentService 里面，写处理的逻辑，由于是在子线程中，所以可以处理耗时的逻辑，不必担心 ANR，普通 Service 由于在主线程运行，所以不能直接处理耗时逻辑 123456789101112131415@Overrideprotected void onHandleIntent(Intent intent) &#123; if (intent != null) &#123; final String action = intent.getAction(); if (ACTION_FOO.equals(action)) &#123; final String param1 = intent.getStringExtra(EXTRA_PARAM1); final String param2 = intenonHt.getStringExtra(EXTRA_PARAM2); handleActionFoo(param1, param2); &#125; else if (ACTION_BAZ.equals(action)) &#123; final String param1 = intent.getStringExtra(EXTRA_PARAM1); final String param2 = intent.getStringExtra(EXTRA_PARAM2); handleActionBaz(param1, param2); &#125; &#125;&#125; 小结 非常简单的 IntentService，使用的时候注意与普通 Service 的区别即可，里面使用了 HandlerThread 获取 Looper 对象，处理完会自动关闭，即调用 onDestroy，再次启动又重新走 Service 的生命周期，一个问题，如果多次 startService，那么 onHandleIntent 是怎么样的呢？答案是一次执行，因为 Looper 事件处理是阻塞的","categories":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/tags/Android/"}]},{"title":"BloomFilter&Hyperloglog 去重&统计","slug":"Backend/BloomFilter&Hyperloglog 去重&统计","date":"2018-09-06T04:53:00.000Z","updated":"2019-09-02T12:20:13.771Z","comments":true,"path":"2018/09/06/Backend/BloomFilter&Hyperloglog 去重&统计/","link":"","permalink":"https://wzes.github.io/2018/09/06/Backend/BloomFilter&Hyperloglog 去重&统计/","excerpt":"","text":"去重小结 最近在做爬虫的时候，遇到了去重的问题，关于去重，有很多地方可以做，比如 内存级别，利用 hashmap，准确，性能好但是内存有限 数据库，利用唯一键，准确，存储量大但是性能差 内存级别 BloomFilter，利用 bitmap，性能好，存储量比 hashmap 大得多，但是有误差 实际使用的时候要根据场景去 tradeoff，没有最好的办法，只有最合适的办法 基数统计 同样，当我们需要统计个数时，也有很多办法，比如 内存级别 hashset，准确，但是存储量跟数据量成正比，原始数据还存在 数据库也可以做，准确但性能较差 内存级别，Hyperloglog，只需少量内存即可，但误差较大 如果我们单单只是技术统计，对准确率要求并不高，可以采取 Hyperloglog，只不过没有记录原始数据，但这恰好为节省内存埋下了伏笔 BloomFilter 原理 有 k 个 hash 函数，对每一个 key 进行 hash 函数计算大小，将 m 位 0 字符串在对应的取余赋值为 1 即可 检查是否存在：计算 key 对应的 k 个 hash值在字符串中的位是否全为 1，如果是，则有可能存在，否则肯定不存在 例子， key = bloom hashcode = [1, 2, 3] 1011100000000000000000 接下来 key = filter 经过同样的 hash 计算 hashcode = [2,4,6] 经过计算不存在，则放入 1011101000000000000000 实际应用中如何选择 m，k，f 的大小，有一个数据公式推导，大家可以自行 Google HyperLogLog 原理 使用概率的原理 这篇文章还不错 https://blog.csdn.net/firenet1/article/details/77247649 总结一下，就是说，我们丢硬币的场景，第一次出现正面，之前都是反面的概率与实验次数有一个关系 n = 2^k，那么我们将 key 映射成 二进制hashcode，0001010, 该过程完全随机，那么 n 就等于 2^4，也就是说试验次数达到 8，但误差较大，所以我们采用多个映射取平均，这样误差就会变小 但是这样的误差很大 大家可以看看 stream-lib 里边的实现，很经典 欢迎讨论～","categories":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"Geohash&Haversine 附近功能","slug":"Backend/Geohash&Haversine 附近功能","date":"2018-09-06T01:13:00.000Z","updated":"2019-09-02T12:20:19.747Z","comments":true,"path":"2018/09/06/Backend/Geohash&Haversine 附近功能/","link":"","permalink":"https://wzes.github.io/2018/09/06/Backend/Geohash&Haversine 附近功能/","excerpt":"","text":"前言 最近偶然间看到了 Geohash 算法，才想起来之前自己做过的附近的功能简直不堪一击，竟然是计算所有与目标点的距离，再排序。想必有经验的人早就笑出声了吧，按照以前的水平，如果不这样做，那也得找出比较相近的，先不计算球面距离，然后得到一个小一点的集合，再计算距离，这样计算量大大减小，然而还是要扫描所有点，那有没有办法不扫描整张表就能得到附近点的信息，想到这，我们而已给所有点预先做一个标签，我们每一次想找附近的点就去比较这些标签，如果我们能够保证，距离相近的点在一个标签内，那么我们就可以只取该标签的点，然后再做距离计算，这样就不用扫描整张表了，问题到这，基本已经浮出水面，接下来就是最核心的问题，如何将点的信息映射成标签，这便是 Geohash https://en.wikipedia.org/wiki/Geohash wiki 上有所解释，但不是那么易懂，可以看看这位仁兄的博客，GeoHash核心原理解析 讲解清晰易懂 相似度 Geohash 将经纬度映射成一段字符串，越是相近的点，前缀匹配就越长，每一位都会有一个精度问题，匹配的越长距离就越近，当然也存在误差 利用这个来做附近的点选取再合适不过了。 Haversine 计算球面距离 传统的计算球面距离公式计算量大，当我们没有要求很高的精度的时候，可以适当通过别的更简单的计算公式得到近似的结果，这便是 Haversine 发挥的作用","categories":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"Android Rxjava 源码解析","slug":"Android/Android Rxjava","date":"2018-09-04T16:15:16.000Z","updated":"2019-09-02T12:17:44.173Z","comments":true,"path":"2018/09/05/Android/Android Rxjava/","link":"","permalink":"https://wzes.github.io/2018/09/05/Android/Android Rxjava/","excerpt":"","text":"前言 RxJava 这个名字，想必做过 Android 的人都有所了解，简单的使用几乎不成问题，但里面的知识点却一向令人望而生畏，接下来几日我便想慢慢解开这层面纱 先来回归一下简单的例子 没有线程切换的最简单的版本，初学者一定很困惑，这段代码是怎么运行起来的，这段代码中最具核心的是 Observable，Observable 有一个方法是 subcribe，当调用这个方法时便调用了 ObservableOnSubscribe.subscibe 方法，里面调用了 e.onNext()，也就是调用了 Obersver 的 onNext 方法，整个的流程便是这样，围绕这个流程，便衍生出了线程切换，各种类型的任务，背压。。。。。。 1234567891011121314151617181920212223242526Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception &#123; e.onNext(&quot;hello&quot;); e.onNext(&quot;world&quot;); e.onComplete(); &#125;&#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(String o) &#123; System.out.println(o.toString()); &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125;&#125;); map 为了方便理解，举一个简单的例子，实际的Rajava 与之类似 映射，将一个 Observable 转化成另一个 Observable 的过程，主要是 onNext 的调用链的关系，实际想起来还是挺复杂的，一个递归的结构，每一个 map 操作都会封装一个 Observable 而他的参数是 MapSubscribe 的发射器，里面在调用 onNext 时穿进去的参数是 transformer.call 的结果，这就说明了如果有 map 存在，首先会递归到开始，然后调用离之最近的 mapSubcriber 的 call 函数，获取结果，并调用下一个发射器的onNext函数，知道调用最顶层的Subcriber的回调函数，该过程还是很有意思的 12345678910111213141516171819202122232425262728293031323334353637383940Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; subscriber.onNext(10); &#125; &#125;).map(new Observable.Transformer&lt;Integer, String&gt;() &#123; @Override public String call(Integer from) &#123; return String.valueOf(from); &#125; &#125;).map(new Observable.Transformer&lt;String, String&gt;() &#123; @Override public String call(String from) &#123; return String.valueOf(from + 10); &#125; &#125;).map(new Observable.Transformer&lt;String, String&gt;() &#123; @Override public String call(String from) &#123; return String.valueOf(from + 10); &#125; &#125;).subscribeOn(Schedulers.io()).subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onStart() &#123; System.out.println(&quot;onStart called&quot;+ &quot; &quot; + Thread.currentThread()); &#125; @Override public void onCompleted() &#123; System.out.println(&quot;onComplete called&quot;+ &quot; &quot; + Thread.currentThread()); &#125; @Override public void onNext(String object) &#123; System.out.println(object + &quot; &quot; + Thread.currentThread()); &#125; @Override public void onError(Throwable t) &#123; &#125; &#125;);","categories":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/categories/Android/"},{"name":"Java","slug":"Android/Java","permalink":"https://wzes.github.io/categories/Android/Java/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"Effective Java2 读书笔记78条","slug":"Book Notes/Effective-Java-2-读书笔记-78条","date":"2018-08-30T14:18:00.000Z","updated":"2019-09-02T12:21:59.163Z","comments":true,"path":"2018/08/30/Book Notes/Effective-Java-2-读书笔记-78条/","link":"","permalink":"https://wzes.github.io/2018/08/30/Book Notes/Effective-Java-2-读书笔记-78条/","excerpt":"","text":"第一条 考虑使用静态工厂方法代替构造器 优势 有名称 不必每次调用的时候都创建一个对象 返回原返回类型的所有子类型的对象 在创建参数实例化的时候，他们使代码变得更简洁 缺点 类如果不含有共有的或者受保护的类构造器，就不能被子类化 他们与其他的静态方法没什么区别 第二条 遇到多个构造器时要考虑用构建器 构造器参数多，个数多，则优先使用 Builder 模式，构建器比JavaBeans更加安全 123public interface Builder&lt;T&gt; &#123; public T build();&#125; 第三条 用私有构造器火鹤枚举类型强化singleton属性 单元素的枚举类型已经成为实现Singleton的最佳方法 1234public enum Elvis &#123; INSTANCE; public void leaveTheBuilding() &#123;&#125;&#125; 第四条 通过私有构造器强化不可实例化的能力 超类也不能被实例化 12345public class UtilityClass &#123; private UtilityClass() &#123; throw new AssertionError(); &#125;&#125; 第五条 避免创建不必要的对象 避免重复创建相同的对象 优先使用基本类型而不是装箱基本类型 不要盲目觉得创建对象代价十分昂贵，使用对象池的特例：数据库连接池，否则没必要创建对象池，会影响GC 第六条 消除过期的对象引用 常见的场景在与ArrayList，删除对象后需要把该索引位置置空。 监听器，其他回调 可使用 WeakHashMap 将键保持为弱引用 第七条 避免使用终结方法 终结方法通常是不可预测的，也是很危险的吗，一般情况下是不必要的。使用终结方法是很危险的。 终结方法线程的优先级比应用程序线程的优先级低很多 1234// 不保证 finalize 执行System.gc System.runFinaliaation// 保证执行System.runFinalizersOnExit Runtime.runFinalizersOnExit 第八条 覆盖 equals 时请遵守通用约定 类是私有的或是包级私有的，可以确定它的 equals 方法永远不会被调用。 防止方法被调用的方法 1234@Ovveridepublic boolean equals(Object o) &#123; throw new AssertionError();&#125; equals 方法实现了等价关系 自反性 对称性 传递性 一致性 一般做法 123456789101112@Overridepublic boolean equals(Object o) &#123; if (o == this) &#123; return true; &#125; if (!(o instanceOf MyClass)) &#123; return false; &#125; MyClass class = (MyClass) o; // 比较各个域值 ......&#125; 第九条 覆盖 equals 时总要覆盖 hashCode Object 规范（JavaSE6） 同一个对象多次调用必须一致，同一个程序多次执行可以不一致 equals 相等，hashCode 必然要相等 hashCode 相同，equals 不一定相同 一个好的散列函数通常倾向于“为不同的对象产生不相等的散列码” 如何计算： 把某个非零常熟值，比如说17，保存到一个名为 result 的 int 类型的变量中。 对于对象中每个关键域 f （指 equals 方法中涉及到的每个域），完成以下步骤： a. 为该域计算 int 类型的散列码 c ： 如果该域是 boolean 类型，则计算 （f ? 1 : 0） 如果该域是 byte ，char，short，int，则计算 （int）f 如果该域是 long，则计算（int）（f ^ （f &gt;&gt; 32）） 如果该域是 float，则计算 Float.floatToIntBits(f); 如果该域是 double，则计算 Double.doubleToLongBits(f), 然后按照步骤 a.3，计算 long 的散列值 如果该域是一个对象引用，并且该类的 equals 方法通过递归的调用 equals 的方式来比较这个域，则同样为这个域递归的调用 hashCode。如果这个域为 null， 则为 0 如果该域是一个数组，则需要把每一个元素当作单独的域来处理。 b. 按照下面的公式，把步骤2.a 中计算得到的散列码 c 合并到 result 中： result = 31 * result + c； 3. 返回 result 4. check 第十条 始终要覆盖 toString 建议所有的子类都应该覆盖这个方法 第十一条 谨慎的覆盖 clone 创建和返回该对象的一个拷贝，不必调用构造器创建对象 JavaSE6 的约定内容： x.clone() != x 为 true x.clone().getClass() == x.getClass() 为 true x.clone().equals(x) 为 true 一般写法，通过递归 super.clone() 创建对象，再将域逐个复制即可 第十二条 考虑实现 Comparable 接口 实现了 Comparable 接口，就表明它的实例具有内在的排序关系。 当然，也可以使用外在排序 Comparator 第十三条 使类和成员的可访问性最小化 设计良好的模块会隐藏所有的实现细节，把它的API与它的实现清晰的隔离开来。 尽可能地使每个类或成员不被外界访问 有四种访问性： 私有的（private） 包级私有的（default） 受保护的（protected） 共有的（public） 实例域不能是共有的 第十四条 在共有类中使用访问方法而非共有域 有时候，可能会编写一些退化类，没有什么作用，只是用来集中实例域 Java平台类库中有一些违反了，但应该警惕 共有类永远不应该暴露可变的域 第十五条 使可变性最小化 不可变类只是其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变，Java 平台类库中包含了许多不可变类，比如 String，基本类型包装类，BigDecimal 和 BigInteger。存在不可变的类有很多理由：不可变的类比可变的类更加容易设计，实现和使用。 原则 不要提供任何会修改对象状态的方法 保证类不会被扩展 使所有的域都是 final 的 使所有的域都是私有的 确保对于任何可变组件的互斥访问 第十六条 复合优先于继承 继承虽然是实现代码重用的有力手段，但它会打破封装性。而复合可以解决这个问题，只有当子类是超类的子类型时，才适用继承（is-a关系）。Java 平台类库中 Stack和Vector，Properties和Hashtable 违反了这个原则 第十七条 要么为继承而设计，并提供文档说明，要么就禁止继承 对于专门为了继承而设计的类需要具有良好文档说明，该文档必须精确的描述覆盖每个方法所带来的影响 构造器绝不能调用可被覆盖的方法 第十八条 接口优于抽象类 Java 程序设计语言提供了两种机制，可以用来定义允许多个实现的类型：接口和抽象 现有的类很容易被更新，以实现新的借口 接口是定义mixin（混合类型）的理想选择 接口允许我们构造非层次结构的类型框架 第十九条 接口只用于定义类型 接口应该只被用来定义类型，不应该被用来导出常量 导出常量的做法： 12345public class PhysicalConstants &#123; // 私有 private PhysicalConstants() &#123;&#125; public static final double AVOGADROS_NUMBER = 6.02214199e23;&#125; 第二十条 类层次优先于标签类 标签类使得类变得复杂难懂，考虑使用类层次替换 域是不能做成 final 的 第二十一条 用函数对象表示策略 简而言之，函数指针的主要用途就是实现策略模式。为了在 Java 中实现这种模式，要声明一个接口来表示该策略，并且为每个具体的策略声明实现一个该接口的类。当一个具体策略只被使用一次的时候，通常使用匿名类的方式和实例化这个具体策略类。当一个具体策略是设计用来重复使用的时候，他的类通常就要实现为私有的静态成员类，并通过共有的静态final域被导出，其类型为该策略接口。 第二十二条 优先考虑静态成员类 嵌套类被定义为在另外一个类的内部的类，有四种：静态成员类，非静态成员类，匿名类，局部类，后三者为内部类； 第二十三条 请不要在新代码中使用原生态类型 例如，List 原生态类型不能再编译器发现类型转化错误，而使用范型则可以，更加安全 第二十四条 消除非受检警告 第二十五条 列表优先于数组 第二十六条 优先考虑范型 不能创建范型数组 第二十七条 优先考虑范型方法 12345678910public static &lt;T entends Comparable&lt;T&gt;&gt; T max(List&lt;T&gt; list) &#123; Iterator&lt;T&gt; i = list.iterator(); T result = i.next(); while (i.hasNext()) &#123; T t = i.next(); if (t.compareTo(result) &gt; 0) &#123; result = t&apos; &#125; &#125;&#125; 第二十八条 利用有限通配符来提升API的灵活性 第二十九条 优先考虑类型安全的异构容器 第三十条 用 enum 代替 int 第三十一条 用实例域代替序数 第三十二条 用 EnumSet 代替位域 第三十三条 用EnumMap 代替序数索引 第三十四条 用接口模拟可伸缩的枚举 虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟。 123456789101112public interface Operation &#123; double apply(double x, double y);&#125;public enum BasicOperation implements Operation &#123; PLUS(&quot;+&quot;) &#123; public double apply(double x, double y) &#123; return x + y; &#125; &#125; private final String symbol; BasicOperation(String symbol) &#123; this.symbol = symbol; &#125;&#125; 第三十五条 注解优先于命名模式 命名模式指的是：给一些类或者方法使用有特定约束的名字 第三十六条 坚持使用 Override 注解 坚持使用 Override 注解能够避免一些错误 第三十七条 用标记接口定义类型 标记接口是没有包含任何方法的接口，例如 Serializable 接口，不包含任何方法 第三十八条 检查参数的有效性 对于共有的可以使用 throws 说明方法会产生什么异常 对于私有的方法可以使用 assert 断言 简而言之，每当编写方法或者构造器的时候，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法提开头处，通过显式的检查来实施这些限制。 第三十九条 必要时进行保护性拷贝 简而言之，如果类具有从客户端得到或者返回客户端的可变组件，类就必须保护性地拷贝这些组件。如果拷贝的成本受到限制，并且类信任它的客户端不会不恰当的修改组件，就可以在文档中指明客户端的职责是不得修改受到影响的组件，以此来代替保护性拷贝 第四十条 谨慎设计方法签名 谨慎的选择方法的名称 不要过于追求提供便利的方法 避免过长的参数列表 第四十一条 慎用重载 安全而保守的策略是，永远不要导出两个具有相同参数树木的重载方法 第四十二条 慎用可变参数 第四十三条 返回零长度的数组或者集合，而不是null 返回类型为 List 或数组，长度为零是返回 Collections.empty(); 第四十四条 为所有导出的API元素编写文档注释 第四十五条 将局部变量的作用域最小化 第四十六条 for-each 循环优先于传统的for循环 第四十七条 了解和使用类库 第四十八条 如果需要精确的答案，请避免使用 float 和 double 第四十九条 基本类型优先于装箱基本类型 第五十条 如果其他类型更合适，则尽量避免使用字符串 第五十一条 当心字符串连接的性能 第五十二条 通过接口引用对象 应该优先使用接口而不是类来引用对象 第五十三条 接口优先于反射机制 第五十四条 谨慎的使用本地方法 第五十五条 谨慎的使用优化 第五十六条 遵守普遍接受的命名习惯 第五十七条 只有针对异常的情况才使用异常 第五十八条 对可恢复的情况使用受检异常，对编程错误使用运行时异常 第五十九条 避免不必要地使用受检的异常 第六十条 优先使用标准的异常 第六十一条 抛出与抽象相对应的异常 第六十二条 每个方法抛出的异常都要有文档 第六十三条 在细节消息中包含能捕获失败的消息 第六十四条 努力是失败保持原子性 第六十五条 不要忽略异常 第六十六条 同步访问共享的可变数据 第六十七条 避免过度同步 第六十八条 executor 和 task 优先于线程 第六十九条 并发工具优先于 wait 和 notify 第七十条 线程安全性的文档化 第七十一条 慎用延迟初始化 第七十二条 不要依赖于线程调度器 第七十三条 避免使用线程组 第七十四条 谨慎地实现 Serializble 接口 实现 Serializable 接口而付出第最大代价是，一旦一个类被发布，就大大降低了“改变这个类的实现” 的灵活性 第七十五条 考虑使用自定义的序列化形式 第七十六条 保护性的编写 readObject 方法 第七十七条 对于实例控制，枚举类型优先于 readResolve 第七十八条 考虑使用序列化代理代替序列化实例","categories":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"Java8 HashMap 源码解析","slug":"Java/Java8 HashMap 源码解析","date":"2018-08-27T07:30:00.000Z","updated":"2019-09-02T12:20:53.730Z","comments":true,"path":"2018/08/27/Java/Java8 HashMap 源码解析/","link":"","permalink":"https://wzes.github.io/2018/08/27/Java/Java8 HashMap 源码解析/","excerpt":"","text":"前言 即使自己写了两年 Java，然而对 HashMap 却望而生畏，虽然每次面试几乎都会问，即使我能将大部分知识点一一道来，令面试官瞠目结舌，然而也只有我自己知道，要是让自己重写，我肯定写不出来的，我并没有理解每一个地方，所以便想写出这篇文章，记录自己的学习，希望能理解每一个地方 前世今生 12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 我们有必要看一个 Map 的接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142public interface Map&lt;K,V&gt; &#123; int size(); boolean isEmpty(); boolean containsKey(Object key); boolean containsValue(Object value); V get(Object key); V put(K key, V value); V remove(Object key); void putAll(Map&lt;? extends K, ? extends V&gt; m); void clear(); Set&lt;K&gt; keySet(); Collection&lt;V&gt; values(); Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); boolean equals(Object o); int hashCode(); default V getOrDefault(Object key, V defaultValue) &#123; V v; return (((v = get(key)) != null) || containsKey(key)) ? v : defaultValue; &#125; default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) &#123; Objects.requireNonNull(action); for (Map.Entry&lt;K, V&gt; entry : entrySet()) &#123; K k; V v; try &#123; k = entry.getKey(); v = entry.getValue(); &#125; catch(IllegalStateException ise) &#123; // this usually means the entry is no longer in the map. throw new ConcurrentModificationException(ise); &#125; action.accept(k, v); &#125; &#125; default V putIfAbsent(K key, V value) &#123; V v = get(key); if (v == null) &#123; v = put(key, value); &#125; return v; &#125; default boolean remove(Object key, Object value) &#123; Object curValue = get(key); if (!Objects.equals(curValue, value) || (curValue == null &amp;&amp; !containsKey(key))) &#123; return false; &#125; remove(key); return true; &#125; default boolean replace(K key, V oldValue, V newValue) &#123; Object curValue = get(key); if (!Objects.equals(curValue, oldValue) || (curValue == null &amp;&amp; !containsKey(key))) &#123; return false; &#125; put(key, newValue); return true; &#125; default V replace(K key, V value) &#123; V curValue; if (((curValue = get(key)) != null) || containsKey(key)) &#123; curValue = put(key, value); &#125; return curValue; &#125; default V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) &#123; Objects.requireNonNull(mappingFunction); V v; if ((v = get(key)) == null) &#123; V newValue; if ((newValue = mappingFunction.apply(key)) != null) &#123; put(key, newValue); return newValue; &#125; &#125; return v; &#125; default V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; Objects.requireNonNull(remappingFunction); V oldValue = get(key); V newValue = remappingFunction.apply(key, oldValue); if (newValue == null) &#123; // delete mapping if (oldValue != null || containsKey(key)) &#123; // something to remove remove(key); return null; &#125; else &#123; // nothing to do. Leave things as they were. return null; &#125; &#125; else &#123; // add or replace old mapping put(key, newValue); return newValue; &#125; &#125; default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) &#123; Objects.requireNonNull(remappingFunction); Objects.requireNonNull(value); V oldValue = get(key); V newValue = (oldValue == null) ? value : remappingFunction.apply(oldValue, value); if(newValue == null) &#123; remove(key); &#125; else &#123; put(key, newValue); &#125; return newValue; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"Java8 InvocationHandler 动态代理 源码解析","slug":"Java/Java8 InvocationHandler动态代理源码解析","date":"2018-08-26T07:30:00.000Z","updated":"2019-09-02T12:20:58.315Z","comments":true,"path":"2018/08/26/Java/Java8 InvocationHandler动态代理源码解析/","link":"","permalink":"https://wzes.github.io/2018/08/26/Java/Java8 InvocationHandler动态代理源码解析/","excerpt":"","text":"前言 之前对动态代理了解仅仅在于表层，一直觉得高不可攀，今天点开了 Proxy 类，欲知故事如何，需 Read The Source Code，再加上看一些别人的文章，对照着自己对源码的理解，形成此文，通俗易懂，保你看后对动态代理又有了更加深入的理解 先看一个例子熟悉一下吧 先定义接口，之后我们再看，为什么JDK不能代理类，只能代理接口 12345678910public interface AddService &#123; /** * &lt;p&gt;Test method&lt;/p&gt; * * @param a number a * @param b number b * @return sum of a and b */ int add(int a, int b);&#125; 实现类 1234567public class AddServiceImpl implements AddService &#123; @Override public int add(int a, int b) &#123; return a + b; &#125;&#125; Handler，继承自InvocationHandler，该接口只有一个方法 invoke，你只需要实现它，然后利用反射 Object invoke = method.invoke(addService, args); 返回接口return invoke; 其他的你想干什么都行，当然你也完全改变这个这个实现，返回一些别的啥，坏事也是可以的。getProxy方法里面调用Proxy.newProxyInstance 获取一个代理对象 1234567891011121314151617181920public class AddServiceHandler implements InvocationHandler &#123; private AddService addService; public AddServiceHandler(AddService addService) &#123; this.addService = addService; &#125; public AddService getProxy() &#123; return (AddService) Proxy.newProxyInstance(addService.getClass().getClassLoader(), addService.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;before&quot;); Object invoke = method.invoke(addService, args); System.out.println(&quot;after&quot;); return invoke; &#125;&#125; 使用，首先获取创建实例对象，然后构造一个Handler，再通过Handler获取Proxy 对象，再调用接口的方法。我们一切的疑问，可能就在 getProxy，他到底返回了什么东西，能够让我们再调用接口方法的时候，执行的却是 实现的Service 的方法，并且加了一些其它实现，聪明的你可能会说，这用静态代理依然能够实现，并且要比动态代理来得简单，为什么还要这样复杂的实现。我现在能想到的是，静态代理的话，你可能需要为每一个代理接口实现一个代理 Handler，然而 InvocationHandler 的话，你只需要为类似的请求实现一个Handler，为程序的扩展提供了大大的空间。 1234567@Test public void dynamicProxyTest() &#123; AddService service = new AddServiceImpl(); AddServiceHandler addServiceHandler = new AddServiceHandler(service); AddService proxy = addServiceHandler.getProxy(); Assert.assertEquals(3, proxy.add(1, 2)); &#125; 看到这里，我们有很多疑问 Proxy.newProxyInstance() 返回的是什么东西 invoke 方法到底在哪调用 我们在 target 里面没有看到其它任何附带生成的 class，系统到底是怎么做的呢 那我们就要好好看看这些方法的实现原理 Proxy.newProxyInstance 1public class Proxy implements java.io.Serializable&#123;&#125; private 的构造方法，里面有一个 InvocationHandler，这个就是我们传入的 Handler，另外还有一个 proxyClassCache，一个代理类的缓存对象，我暂时不打算展开讲这个东西，还没搞明白，现在需要记住，这个存放这系统帮我们生成的代理类，用了WeakReference 实现， GC 的时候会被回收。 里面有两个参数传过去，KeyFactory() 先不管，ProxyClassFactory() 这个很重要，我们之后遇到了再说 123456789101112131415161718192021/** parameter types of a proxy class constructor */private static final Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler.class &#125;;/** * a cache of proxy classes */private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());/** * the invocation handler for this proxy instance. * @serial */protected InvocationHandler h;/** * Prohibits instantiation. */private Proxy() &#123;&#125; 为了理解方便，我将一些无关精要的代码剔除，留下最重要的两个方法，getProxyClass0(loader, intfs) 根据loader和intfs 获取代理类，通过这个方法我们获得一个新的类字节码，这个类是运行时生成的，通过这个代理类，getConstructor 获取构造对象，调用newInstance创建一个实例对象，newInstance是可以传参的，只需要调用 constructor 的构造方法参数必须是 InvocationHandler.class，所以我们传的是 this 对象。 123456789101112public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException&#123; /* * Look up or generate the designated proxy class. */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); return cons.newInstance(new Object[]&#123;h&#125;);&#125; 65535 限制，这个get 比较高级，直接从缓存拿，刚开始看到可能觉得有点纳闷，这个 proxyClassCache 之前遇到过了 1234567891011private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException(&quot;interface limit exceeded&quot;); &#125; // If the proxy class defined by the given loader implementing // the given interfaces exists, this will simply return the cached copy; // otherwise, it will create the proxy class via the ProxyClassFactory return proxyClassCache.get(loader, interfaces);&#125; get方法首先创建一个 valuesMap，获取subKey，里面比较重要的就是subKeyFactory.apply(key, parameter)，这个方法会帮我们生成代理类的subKey，另外之后会建立一个Factory，当使用get 的时候，便是真正生成 代理类的时候 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public V get(K key, P parameter) &#123; Objects.requireNonNull(parameter); expungeStaleEntries(); Object cacheKey = CacheKey.valueOf(key, refQueue); // lazily install the 2nd level valuesMap for the particular cacheKey ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey); if (valuesMap == null) &#123; ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = new ConcurrentHashMap&lt;&gt;()); if (oldValuesMap != null) &#123; valuesMap = oldValuesMap; &#125; &#125; // create subKey and retrieve the possible Supplier&lt;V&gt; stored by that // subKey from valuesMap Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter)); Supplier&lt;V&gt; supplier = valuesMap.get(subKey); Factory factory = null; while (true) &#123; if (supplier != null) &#123; // supplier might be a Factory or a CacheValue&lt;V&gt; instance V value = supplier.get(); if (value != null) &#123; return value; &#125; &#125; // else no supplier in cache // or a supplier that returned null (could be a cleared CacheValue // or a Factory that wasn&apos;t successful in installing the CacheValue) // lazily construct a Factory if (factory == null) &#123; factory = new Factory(key, parameter, subKey, valuesMap); &#125; if (supplier == null) &#123; supplier = valuesMap.putIfAbsent(subKey, factory); if (supplier == null) &#123; // successfully installed Factory supplier = factory; &#125; // else retry with winning supplier &#125; else &#123; if (valuesMap.replace(subKey, supplier, factory)) &#123; // successfully replaced // cleared CacheEntry / unsuccessful Factory // with our Factory supplier = factory; &#125; else &#123; // retry with current supplier supplier = valuesMap.get(subKey); &#125; &#125; &#125;&#125; ProxyClassFactory apply 不可不看，首先加载接口，然后使用ProxyGenerator.generateProxyClass 生成Class 字节码文件，最后再调用 defineClass0 对其加载后返回关键字，作为key，之后再根据这个key获取到真正的class 对象，到这里，Proxy类已经生成好，并且加载好了，直接返回，这个类是动态生成的，留在内存的数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;&#123; // prefix for all proxy class names private static final String proxyClassNamePrefix = &quot;$Proxy&quot;; // next number to use for generation of unique proxy class names private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) &#123; /* * Verify that the class loader resolves the name of this * interface to the same Class object. */ Class&lt;?&gt; interfaceClass = null; try &#123; interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + &quot; is not visible from class loader&quot;); &#125; /* * Verify that the Class object actually represents an * interface. */ if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + &quot; is not an interface&quot;); &#125; /* * Verify that this interface is not a duplicate. */ if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( &quot;repeated interface: &quot; + interfaceClass.getName()); &#125; &#125; String proxyPkg = null; // package to define proxy class in int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * Record the package of a non-public proxy interface so that the * proxy class will be defined in the same package. Verify that * all non-public proxy interfaces are in the same package. */ for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf(&apos;.&apos;); String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( &quot;non-public interfaces from different packages&quot;); &#125; &#125; &#125; if (proxyPkg == null) &#123; // if no non-public proxy interfaces, use com.sun.proxy package proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;; &#125; /* * Choose a name for the proxy class to generate. */ long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * Generate the specified proxy class. */ byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); &#125; &#125;&#125; 那我们可以调用ProxyGenerator.generateProxyClass来看一次下这个生成的类，把它写到文件里，这个类大概就是这个样子，就是我们通过getProxy获取到的实际类，之后就简单了，可以清楚的看到里面熟悉的add方法，是通过调用了 invoke 来实现的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public final class $Proxy11 extends Proxy implements Service &#123; private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy11(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int add(int var1, int var2) throws &#123; try &#123; return (Integer)super.h.invoke(this, m3, new Object[]&#123;var1, var2&#125;); &#125; catch (RuntimeException | Error var4) &#123; throw var4; &#125; catch (Throwable var5) &#123; throw new UndeclaredThrowableException(var5); &#125; &#125; public final int hashCode() throws &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;)); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;); m3 = Class.forName(&quot;proxy.Service&quot;).getMethod(&quot;add&quot;, Integer.TYPE, Integer.TYPE); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 至此，大部分逻辑已经搞清楚了，那我们大概知道了为什么这个过程要比直接创建对象要慢，那是因为他第一次的时候需要动态的去创建字节码，然后进行加载，初始化…虽然有缓存，但是由于使用了 WeakReference，GC后有可能会被回收，那么就得重新加载，一定程度上会降低效率，所以一般情况下，我们尽量避免这种动态生成类的方式，而是用在编译时生成类的方式取代，这便是 APT 技术的精髓。 小结 上面三个小问题都已经弄清楚了吧，现在对动态代理更加了解了些，另外一类 CGLIB，更改字节码的技术之后有时间会再去看 欢迎讨论～～～","categories":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"Android DiskLruCache 源码解析","slug":"Android/DiskLruCache","date":"2018-08-24T15:03:00.000Z","updated":"2019-09-02T12:18:17.487Z","comments":true,"path":"2018/08/24/Android/DiskLruCache/","link":"","permalink":"https://wzes.github.io/2018/08/24/Android/DiskLruCache/","excerpt":"","text":"前言 之前在看 LruCache 的时候，就像看看基于 Disk 版的 LruCache，当我看完 LruCache 后，如果是我自己去写，大概还是会基于 LruCache 去保留 key，根据这个 key 去做 LRU，只不过把值保存在硬盘里，这几面又有一个对应关系，Key 和 Value，如果说，一个Key 对应一个文件，那么就会好办得很多，直接根据 Key的值获取文件名，然后读取数据，或者写入数据，然而这样就会造成文件数和 Key 的个数线性增长，效果不见得会好，如果多个 Key 对应一个文件，那么就要考虑，这个 Key 的值在那个文件，哪一位置，想想这些，正式 key-value 数据库需要解决的问题，只不过人家的数据库是不会存在过期的，当然，Redis 是有过期的说法。 突然有一种想去了解一下内存数据库的实现的冲动，类似 Redis，我记得里面的数据结构有使用 SkipList 来做，插入，删除都能在一定的时间范围内，当然红黑树也是比较合适，就是如何快速找到这个 Key 相关信息，然后找出数据的存在位置。这期间可能你想做到数据一部分加载入内存，一部分在硬盘，这样理论上数据库的存储空间便是磁盘的存储空间，我们可以根据某个策略，当热点数据存放在内存，冷数据存放硬盘，82原则，这有点类似操作系统的内存管理，我们可以利用 Lru 对我们的内存进行管理，当然这可能比全部加载进内存要慢得多，但大部分数据在内存，速度要比每次从磁盘要快得多。带着这样的疑虑，我们看一下 Jake大神的 DiskLruCache DiskLruCache 是什么？ 这是一个非常短小精悍的Key-Value，基于Lru的原则实现的Cache，value只能为字符串，所以你得将你想要存的数据转化成字符串格式，然后再存，这使得这个库局限于字符串，但为了短小，也没办法 如何使用？ 12345678910111213// 创建一个实例，cacheDir 是cache的文件目录DiskLruCache cache = DiskLruCache.open(cacheDir, appVersion, 2, Integer.MAX_VALUE);// 存或者更改数据DiskLruCache.Editor creator = cache.edit(&quot;k1&quot;);creator.set(0, &quot;A&quot;);creator.set(1, &quot;B&quot;);// 要调用这个creator.commit();cache.close();// 读取数据DiskLruCache.Snapshot snapshot = cache.get(&quot;k1&quot;);String data = snapshot.getString(0);snapshot.close(); 源码分析 属性 在DiskLruCache 中有三种文件，一个是日志文件，里面是我们操作的记录，还有临时文件，存在的是我们的Value数据，在未提交前，一个是备份文件，可从这个里面恢复数据。lruEntries 是key的集合，使用了 LinkedHashMap，于LruCache一样，redundantOpCount 是里面冗余操作的次数，当这个值大于2000，会trimToSize，重新构建日志文件 123456789101112private final File directory;private final File journalFile;private final File journalFileTmp;private final File journalFileBackup;private final int appVersion;private long maxSize;private final int valueCount;private long size = 0;private Writer journalWriter;private final LinkedHashMap&lt;String, Entry&gt; lruEntries = new LinkedHashMap&lt;String, Entry&gt;(0, 0.75f, true);private int redundantOpCount; 日志文件的格式，前几行是文件头，后面是操作记录 123456789101112131415* This cache uses a journal file named &quot;journal&quot;. A typical journal file* looks like this:* libcore.io.DiskLruCache* 1* 100* 2** CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054* DIRTY 335c4c6028171cfddfbaae1a9c313c52* CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342* REMOVE 335c4c6028171cfddfbaae1a9c313c52* DIRTY 1ab96a171faeeee38496d8b330771a7a* CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234* READ 335c4c6028171cfddfbaae1a9c313c52* READ 3400330d1dfc7f3f7f4b8d4d803dfcf6 看一下如何建立一个实例，首先查看是否有备份文件，如果有的话，在检查是否有日志文件，首次创建时没有任何文件，因此会执行到 directory.mkdirs() 然后rebuildJournal， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Opens the cache in &#123;@code directory&#125;, creating a cache if none exists * there. * * @param directory a writable directory * @param valueCount the number of values per cache entry. Must be positive. * @param maxSize the maximum number of bytes this cache should use to store * @throws IOException if reading or writing the cache directory fails */public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize) throws IOException &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;); &#125; if (valueCount &lt;= 0) &#123; throw new IllegalArgumentException(&quot;valueCount &lt;= 0&quot;); &#125; // If a bkp file exists, use it instead. File backupFile = new File(directory, JOURNAL_FILE_BACKUP); if (backupFile.exists()) &#123; File journalFile = new File(directory, JOURNAL_FILE); // If journal file also exists just delete backup file. if (journalFile.exists()) &#123; backupFile.delete(); &#125; else &#123; renameTo(backupFile, journalFile, false); &#125; &#125; // Prefer to pick up where we left off. DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize); if (cache.journalFile.exists()) &#123; try &#123; cache.readJournal(); cache.processJournal(); return cache; &#125; catch (IOException journalIsCorrupt) &#123; System.out .println(&quot;DiskLruCache &quot; + directory + &quot; is corrupt: &quot; + journalIsCorrupt.getMessage() + &quot;, removing&quot;); cache.delete(); &#125; &#125; // Create a new empty cache. directory.mkdirs(); cache = new DiskLruCache(directory, appVersion, valueCount, maxSize); cache.rebuildJournal(); return cache;&#125; 线程安全的，首先使用将文件头写入，再将entry写入，最后判断 journal 文件是否存在，如果存在，那么现将其改为备份文件，之后把临时文件改成日志文件，删除备份文件，总之就是要留下一个日志文件，最后创建一个 JournalWriter，追加模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Creates a new journal that omits redundant information. This replaces the * current journal if it exists. */private synchronized void rebuildJournal() throws IOException &#123; if (journalWriter != null) &#123; journalWriter.close(); &#125; Writer writer = new BufferedWriter( new OutputStreamWriter(new FileOutputStream(journalFileTmp), Util.US_ASCII)); try &#123; writer.write(MAGIC); writer.write(&quot;\\n&quot;); writer.write(VERSION_1); writer.write(&quot;\\n&quot;); writer.write(Integer.toString(appVersion)); writer.write(&quot;\\n&quot;); writer.write(Integer.toString(valueCount)); writer.write(&quot;\\n&quot;); writer.write(&quot;\\n&quot;); // 每一个 entry 会有一个Editor for (Entry entry : lruEntries.values()) &#123; if (entry.currentEditor != null) &#123; writer.write(DIRTY + &apos; &apos; + entry.key + &apos;\\n&apos;); &#125; else &#123; writer.write(CLEAN + &apos; &apos; + entry.key + entry.getLengths() + &apos;\\n&apos;); &#125; &#125; &#125; finally &#123; writer.close(); &#125; if (journalFile.exists()) &#123; renameTo(journalFile, journalFileBackup, true); &#125; renameTo(journalFileTmp, journalFile, false); journalFileBackup.delete(); journalWriter = new BufferedWriter( new OutputStreamWriter(new FileOutputStream(journalFile, true), Util.US_ASCII));&#125;// 通过改名来复制文件内容private static void renameTo(File from, File to, boolean deleteDestination) throws IOException &#123; if (deleteDestination) &#123; deleteIfExists(to); &#125; if (!from.renameTo(to)) &#123; throw new IOException(); &#125;&#125; 看一下 Entry，主要是Key和valueCount，还有一个 currentEditor 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private final class Entry &#123; private final String key; /** Lengths of this entry&apos;s files. */ private final long[] lengths; /** True if this entry has ever been published. */ private boolean readable; /** The ongoing edit or null if this entry is not being edited. */ private Editor currentEditor; /** The sequence number of the most recently committed edit to this entry. */ private long sequenceNumber; private Entry(String key) &#123; this.key = key; this.lengths = new long[valueCount]; &#125; public String getLengths() throws IOException &#123; StringBuilder result = new StringBuilder(); for (long size : lengths) &#123; result.append(&apos; &apos;).append(size); &#125; return result.toString(); &#125; /** Set lengths using decimal numbers like &quot;10123&quot;. */ private void setLengths(String[] strings) throws IOException &#123; if (strings.length != valueCount) &#123; throw invalidLengths(strings); &#125; try &#123; for (int i = 0; i &lt; strings.length; i++) &#123; lengths[i] = Long.parseLong(strings[i]); &#125; &#125; catch (NumberFormatException e) &#123; throw invalidLengths(strings); &#125; &#125; private IOException invalidLengths(String[] strings) throws IOException &#123; throw new IOException(&quot;unexpected journal line: &quot; + java.util.Arrays.toString(strings)); &#125; public File getCleanFile(int i) &#123; return new File(directory, key + &quot;.&quot; + i); &#125; public File getDirtyFile(int i) &#123; return new File(directory, key + &quot;.&quot; + i + &quot;.tmp&quot;); &#125; &#125; 看一下初始化，首先看一下，通常会新建一个entry，或者读取，然后绑定一个Editor，写日志 123456789101112131415161718192021222324252627public Editor edit(String key) throws IOException &#123; return edit(key, ANY_SEQUENCE_NUMBER);&#125;private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException &#123; checkNotClosed(); validateKey(key); Entry entry = lruEntries.get(key); if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == null || entry.sequenceNumber != expectedSequenceNumber)) &#123; return null; // Snapshot is stale. &#125; if (entry == null) &#123; entry = new Entry(key); lruEntries.put(key, entry); &#125; else if (entry.currentEditor != null) &#123; return null; // Another edit is in progress. &#125; Editor editor = new Editor(entry); entry.currentEditor = editor; // Flush the journal before creating files to prevent file leaks. journalWriter.write(DIRTY + &apos; &apos; + key + &apos;\\n&apos;); journalWriter.flush(); return editor;&#125; Editor 的实现，一个Entry对应一个Editor，通常我们会通过Editor set get数据， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** Edits the values for an entry. */public final class Editor &#123; private final Entry entry; private final boolean[] written; private boolean hasErrors; private boolean committed; private Editor(Entry entry) &#123; this.entry = entry; this.written = (entry.readable) ? null : new boolean[valueCount]; &#125; /** * Returns an unbuffered input stream to read the last committed value, * or null if no value has been committed. */ public InputStream newInputStream(int index) throws IOException &#123; synchronized (DiskLruCache.this) &#123; if (entry.currentEditor != this) &#123; throw new IllegalStateException(); &#125; if (!entry.readable) &#123; return null; &#125; try &#123; return new FileInputStream(entry.getCleanFile(index)); &#125; catch (FileNotFoundException e) &#123; return null; &#125; &#125; &#125; /** * Returns the last committed value as a string, or null if no value * has been committed. */ public String getString(int index) throws IOException &#123; InputStream in = newInputStream(index); return in != null ? inputStreamToString(in) : null; &#125; /** Sets the value at &#123;@code index&#125; to &#123;@code value&#125;. */ public void set(int index, String value) throws IOException &#123; Writer writer = null; try &#123; writer = new OutputStreamWriter(newOutputStream(index), Util.UTF_8); writer.write(value); &#125; finally &#123; Util.closeQuietly(writer); &#125; &#125; /** * Commits this edit so it is visible to readers. This releases the * edit lock so another edit may be started on the same key. */ public void commit() throws IOException &#123; if (hasErrors) &#123; completeEdit(this, false); remove(entry.key); // The previous entry is stale. &#125; else &#123; completeEdit(this, true); &#125; committed = true; &#125; /** * Aborts this edit. This releases the edit lock so another edit may be * started on the same key. */ public void abort() throws IOException &#123; completeEdit(this, false); &#125; public void abortUnlessCommitted() &#123; if (!committed) &#123; try &#123; abort(); &#125; catch (IOException ignored) &#123; &#125; &#125; &#125; private class FaultHidingOutputStream extends FilterOutputStream &#123; private FaultHidingOutputStream(OutputStream out) &#123; super(out); &#125; @Override public void write(int oneByte) &#123; try &#123; out.write(oneByte); &#125; catch (IOException e) &#123; hasErrors = true; &#125; &#125; @Override public void write(byte[] buffer, int offset, int length) &#123; try &#123; out.write(buffer, offset, length); &#125; catch (IOException e) &#123; hasErrors = true; &#125; &#125; @Override public void close() &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; hasErrors = true; &#125; &#125; @Override public void flush() &#123; try &#123; out.flush(); &#125; catch (IOException e) &#123; hasErrors = true; &#125; &#125; &#125;&#125; 获取一个OuputStream，注意，每个index是一个文件，而且不能超过valueCount，用了全局锁，写的时候使用了 dirtyFile，这是一个临时文件，等commit了会把这个文件变为正式文件 12345678910111213141516171819202122232425262728293031323334353637/** * Returns a new unbuffered output stream to write the value at * &#123;@code index&#125;. If the underlying output stream encounters errors * when writing to the filesystem, this edit will be aborted when * &#123;@link #commit&#125; is called. The returned output stream does not throw * IOExceptions. */ public OutputStream newOutputStream(int index) throws IOException &#123; if (index &lt; 0 || index &gt;= valueCount) &#123; throw new IllegalArgumentException(&quot;Expected index &quot; + index + &quot; to &quot; + &quot;be greater than 0 and less than the maximum value count &quot; + &quot;of &quot; + valueCount); &#125; synchronized (DiskLruCache.this) &#123; if (entry.currentEditor != this) &#123; throw new IllegalStateException(); &#125; if (!entry.readable) &#123; written[index] = true; &#125; File dirtyFile = entry.getDirtyFile(index); FileOutputStream outputStream; try &#123; outputStream = new FileOutputStream(dirtyFile); &#125; catch (FileNotFoundException e) &#123; // Attempt to recreate the cache directory. directory.mkdirs(); try &#123; outputStream = new FileOutputStream(dirtyFile); &#125; catch (FileNotFoundException e2) &#123; // We are unable to recover. Silently eat the writes. return NULL_OUTPUT_STREAM; &#125; &#125; return new FaultHidingOutputStream(outputStream); &#125; &#125; 提交的时候，会锁住整个实例， 123456789101112131415161718192021222324252627282930313233343536373839private synchronized void completeEdit(Editor editor, boolean success) throws IOException &#123; Entry entry = editor.entry; // 省略 .... // 把dirty文件变为正式文件 for (int i = 0; i &lt; valueCount; i++) &#123; File dirty = entry.getDirtyFile(i); if (success) &#123; if (dirty.exists()) &#123; File clean = entry.getCleanFile(i); dirty.renameTo(clean); long oldLength = entry.lengths[i]; long newLength = clean.length(); entry.lengths[i] = newLength; size = size - oldLength + newLength; &#125; &#125; else &#123; deleteIfExists(dirty); &#125; &#125; // 增加一次操作 redundantOpCount++; entry.currentEditor = null; if (entry.readable | success) &#123; entry.readable = true; journalWriter.write(CLEAN + &apos; &apos; + entry.key + entry.getLengths() + &apos;\\n&apos;); if (success) &#123; entry.sequenceNumber = nextSequenceNumber++; &#125; &#125; else &#123; lruEntries.remove(entry.key); journalWriter.write(REMOVE + &apos; &apos; + entry.key + &apos;\\n&apos;); &#125; journalWriter.flush(); // 是否需要清除数据 if (size &gt; maxSize || journalRebuildRequired()) &#123; executorService.submit(cleanupCallable); &#125;&#125; 执行清除数据的过程 1234567891011121314151617181920212223242526/** This cache uses a single background thread to evict entries. */final ThreadPoolExecutor executorService = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());private final Callable&lt;Void&gt; cleanupCallable = new Callable&lt;Void&gt;() &#123; public Void call() throws Exception &#123; synchronized (DiskLruCache.this) &#123; if (journalWriter == null) &#123; return null; // Closed. &#125; trimToSize(); if (journalRebuildRequired()) &#123; rebuildJournal(); redundantOpCount = 0; &#125; &#125; return null; &#125;&#125;;// 访问过得节点会被移动到末尾，链首的数据都是老数据，// 新数据都是添加到链尾，每次被访问的数据也会被放入链尾private void trimToSize() throws IOException &#123; while (size &gt; maxSize) &#123; Map.Entry&lt;String, Entry&gt; toEvict = lruEntries.entrySet().iterator().next(); remove(toEvict.getKey()); &#125;&#125; 我们再回过头看一下，如果缓存文件存在，那么则读取日志文件，首先检查文件头，再读取操作记录，redundantOpCount = lineCount - lruEntries.size() 这里记录了冗余操作的次数，当这个数大于2000 时，则重新构建日志文件，重新构建会删除之前的操作记录，这样有利于日志文件大小的控制 123456789101112131415161718192021222324252627282930313233343536373839private void readJournal() throws IOException &#123; StrictLineReader reader = new StrictLineReader(new FileInputStream(journalFile), Util.US_ASCII); try &#123; String magic = reader.readLine(); String version = reader.readLine(); String appVersionString = reader.readLine(); String valueCountString = reader.readLine(); String blank = reader.readLine(); if (!MAGIC.equals(magic) || !VERSION_1.equals(version) || !Integer.toString(appVersion).equals(appVersionString) || !Integer.toString(valueCount).equals(valueCountString) || !&quot;&quot;.equals(blank)) &#123; throw new IOException(&quot;unexpected journal header: [&quot; + magic + &quot;, &quot; + version + &quot;, &quot; + valueCountString + &quot;, &quot; + blank + &quot;]&quot;); &#125; int lineCount = 0; while (true) &#123; try &#123; readJournalLine(reader.readLine()); lineCount++; &#125; catch (EOFException endOfJournal) &#123; break; &#125; &#125; redundantOpCount = lineCount - lruEntries.size(); // If we ended on a truncated line, rebuild the journal before appending to it. if (reader.hasUnterminatedLine()) &#123; rebuildJournal(); &#125; else &#123; journalWriter = new BufferedWriter(new OutputStreamWriter( new FileOutputStream(journalFile, true), Util.US_ASCII)); &#125; &#125; finally &#123; Util.closeQuietly(reader); &#125;&#125; 小结 核心思想：LruCache，利用LinkedHashMap存储Key，将Value存于文件，一个Key，一个value对应一个文件各不影响。","categories":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/tags/Android/"}]},{"title":"Android OkHttp3 源码解析","slug":"Android/OkHttp3","date":"2018-08-23T11:30:00.000Z","updated":"2019-09-02T12:19:12.575Z","comments":true,"path":"2018/08/23/Android/OkHttp3/","link":"","permalink":"https://wzes.github.io/2018/08/23/Android/OkHttp3/","excerpt":"","text":"前言 总觉得网络这一块不是那么的熟悉，也找不到窍门，索性看一个网络请求框架，来加深自己对网络请求的认识。这个系列应该会很长，毕竟这个库也不简单，里面包含了很多知识，我会先从使用，再到简单 API源码 的分析，再到框架内部各个模块的仔细研读这样一个顺序去分析。 OkHttp3 这个库可以说是很优秀，使用起来也很简单，关键是，你可以对它进行各种定制，来做到各种各样的功能，在Android 中，Retrofit 底层就是用 OkHttpClient 去实现的。OkHttp 虽然没有浏览器那么强大，但他内部实现了很多请求服务器数据的场景，能处理很多不同的结果，比如常见的 100 101 Continue 301 302 重定向等等，遇到301，则会触发重定向，从Response 里边取出 Location ，然后再封装 Request，重新访问。这些它在内部帮我们直接去实现，里面还有请求的缓存，应该是根据服务端的Cache-Control 来做的，还有 HTTP 的连接复用，它支持 HTTP1.1 HTTP2 也支持 HTTPS，底层分别使用 Socket 和 sslSocket 写的。另外，它提供了同步，异步的请求方式，可以很方便使用者进行调用。说了很多特性，但我目前仅仅是一个抽象，很难说清楚里面的实现，所以就想好好去看一下里面的实现原理，提升一下内功 使用篇 官方的 GET Sample 123456789101112131415161718192021222324252627import java.io.IOException;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;public class GetExample &#123; // 首先构建一个 OkHttpClient ，当然你也可以使用 Builder 去构建 OkHttpClient client = new OkHttpClient(); String run(String url) throws IOException &#123; // 构建一个 Request 默认是 GET 请求 Request request = new Request.Builder() .url(url) .build(); // 同步的方式去执行 // 返回一个 Response 对象 try (Response response = client.newCall(request).execute()) &#123; return response.body().string(); &#125; &#125; public static void main(String[] args) throws IOException &#123; GetExample example = new GetExample(); String response = example.run(&quot;https://raw.github.com/square/okhttp/master/README.md&quot;); System.out.println(response); &#125;&#125; POST Sample 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.io.IOException;import okhttp3.MediaType;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.RequestBody;import okhttp3.Response;public class PostExample &#123; public static final MediaType JSON = MediaType.get(&quot;application/json; charset=utf-8&quot;); OkHttpClient client = new OkHttpClient(); // 在构建一个 Request 的时候，提交一个 body // 通过 RequestBody.create() 来创建一个 Json 格式的 body String post(String url, String json) throws IOException &#123; RequestBody body = RequestBody.create(JSON, json); Request request = new Request.Builder() .url(url) .post(body) .build(); // 一个小小的API，会在请求结束后调用 client.dispatcher().setIdleCallback(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;Request is Over&quot;); &#125; &#125;); try (Response response = client.newCall(request).execute()) &#123; return response.body().string(); &#125; &#125; String bowlingJson(String player1, String player2) &#123; return &quot;&#123;&apos;winCondition&apos;:&apos;HIGH_SCORE&apos;,&quot; + &quot;&apos;name&apos;:&apos;Bowling&apos;,&quot; + &quot;&apos;round&apos;:4,&quot; + &quot;&apos;lastSaved&apos;:1367702411696,&quot; + &quot;&apos;dateStarted&apos;:1367702378785,&quot; + &quot;&apos;players&apos;:[&quot; + &quot;&#123;&apos;name&apos;:&apos;&quot; + player1 + &quot;&apos;,&apos;history&apos;:[10,8,6,7,8],&apos;color&apos;:-13388315,&apos;total&apos;:39&#125;,&quot; + &quot;&#123;&apos;name&apos;:&apos;&quot; + player2 + &quot;&apos;,&apos;history&apos;:[6,10,5,10,10],&apos;color&apos;:-48060,&apos;total&apos;:41&#125;&quot; + &quot;]&#125;&quot;; &#125; public static void main(String[] args) throws IOException &#123; PostExample example = new PostExample(); String json = example.bowlingJson(&quot;Jesse&quot;, &quot;Jake&quot;); String response = example.post(&quot;http://www.roundsapp.com/post&quot;, json); System.out.println(response); &#125;&#125; 可以看到，GET，POST 还是挺简单的，为了满足好奇心，我们看一个方法的源码，OkHttpClient 的 newCall 方法，类似工厂的方法，构建一个 RealCall 的，然后调用 RealCall 的 execute 方法执行 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Override public Call newCall(Request request) &#123; return RealCall.newRealCall(this, request, false /* for web socket */);&#125;@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); try &#123; // 只是放入同步队列 client.dispatcher().executed(this); // 真正的网络调用在这个地方 Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(&quot;Canceled&quot;); return result; &#125; catch (IOException e) &#123; eventListener.callFailed(this, e); throw e; &#125; finally &#123; // 结束那个任务 client.dispatcher().finished(this); &#125;&#125;// 从队列里面移除一个 callprivate &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123; int runningCallsCount; Runnable idleCallback; synchronized (this) &#123; // 移除 if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&apos;t in-flight!&quot;); // 触发任务 if (promoteCalls) promoteCalls(); runningCallsCount = runningCallsCount(); idleCallback = this.idleCallback; &#125; // dispatcher 的api，通过 client 获取然后设置 if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125;&#125; 下集预告，OkHttp 的核心，请求链都是在这个这个方法里，调用是从上往下，又从下传到最上，如果到了 CallServerInterceptor，它把数据发到服务端，然后获取结果，再返回给上层处理 RetryAndFollowUpInterceptor BridgeInterceptor CacheInterceptor ConnectInterceptor CallServerInterceptor 12345678910111213141516171819Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest);&#125; 小结 我们大致知道了流程，就是先创建一个 OkHttpClient，然后再创建一个 Request，然后再调用 newCall 执行，暂时我们看了同步的方式 前言 之前我们掌握了 OkHttpClient 的基本使用，在最后面我们抛出了很多 Interceptor，现在我们看一下 Interceptor 到底是什么东西，英文是拦截器的意思，当我看了源码后，我觉得我更容易理解的是，处理器 定义 如果定义自己的 interceptor，要实现 intercept，里面有一个内部类 Chain ，链 1234567891011121314151617181920212223242526272829public interface Interceptor &#123; Response intercept(Chain chain) throws IOException; interface Chain &#123; Request request(); Response proceed(Request request) throws IOException; /** * Returns the connection the request will be executed on. This is only available in the chains * of network interceptors; for application interceptors this is always null. */ @Nullable Connection connection(); Call call(); int connectTimeoutMillis(); Chain withConnectTimeout(int timeout, TimeUnit unit); int readTimeoutMillis(); Chain withReadTimeout(int timeout, TimeUnit unit); int writeTimeoutMillis(); Chain withWriteTimeout(int timeout, TimeUnit unit); &#125;&#125; 再看一下这个函数，如果我们没有自定义的 interceptor，最先的是RetryAndFollowUpInterceptor，他是一个 重试和重定向的拦截器 12345678910111213141516171819Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest);&#125; 我们看一下 RealInterceptorChain， 他实现了 Interceptor.Chain 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132public final class RealInterceptorChain implements Interceptor.Chain &#123; private final List&lt;Interceptor&gt; interceptors; private final StreamAllocation streamAllocation; private final HttpCodec httpCodec; private final RealConnection connection; private final int index; private final Request request; private final Call call; private final EventListener eventListener; private final int connectTimeout; private final int readTimeout; private final int writeTimeout; private int calls; public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call, EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) &#123; this.interceptors = interceptors; this.connection = connection; this.streamAllocation = streamAllocation; this.httpCodec = httpCodec; this.index = index; this.request = request; this.call = call; this.eventListener = eventListener; this.connectTimeout = connectTimeout; this.readTimeout = readTimeout; this.writeTimeout = writeTimeout; &#125; @Override public Connection connection() &#123; return connection; &#125; @Override public int connectTimeoutMillis() &#123; return connectTimeout; &#125; @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) &#123; int millis = checkDuration(&quot;timeout&quot;, timeout, unit); return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index, request, call, eventListener, millis, readTimeout, writeTimeout); &#125; @Override public int readTimeoutMillis() &#123; return readTimeout; &#125; @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) &#123; int millis = checkDuration(&quot;timeout&quot;, timeout, unit); return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index, request, call, eventListener, connectTimeout, millis, writeTimeout); &#125; @Override public int writeTimeoutMillis() &#123; return writeTimeout; &#125; @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) &#123; int millis = checkDuration(&quot;timeout&quot;, timeout, unit); return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index, request, call, eventListener, connectTimeout, readTimeout, millis); &#125; public StreamAllocation streamAllocation() &#123; return streamAllocation; &#125; public HttpCodec httpStream() &#123; return httpCodec; &#125; @Override public Call call() &#123; return call; &#125; public EventListener eventListener() &#123; return eventListener; &#125; @Override public Request request() &#123; return request; &#125; @Override public Response proceed(Request request) throws IOException &#123; return proceed(request, streamAllocation, httpCodec, connection); &#125; public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; // If we already have a stream, confirm that the incoming request will use it. if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123; throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1) + &quot; must retain the same host and port&quot;); &#125; // If we already have a stream, confirm that this is the only call to chain.proceed(). if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123; throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1) + &quot; must call proceed() exactly once&quot;); &#125; // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); // Confirm that the next interceptor made its required call to chain.proceed(). if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123; throw new IllegalStateException(&quot;network interceptor &quot; + interceptor + &quot; must call proceed() exactly once&quot;); &#125; // Confirm that the intercepted response isn&apos;t null. if (response == null) &#123; throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;); &#125; if (response.body() == null) &#123; throw new IllegalStateException( &quot;interceptor &quot; + interceptor + &quot; returned a response with no body&quot;); &#125; return response; &#125;&#125; 我把最关键的代码贴出来，Interceptors 获取实例Interceptor，比如第一个的话，是RetryAndFollowUpInterceptor，然后执行 intercept方法，将下一个RealInterceptorChain 传进去，所以其实这里是一个递归，会不断调用，知道最后一层返回 Response 1234567// Call the next interceptor in the chain.RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout);Interceptor interceptor = interceptors.get(index);// Response response = interceptor.intercept(next); RetryAndFollowUpInterceptor 实现机制，里面有个重要的东西，重定向次数，最大为20，还有 OkHttpClient 的实例，还有一个volatile 的 canceled ，标记是否取消，还有 forWebSocket，这个等到用到了再解释，StreamAllocation也是 1public final class RetryAndFollowUpInterceptor implements Interceptor &#123;&#125; 1234567891011/** * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox, * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5. */private static final int MAX_FOLLOW_UPS = 20;private final OkHttpClient client;private final boolean forWebSocket;private volatile StreamAllocation streamAllocation;private Object callStackTrace;private volatile boolean canceled; 我们看一下他的 intercept 方法，第一个 interceptor 是RetryAndFollowUpInterceptor，Chain 包含了当前是第几个拦截器的信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100@Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; Call call = realChain.call(); EventListener eventListener = realChain.eventListener(); // 构建一个 StreamAllocation对象 // client连接池，Address 地址，call对象，监听对象 StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; // 初始化跟踪次数 int followUpCount = 0; Response priorResponse = null; // 循环，为了处理重定向，失败重试的问题 while (true) &#123; // 每一次首先判断是否取消 if (canceled) &#123; streamAllocation.release(); throw new IOException(&quot;Canceled&quot;); &#125; // Response response; boolean releaseConnection = true; try &#123; // 调用 Chain 对象的 proceed，这里最后也 // 会进到下一个 Interceptor 的 intercept response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false; &#125; catch (RouteException e) &#123; // The attempt to connect via a route failed. The request will not have been sent. if (!recover(e.getLastConnectException(), streamAllocation, false, request)) &#123; throw e.getFirstConnectException(); &#125; releaseConnection = false; continue; &#125; catch (IOException e) &#123; // An attempt to communicate with a server failed. The request may have been sent. boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, streamAllocation, requestSendStarted, request)) throw e; releaseConnection = false; continue; &#125; finally &#123; // We&apos;re throwing an unchecked exception. Release any resources. if (releaseConnection) &#123; streamAllocation.streamFailed(null); streamAllocation.release(); &#125; &#125; // Attach the prior response if it exists. Such responses never have a body. if (priorResponse != null) &#123; response = response.newBuilder() .priorResponse(priorResponse.newBuilder() .body(null) .build()) .build(); &#125; // 检查是否出现需要重试，比如重定向，服务器问题 Request followUp; try &#123; followUp = followUpRequest(response, streamAllocation.route()); &#125; catch (IOException e) &#123; streamAllocation.release(); throw e; &#125; // 无重试，直接返回结果 if (followUp == null) &#123; if (!forWebSocket) &#123; streamAllocation.release(); &#125; return response; &#125; closeQuietly(response.body()); // 检查重试次数，超出的话抛出异常 if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123; streamAllocation.release(); throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount); &#125; if (followUp.body() instanceof UnrepeatableRequestBody) &#123; streamAllocation.release(); throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code()); &#125; // 不是同一个连接 if (!sameConnection(response, followUp.url())) &#123; streamAllocation.release(); streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(followUp.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; &#125; else if (streamAllocation.codec() != null) &#123; throw new IllegalStateException(&quot;Closing the body of &quot; + response + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;); &#125; request = followUp; priorResponse = response; &#125; &#125; 判断是否需要跟踪的代码，可以好好补一补状态码了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121private Request followUpRequest(Response userResponse, Route route) throws IOException &#123; if (userResponse == null) throw new IllegalStateException(); int responseCode = userResponse.code(); final String method = userResponse.request().method(); switch (responseCode) &#123; // 407 代理服务器需要认证 case HTTP_PROXY_AUTH: Proxy selectedProxy = route != null ? route.proxy() : client.proxy(); if (selectedProxy.type() != Proxy.Type.HTTP) &#123; throw new ProtocolException(&quot;Received HTTP_PROXY_AUTH (407) code while not using proxy&quot;); &#125; return client.proxyAuthenticator().authenticate(route, userResponse); // 401 未授权，根据Header Authenticate 进行授权 case HTTP_UNAUTHORIZED: return client.authenticator().authenticate(route, userResponse); // 如果是非GET，HEAD，则不管，注意 307,308 和 301 302 的区别 // 308 case HTTP_PERM_REDIRECT: // 307 case HTTP_TEMP_REDIRECT: // &quot;If the 307 or 308 status code is received in response to a request other than GET // or HEAD, the user agent MUST NOT automatically redirect the request&quot; if (!method.equals(&quot;GET&quot;) &amp;&amp; !method.equals(&quot;HEAD&quot;)) &#123; return null; &#125; // fall-through // 根据Location 重定向，构建一条新的 Request // 300 case HTTP_MULT_CHOICE: // 301 case HTTP_MOVED_PERM: // 302 case HTTP_MOVED_TEMP: // 303 case HTTP_SEE_OTHER: // Does the client allow redirects? if (!client.followRedirects()) return null; String location = userResponse.header(&quot;Location&quot;); if (location == null) return null; HttpUrl url = userResponse.request().url().resolve(location); // Don&apos;t follow redirects to unsupported protocols. if (url == null) return null; // If configured, don&apos;t follow redirects between SSL and non-SSL. boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme()); if (!sameScheme &amp;&amp; !client.followSslRedirects()) return null; // Most redirects don&apos;t include a request body. Request.Builder requestBuilder = userResponse.request().newBuilder(); if (HttpMethod.permitsRequestBody(method)) &#123; final boolean maintainBody = HttpMethod.redirectsWithBody(method); if (HttpMethod.redirectsToGet(method)) &#123; requestBuilder.method(&quot;GET&quot;, null); &#125; else &#123; RequestBody requestBody = maintainBody ? userResponse.request().body() : null; requestBuilder.method(method, requestBody); &#125; if (!maintainBody) &#123; requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;); requestBuilder.removeHeader(&quot;Content-Length&quot;); requestBuilder.removeHeader(&quot;Content-Type&quot;); &#125; &#125; // When redirecting across hosts, drop all authentication headers. This // is potentially annoying to the application layer since they have no // way to retain them. if (!sameConnection(userResponse, url)) &#123; requestBuilder.removeHeader(&quot;Authorization&quot;); &#125; return requestBuilder.url(url).build(); // 408 客户端连接超时 case HTTP_CLIENT_TIMEOUT: // 408&apos;s are rare in practice, but some servers like HAProxy use this response code. The // spec says that we may repeat the request without modifications. Modern browsers also // repeat the request (even non-idempotent ones.) if (!client.retryOnConnectionFailure()) &#123; // The application layer has directed us not to retry the request. return null; &#125; if (userResponse.request().body() instanceof UnrepeatableRequestBody) &#123; return null; &#125; if (userResponse.priorResponse() != null &amp;&amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) &#123; // We attempted to retry and got another timeout. Give up. return null; &#125; // 尝试重试 if (retryAfter(userResponse, 0) &gt; 0) &#123; return null; &#125; return userResponse.request(); // 503 case HTTP_UNAVAILABLE: if (userResponse.priorResponse() != null &amp;&amp; userResponse.priorResponse().code() == HTTP_UNAVAILABLE) &#123; // We attempted to retry and got another timeout. Give up. return null; &#125; if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) &#123; // specifically received an instruction to retry without delay return userResponse.request(); &#125; return null; default: return null; &#125;&#125; 解析重试的时间，在客户端请求超时，服务器负载过高造成的都有可能进行重试，这时候会根据服务器给的 retry-after 属性进行重试，默认的重试时间为0，立刻重试 123456789101112131415private int retryAfter(Response userResponse, int defaultDelay) &#123; String header = userResponse.header(&quot;Retry-After&quot;); if (header == null) &#123; return defaultDelay; &#125; // https://tools.ietf.org/html/rfc7231#section-7.1.3 // currently ignores a HTTP-date, and assumes any non int 0 is a delay if (header.matches(&quot;\\\\d+&quot;)) &#123; return Integer.valueOf(header); &#125; return Integer.MAX_VALUE;&#125; 判断是否是同一个连接的方法，比较host 和 port，以及scheme（http 或 https），至于为什么要这样写，我们在之后会看到原理。 12345678910/** * Returns true if an HTTP request for &#123;@code followUp&#125; can reuse the connection used by this * engine. */private boolean sameConnection(Response response, HttpUrl followUp) &#123; HttpUrl url = response.request().url(); return url.host().equals(followUp.host()) &amp;&amp; url.port() == followUp.port() &amp;&amp; url.scheme().equals(followUp.scheme());&#125; 代理类型，三种 1234567891011121314public enum Type &#123; /** * Represents a direct connection, or the absence of a proxy. */ DIRECT, /** * Represents proxy for high level protocols such as HTTP or FTP. */ HTTP, /** * Represents a SOCKS (V4 or V5) proxy. */ SOCKS&#125;; 小结 我们详细的看了这个 RetryAndFollowUpInterceptor，可能你现在还不是很清晰，但相信之后看了其他的一些Interceptor，你就会十分了解这个东西 前言 之前我们学习了 OkHttp3 的使用以及 RetryAndFollowUpInterceptor 的源码，至今还记忆尤新，今天我给大家带来一个 BridgeInterceptor，这个东西也很重要，那它到底是个什么东西呢？ 是什么东西 Bridge，桥接，是不是说起着承上启下的作用，的确如此，原文是这么说的 Bridges from application code to network code. First it builds a network request from a user request. Then it proceeds to call the network. Finally it builds a user response from the network response 翻译过来，就是说将请求或者响应在应用层和网络层相互转化 源码 里面的 Intercept 方法，首先，获取到用过刚开始构建的 request 对象，因为用户仅仅配置了几个简单的属性，比如 url，method等，但这远远不够，我们传给服务器的数据不仅仅如此，如果看过 http 协议，我们应该比较了解明文模式下的数据格式 12345678910111213141516171819202122@Override public Response intercept(Chain chain) throws IOException &#123; Request userRequest = chain.request(); Request.Builder requestBuilder = userRequest.newBuilder(); RequestBody body = userRequest.body(); if (body != null) &#123; MediaType contentType = body.contentType(); if (contentType != null) &#123; requestBuilder.header(&quot;Content-Type&quot;, contentType.toString()); &#125; // 如果body 的长度为 -1 那么将使用 // Transfer-Encoding 设置为 chunked // 意思是分块传输 long contentLength = body.contentLength(); if (contentLength != -1) &#123; requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength)); requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;); &#125; else &#123; requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;); requestBuilder.removeHeader(&quot;Content-Length&quot;); &#125; &#125; 给 request 添加 Host，以及Connection 为 Keep-Alive，以及使用 Accept-Encoding 为 gzip 1234567891011121314if (userRequest.header(&quot;Host&quot;) == null) &#123; requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false)); &#125; if (userRequest.header(&quot;Connection&quot;) == null) &#123; requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;); &#125; // If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also decompressing // the transfer stream. boolean transparentGzip = false; if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123; transparentGzip = true; requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;); &#125; 封装Cookie，以及User-Agent 为 okhttp 关于 Cookie 的格式如下，其中 Name = Value 必须要有 1Set-Cookie: Name = Value; Comment = value; Domain = value; Max-Age = value; Path = Value;Secure; Version = 1 * DIGIT; 1234567891011121314151617List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url()); if (!cookies.isEmpty()) &#123; requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies)); &#125; if (userRequest.header(&quot;User-Agent&quot;) == null) &#123; requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent()); &#125; public final class Version &#123; public static String userAgent() &#123; return &quot;okhttp/3.11.0&quot;; &#125; private Version() &#123; &#125; &#125; 之后就是转发给下一个 Interceptor 了，在拿到数据以后，处理一下 cookie 的数据，具体就是更新Cookie，之后就是处理数据了，如果服务端使用了gzip，我们就需要解压，在构建 response，之后再返回 12345678910111213141516171819Response networkResponse = chain.proceed(requestBuilder.build());HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest);if (transparentGzip &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;)) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123; GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll(&quot;Content-Encoding&quot;) .removeAll(&quot;Content-Length&quot;) .build(); responseBuilder.headers(strippedHeaders); String contentType = networkResponse.header(&quot;Content-Type&quot;); responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));&#125; 差不多到这就完了 小结 今天的bridgeInterceptor主要做的工作便是封装 request 和 处理 response 这个东西，中间我们学习了 content-encoding accept-encoding 等属性，另外详细的了解了cookie，终于搞明白了这东西的格式，收获不小 欢迎讨论 前言 桥接 Interceptor 之后就是缓存 Interceptor 了，缓存在浏览器中运用十分广泛，如果在加载网页时使用了缓存，主要是二次加载，那么一些不变的内容就可以不用去重新请求，这样数据就不用来回传送，性能便有所提高，通常我们遇到的 304 响应码便是缓存的象征，关于缓存还需要掌握很多请求头的知识，比如ETag，If-None-Match，If-Modified-Since，Last-Modified-Time 等等，这些属性是客户端，服务端缓存消息交互的关键。因此我们要学习缓存的话，这些知识必不可少。 是什么东西？ 用于处理客户端的缓存，缓存的内容实在客户端的，但通常与服务器是脱不了关系的，这里我们需要明白的是，关于网络缓存有很多很多中，可以在很多地方做缓存，而这里是在客户端做缓存。 源码学习 缓存的内核，所有的数据存取都与这家伙有关，内部是使用 Cache，如果我们需要使用缓存，那需要我们自己配置，默认是没有本地缓存的 123final InternalCache cache;public final class Cache implements Closeable, Flushable &#123;&#125; 构造函数，我们可以看到，内部使用了 DiskLruCache，如果不了解 DiskLruCache的同学，可以参考我的另外一篇文章 DiskLruCache 源码解析 ， 12345678910111213141516final DiskLruCache cache;/* read and write statistics, all guarded by &apos;this&apos; */int writeSuccessCount;int writeAbortCount;private int networkCount;private int hitCount;private int requestCount;public Cache(File directory, long maxSize) &#123; this(directory, maxSize, FileSystem.SYSTEM);&#125;Cache(File directory, long maxSize, FileSystem fileSystem) &#123; this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);&#125; 先来看看如何缓存放进去，当然，能缓存的请求类型只有 GET，HEAD，即首先判断 Response 类型，眼看这里代码写得好烂，估计作者可能睡着了，有空去 PR， 123456789101112131415161718192021222324252627282930313233343536@Nullable CacheRequest put(Response response) &#123; String requestMethod = response.request().method(); if (HttpMethod.invalidatesCache(response.request().method())) &#123; try &#123; remove(response.request()); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; return null; &#125; if (!requestMethod.equals(&quot;GET&quot;)) &#123; // Don&apos;t cache non-GET responses. We&apos;re technically allowed to cache // HEAD requests and some POST requests, but the complexity of doing // so is high and the benefit is low. return null; &#125; if (HttpHeaders.hasVaryAll(response)) &#123; return null; &#125; Entry entry = new Entry(response); DiskLruCache.Editor editor = null; try &#123; editor = cache.edit(key(response.request().url())); if (editor == null) &#123; return null; &#125; entry.writeTo(editor); return new CacheRequestImpl(editor); &#125; catch (IOException e) &#123; abortQuietly(editor); return null; &#125;&#125; 根据 url 的 md5 值的16进制来获取key，为什么要这么做呢？别想了，就这样吧 123public static String key(HttpUrl url) &#123; return ByteString.encodeUtf8(url.toString()).md5().hex(); &#125; 验证请求能否缓存 1234567public static boolean invalidatesCache(String method) &#123; return method.equals(&quot;POST&quot;) || method.equals(&quot;PATCH&quot;) || method.equals(&quot;PUT&quot;) || method.equals(&quot;DELETE&quot;) || method.equals(&quot;MOVE&quot;); // WebDAV&#125; 下面的代码是获取缓存的代码，同样先获取 key，然后获取缓存 12345678910111213141516171819202122232425262728293031@Nullable Response get(Request request) &#123; String key = key(request.url()); DiskLruCache.Snapshot snapshot; Entry entry; try &#123; snapshot = cache.get(key); if (snapshot == null) &#123; return null; &#125; &#125; catch (IOException e) &#123; // Give up because the cache cannot be read. return null; &#125; try &#123; entry = new Entry(snapshot.getSource(ENTRY_METADATA)); &#125; catch (IOException e) &#123; Util.closeQuietly(snapshot); return null; &#125; Response response = entry.response(snapshot); if (!entry.matches(request, response)) &#123; Util.closeQuietly(response.body()); return null; &#125; return response;&#125; 我们在回过头来看，这里将获取一个 CacheStrategy，通常，cacheResponse 为空，所以这一步几乎没有任何缓存，只是封装了一下 request 123456789101112131415161718192021public CacheStrategy get() &#123; CacheStrategy candidate = getCandidate(); if (candidate.networkRequest != null &amp;&amp; request.cacheControl().onlyIfCached()) &#123; // We&apos;re forbidden from using the network and the cache is insufficient. return new CacheStrategy(null, null); &#125; return candidate;&#125;private CacheStrategy getCandidate() &#123; // No cached response. if (cacheResponse == null) &#123; return new CacheStrategy(request, null); &#125; // Drop the cached response if it&apos;s missing a required handshake. if (request.isHttps() &amp;&amp; cacheResponse.handshake() == null) &#123; return new CacheStrategy(request, null); &#125; 比较重要的逻辑，大致的思路为：首先检查缓存，如果存在，则根据缓存封装一个Request，带上 ETag，If-Modify-Since 标签，访问服务器，否则直接访问服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Override public Response intercept(Chain chain) throws IOException &#123; Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; if (cache != null) &#123; cache.trackResponse(strategy); &#125; if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it. &#125; // If we&apos;re forbidden from using the network and the cache is insufficient, fail. if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(&quot;Unsatisfiable Request (only-if-cached)&quot;) .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // If we don&apos;t need the network, we&apos;re done. if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; Response networkResponse = null; try &#123; networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; 访问完以后，如果是304返回码，说明可以从缓存中拿数据，那我们就可以从缓存中拿数据，构建一个新的 Response 就行了 另一个操作就是，存储数据，即根据服务端的返回码把可以缓存的数据保存在 Cache 里，主要是根据 Cache-control Pragma ，只要能缓存，尽量缓存 123456789101112131415161718192021222324252627282930313233343536373839404142434445 // If we have a cache response too, then we&apos;re doing a conditional get. if (cacheResponse != null) &#123; if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response;&#125; 可以欣赏一下这个方法，可以加深我们对缓存的认识 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public static CacheControl parse(Headers headers) &#123; boolean noCache = false; boolean noStore = false; int maxAgeSeconds = -1; int sMaxAgeSeconds = -1; boolean isPrivate = false; boolean isPublic = false; boolean mustRevalidate = false; int maxStaleSeconds = -1; int minFreshSeconds = -1; boolean onlyIfCached = false; boolean noTransform = false; boolean immutable = false; boolean canUseHeaderValue = true; String headerValue = null; for (int i = 0, size = headers.size(); i &lt; size; i++) &#123; String name = headers.name(i); String value = headers.value(i); if (name.equalsIgnoreCase(&quot;Cache-Control&quot;)) &#123; if (headerValue != null) &#123; // Multiple cache-control headers means we can&apos;t use the raw value. canUseHeaderValue = false; &#125; else &#123; headerValue = value; &#125; &#125; else if (name.equalsIgnoreCase(&quot;Pragma&quot;)) &#123; // Might specify additional cache-control params. We invalidate just in case. canUseHeaderValue = false; &#125; else &#123; continue; &#125; int pos = 0; while (pos &lt; value.length()) &#123; int tokenStart = pos; pos = HttpHeaders.skipUntil(value, pos, &quot;=,;&quot;); String directive = value.substring(tokenStart, pos).trim(); String parameter; if (pos == value.length() || value.charAt(pos) == &apos;,&apos; || value.charAt(pos) == &apos;;&apos;) &#123; pos++; // consume &apos;,&apos; or &apos;;&apos; (if necessary) parameter = null; &#125; else &#123; pos++; // consume &apos;=&apos; pos = HttpHeaders.skipWhitespace(value, pos); // quoted string if (pos &lt; value.length() &amp;&amp; value.charAt(pos) == &apos;\\&quot;&apos;) &#123; pos++; // consume &apos;&quot;&apos; open quote int parameterStart = pos; pos = HttpHeaders.skipUntil(value, pos, &quot;\\&quot;&quot;); parameter = value.substring(parameterStart, pos); pos++; // consume &apos;&quot;&apos; close quote (if necessary) // unquoted string &#125; else &#123; int parameterStart = pos; pos = HttpHeaders.skipUntil(value, pos, &quot;,;&quot;); parameter = value.substring(parameterStart, pos).trim(); &#125; &#125; if (&quot;no-cache&quot;.equalsIgnoreCase(directive)) &#123; noCache = true; &#125; else if (&quot;no-store&quot;.equalsIgnoreCase(directive)) &#123; noStore = true; &#125; else if (&quot;max-age&quot;.equalsIgnoreCase(directive)) &#123; maxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1); &#125; else if (&quot;s-maxage&quot;.equalsIgnoreCase(directive)) &#123; sMaxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1); &#125; else if (&quot;private&quot;.equalsIgnoreCase(directive)) &#123; isPrivate = true; &#125; else if (&quot;public&quot;.equalsIgnoreCase(directive)) &#123; isPublic = true; &#125; else if (&quot;must-revalidate&quot;.equalsIgnoreCase(directive)) &#123; mustRevalidate = true; &#125; else if (&quot;max-stale&quot;.equalsIgnoreCase(directive)) &#123; maxStaleSeconds = HttpHeaders.parseSeconds(parameter, Integer.MAX_VALUE); &#125; else if (&quot;min-fresh&quot;.equalsIgnoreCase(directive)) &#123; minFreshSeconds = HttpHeaders.parseSeconds(parameter, -1); &#125; else if (&quot;only-if-cached&quot;.equalsIgnoreCase(directive)) &#123; onlyIfCached = true; &#125; else if (&quot;no-transform&quot;.equalsIgnoreCase(directive)) &#123; noTransform = true; &#125; else if (&quot;immutable&quot;.equalsIgnoreCase(directive)) &#123; immutable = true; &#125; &#125; &#125; if (!canUseHeaderValue) &#123; headerValue = null; &#125; return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPrivate, isPublic, mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, immutable, headerValue); &#125; 大致的缓存就差不多了 小结 我们今天研究了一下缓存策略，到底什么时候可以缓存，什么时候不能缓存，缓存到底是什么操作，我们今天都弄清楚了，总的来说，缓存并不是说不访问服务器了，而是说访问服务器看是否有没有数据的变化，另外缓存针对于 GET HEAD 请求，另外 DiskLruCache 的使用 欢迎讨论～ 前言 几天过去了，之前我们依次学习了 RetryAndFollowUpInterceptor、BridgeInterceptor、CacheInterceptor 看到了我们的 Request 怎么一步一步转化成 NetworkRequest，亦或是 Response 怎么处理 Response，重试跟踪，转化，缓存，但我们至今还未看到数据是怎么传送出去，今天，我们将要了解的 ConnectInterceptor 仍然没有传数据过去，但是他在建立连接，复用连接起着重要的作用，内部维护着一个连接池，连接使用的是 socket，sslsocket，分别对应HTTP1 HTTP2 的 socket 和 HTTPS 的 sslSocket 连接，关于 sslSocket，又涉及到安全问题，比如说，ssl 的建立，证书的认证，数据的加密传输，解密等等。 是什么东西？ 关于连接的拦截器，里面管理着 socket 的连接，这样方便我们之后的请求做连接复用，提高效率 源码解析 首先获取 streamAllocation，然后新建一个 stream， 1234567891011121314151617181920public final class ConnectInterceptor implements Interceptor &#123; public final OkHttpClient client; public ConnectInterceptor(OkHttpClient client) &#123; this.client = client; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;); HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); &#125;&#125; 通过 findHealthyConnection 获取一个连接，在根据 RealConnection 建立 HttpCodec 123456789101112131415161718192021public HttpCodec newStream( OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) &#123; int connectTimeout = chain.connectTimeoutMillis(); int readTimeout = chain.readTimeoutMillis(); int writeTimeout = chain.writeTimeoutMillis(); int pingIntervalMillis = client.pingIntervalMillis(); boolean connectionRetryEnabled = client.retryOnConnectionFailure(); try &#123; RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks); HttpCodec resultCodec = resultConnection.newCodec(client, chain, this); synchronized (connectionPool) &#123; codec = resultCodec; return resultCodec; &#125; &#125; catch (IOException e) &#123; throw new RouteException(e); &#125;&#125; 方法有点长，主要的思路是先从连接池里查找，若找不到就创建一个 socket 连接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException &#123; boolean foundPooledConnection = false; RealConnection result = null; Route selectedRoute = null; Connection releasedConnection; Socket toClose; synchronized (connectionPool) &#123; if (released) throw new IllegalStateException(&quot;released&quot;); if (codec != null) throw new IllegalStateException(&quot;codec != null&quot;); if (canceled) throw new IOException(&quot;Canceled&quot;); // Attempt to use an already-allocated connection. We need to be careful here because our // already-allocated connection may have been restricted from creating new streams. releasedConnection = this.connection; toClose = releaseIfNoNewStreams(); if (this.connection != null) &#123; // We had an already-allocated connection and it&apos;s good. result = this.connection; releasedConnection = null; &#125; if (!reportedAcquired) &#123; // If the connection was never reported acquired, don&apos;t report it as released! releasedConnection = null; &#125; if (result == null) &#123; // Attempt to get a connection from the pool. Internal.instance.get(connectionPool, address, this, null); if (connection != null) &#123; foundPooledConnection = true; result = connection; &#125; else &#123; selectedRoute = route; &#125; &#125; &#125; closeQuietly(toClose); if (releasedConnection != null) &#123; eventListener.connectionReleased(call, releasedConnection); &#125; if (foundPooledConnection) &#123; eventListener.connectionAcquired(call, result); &#125; if (result != null) &#123; // If we found an already-allocated or pooled connection, we&apos;re done. return result; &#125; // If we need a route selection, make one. This is a blocking operation. boolean newRouteSelection = false; if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection.hasNext())) &#123; newRouteSelection = true; routeSelection = routeSelector.next(); &#125; synchronized (connectionPool) &#123; if (canceled) throw new IOException(&quot;Canceled&quot;); if (newRouteSelection) &#123; // Now that we have a set of IP addresses, make another attempt at getting a connection from // the pool. This could match due to connection coalescing. List&lt;Route&gt; routes = routeSelection.getAll(); for (int i = 0, size = routes.size(); i &lt; size; i++) &#123; Route route = routes.get(i); Internal.instance.get(connectionPool, address, this, route); if (connection != null) &#123; foundPooledConnection = true; result = connection; this.route = route; break; &#125; &#125; &#125; if (!foundPooledConnection) &#123; if (selectedRoute == null) &#123; selectedRoute = routeSelection.next(); &#125; // Create a connection and assign it to this allocation immediately. This makes it possible // for an asynchronous cancel() to interrupt the handshake we&apos;re about to do. route = selectedRoute; refusedStreamCount = 0; result = new RealConnection(connectionPool, selectedRoute); acquire(result, false); &#125; &#125; // If we found a pooled connection on the 2nd time around, we&apos;re done. if (foundPooledConnection) &#123; eventListener.connectionAcquired(call, result); return result; &#125; // Do TCP + TLS handshakes. This is a blocking operation. result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, call, eventListener); routeDatabase().connected(result.route()); Socket socket = null; synchronized (connectionPool) &#123; reportedAcquired = true; // Pool the connection. Internal.instance.put(connectionPool, result); // If another multiplexed connection to the same address was created concurrently, then // release this connection and acquire that one. if (result.isMultiplexed()) &#123; socket = Internal.instance.deduplicate(connectionPool, address, this); result = connection; &#125; &#125; closeQuietly(socket); eventListener.connectionAcquired(call, result); return result; &#125; 建立protocol连接，此处如果是 TLS ，则建立 sslsocket 连接 1234567891011121314151617181920212223private void establishProtocol(ConnectionSpecSelector connectionSpecSelector, int pingIntervalMillis, Call call, EventListener eventListener) throws IOException &#123; if (route.address().sslSocketFactory() == null) &#123; if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) &#123; socket = rawSocket; protocol = Protocol.H2_PRIOR_KNOWLEDGE; startHttp2(pingIntervalMillis); return; &#125; socket = rawSocket; protocol = Protocol.HTTP_1_1; return; &#125; eventListener.secureConnectStart(call); connectTls(connectionSpecSelector); eventListener.secureConnectEnd(call, handshake); if (protocol == Protocol.HTTP_2) &#123; startHttp2(pingIntervalMillis); &#125;&#125; 建立 TSL，在 rawSocket 的基础上建立 sslSocket 连接，然后握手，检测证书，返回连接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IOException &#123; Address address = route.address(); SSLSocketFactory sslSocketFactory = address.sslSocketFactory(); boolean success = false; SSLSocket sslSocket = null; try &#123; // Create the wrapper over the connected socket. sslSocket = (SSLSocket) sslSocketFactory.createSocket( rawSocket, address.url().host(), address.url().port(), true /* autoClose */); // Configure the socket&apos;s ciphers, TLS versions, and extensions. ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket); if (connectionSpec.supportsTlsExtensions()) &#123; Platform.get().configureTlsExtensions( sslSocket, address.url().host(), address.protocols()); &#125; // Force handshake. This can throw! sslSocket.startHandshake(); // block for session establishment SSLSession sslSocketSession = sslSocket.getSession(); Handshake unverifiedHandshake = Handshake.get(sslSocketSession); // Verify that the socket&apos;s certificates are acceptable for the target host. if (!address.hostnameVerifier().verify(address.url().host(), sslSocketSession)) &#123; X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(0); throw new SSLPeerUnverifiedException(&quot;Hostname &quot; + address.url().host() + &quot; not verified:&quot; + &quot;\\n certificate: &quot; + CertificatePinner.pin(cert) + &quot;\\n DN: &quot; + cert.getSubjectDN().getName() + &quot;\\n subjectAltNames: &quot; + OkHostnameVerifier.allSubjectAltNames(cert)); &#125; // Check that the certificate pinner is satisfied by the certificates presented. address.certificatePinner().check(address.url().host(), unverifiedHandshake.peerCertificates()); // Success! Save the handshake and the ALPN protocol. String maybeProtocol = connectionSpec.supportsTlsExtensions() ? Platform.get().getSelectedProtocol(sslSocket) : null; socket = sslSocket; source = Okio.buffer(Okio.source(socket)); sink = Okio.buffer(Okio.sink(socket)); handshake = unverifiedHandshake; protocol = maybeProtocol != null ? Protocol.get(maybeProtocol) : Protocol.HTTP_1_1; success = true; &#125; catch (AssertionError e) &#123; if (Util.isAndroidGetsocknameError(e)) throw new IOException(e); throw e; &#125; finally &#123; if (sslSocket != null) &#123; Platform.get().afterHandshake(sslSocket); &#125; if (!success) &#123; closeQuietly(sslSocket); &#125; &#125;&#125; 关于 SSL 更多的内容，可自行 google 小结 ConnectInterceptor 的作用我们现在大致有个轮廓了，但总感觉还不够清晰，需要多加巩固，其中有关于 X509TrustManager，自定义证书的信任，其他的由 sslContext 帮我们做了处理 前言 激动人心的时刻将要来了，我们将会看到数据是怎么在客户端服务端之间进行交互的，但是再此之前，我们有必要了解一下 socket 纠结是什么东西，与 HTTP 协议，TCP/IP 协议之间的关系又是如何，这些理论暂且自行查找，我在这暂且简单说一说，socket 并不是协议，它实现了 TCP/UDP 的语义，而HTTP 是属于应用层的协议，我们并不能直接使用 TCP、UDP 来传输数据，而这时候我们可以使用 socket 来实现。当我们使用 socket 建立 TCP 连接，之后便可以使用这个连接用来收发数据。当你对 HTTP 协议了解深入了，就会体会到这中间的妙处，建议是看一下 HTTP 协议，可以看 RFC 官方文档，下次在简历上可以说精通 TCP/IP、HTTP 协议，这可比项目吸引眼球多了。又想去改简历了 12 | SOCKET |IP -&gt; TCP -&gt; HTTP HTTP 协议 若要理解 HTTP 协议，莫过于使用它，安利一下 wireshark 这个工具，还是超级好用的，可以清楚地看到包的内容，各层协议封装的内容，看多了就会很清楚包里面的数据格式，之所以然而知其所以然。 我们在使用 socket 的时候，通常就是往 socket 里写入 HTTP 消息，下面给出两个简单的例子，我们只需要把这些文本写入流中便可，即可完成一次简单的 HTTP 通信，当然，实际的协议要比这复杂得多，很多协议需要浏览器与服务器自行实现。 Request 12345GET URL HTTP/1.1\\r\\n // 请求行Host: www.cnblogs.com\\r\\n // 请求头Connection: keep-alive\\r\\nAccept: application/json, text/javascript, */*; q=0.01\\r\\n\\r\\n Response 12345HTTP/1.1 200 OK\\r\\n // 响应行Date: Wed, 22 Aug 2018 02:10:58 GMT\\r\\n // 响应头...\\r\\n // 空行File Data: 5 bytes // 请求数据 源码解析 1public final class CallServerInterceptor implements Interceptor &#123;&#125; 通常，是由 httpCodec.writeRequestHeaders(request) 写入 socket 流中，然后通过 flushRequest 刷新缓存，请求便发给服务端了，中间可能遇到很多情况 100 如果客户端使用了 Expect：100-continue，那么客户端会先发送 headers，获取响应，如果服务器能够接收并且发送了 100 返回码，那么客户端会继续发送数据构建 Response 101 协议升级，重新构建 Response 204 205 检查是否有异常 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; HttpCodec httpCodec = realChain.httpStream(); StreamAllocation streamAllocation = realChain.streamAllocation(); RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); realChain.eventListener().requestHeadersStart(realChain.call()); httpCodec.writeRequestHeaders(request); realChain.eventListener().requestHeadersEnd(realChain.call(), request); Response.Builder responseBuilder = null; if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123; // If there&apos;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100 // Continue&quot; response before transmitting the request body. If we don&apos;t get that, return // what we did get (such as a 4xx response) without ever transmitting the request body. if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) &#123; httpCodec.flushRequest(); realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(true); &#125; if (responseBuilder == null) &#123; // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met. realChain.eventListener().requestBodyStart(realChain.call()); long contentLength = request.body().contentLength(); CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, contentLength)); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); realChain.eventListener() .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount); &#125; else if (!connection.isMultiplexed()) &#123; // If the &quot;Expect: 100-continue&quot; expectation wasn&apos;t met, prevent the HTTP/1 connection // from being reused. Otherwise we&apos;re still obligated to transmit the request body to // leave the connection in a consistent state. streamAllocation.noNewStreams(); &#125; &#125; httpCodec.finishRequest(); 当然，其中也包括 https的传输，而使用 sslSocket 惊喜加密通信。 小结 基本上我们看到了 OkHttp 必备的 Interceptor，大致的流程我们已经清楚了，接下来就是细节推导，我们时常更新细节","categories":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/categories/Android/"},{"name":"Java","slug":"Android/Java","permalink":"https://wzes.github.io/categories/Android/Java/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"HTTP-Code-总结","slug":"Network/HTTP Code 总结","date":"2018-08-23T06:29:00.000Z","updated":"2019-09-02T12:22:27.115Z","comments":true,"path":"2018/08/23/Network/HTTP Code 总结/","link":"","permalink":"https://wzes.github.io/2018/08/23/Network/HTTP Code 总结/","excerpt":"","text":"每天背一个状态码系列 1xx Informational response 100 Continue 通俗点说的话，如果是POST 请求，我们的提交的数据超过1024 个字节，那么服务器可能不接受，那么我们可以先发一个请求，在请求头里加入 “Expect”:”100-continue”，询问服务器是否接受，这时候如果服务器能够接收，那么我们在提交请求，而不是我们一次性直接提交数据，这样做在一定程度上减缓了服务器端的压力。 维基百科上说的 The server has received the request headers and the client should proceed to send the request body (in the case of a request for which a body needs to be sent; for example, a POST request). Sending a large request body to a server after a request has been rejected for inappropriate headers would be inefficient. To have a server check the request’s headers, a client must send Expect: 100-continueas a header in its initial request and receive a 100 Continue status code in response before sending the body. If the client receives an error code such as 403 (Forbidden) or 405 (Method Not Allowed) then it shouldn’t send the request’s body. The response 417 Expectation Failed indicates that the request should be repeated without the Expect header as it indicates that the server doesn’t support expectations (this is the case, for example, of HTTP/1.0 servers).[5] 101 Switching Protocols 就是说，如果服务器发现对方在 Upgrade 中的协议，如果自己有支持更合适的，会发送 101 响应码，客户端收到后，更换协议重新访问 The requester has asked the server to switch protocols and the server has agreed to do so 2xx Successful 200 OK 通俗点说，200 表示请求成功，如果是 GET 请求，那就返回完成的数据，如果是 POST 请求，那么返回操作的执行结果 Standard response for successful HTTP requests. The actual response will depend on the request method used. In a GET request, the response will contain an entity corresponding to the requested resource. In a POST request, the response will contain an entity describing or containing the result of the action 201 Created 通常来说，这个状态吗用于 PUT 请求的返回码，说的是资源已经创建，然后服务器可以将资源的地址写到响应头中的Location字段里，或者是数据里 The request has been fulfilled and resulted in a new resource being created. The newly created resource can be referenced by the URI(s) returned in the entity of the response, with the most specific URI for the resource given by a Location header field. The response SHOULD include an entity containing a list of resource characteristics and location(s) from which the user or user agent can choose the one most appropriate. The entity format is specified by the media type given in the Content-Type header field. The origin server MUST create the resource before returning the 201 status code. If the action cannot be carried out immediately, the server SHOULD respond with 202 (Accepted) response instead. A 201 response MAY contain an ETag response header field indicating the current value of the entity tag for the requested variant just created, see section 202 Accepted 与 201 不同，202返回的话是请求没有处理完成，该请求可用于异步处理的返回码 The HyperText Transfer Protocol (HTTP) 202 Accepted response status code indicates that the request has been received but not yet acted upon. It is non-committal, meaning that there is no way for the HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing. 204 No Content 服务器成功响应，但是没有返回数据，客户端不应该对此做出反应，也就是说没要跳转 If the client is a user agent, it SHOULD NOT change its document view from that which caused the request to be sent. This response is primarily intended to allow input for actions to take place without causing a change to the user agent’s active document view, although any new or updated metainformation SHOULD be applied to the document currently in the user agent’s active view. 205 Reset Content 同样也是没有数据返回，但是客户端应该重置表单 The server successfully processed the request, but is not returning any content. Unlike a 204 response, this response requires that the requester reset the document view 206 Partial Content 返回部分数据，多用于下载数据，如果数据量过大，可能需要分段下载，在 Header 是以 Range 表示的 The HTTP 206 Partial Content success status response code indicates that the request has succeeded and has the body contains the requested ranges of data, as described in the Range header of the request. 3xx Redirect 300 Multiple Choices 多种选择，客户端收到后应该根据 Location 选择其中一个请求进行访问 The HTTP 300 Multiple Choices redirect status response code indicates that the request has more than one possible responses. The user-agent or the user should choose one of them. As there is no standardized way of choosing one of the responses, this response code is very rarely used. 301 Moved Permanently 永久移动地址，会在 Location 中附上新地址，客户端可以根据这个地址进行新的请求，通常用于 HEAD 和 POST 请求 The HyperText Transfer Protocol (HTTP) **301 Moved Permanently** redirect status response code indicates that the resource requested has been definitively moved to the URL given by the Location headers. A browser redirects to this page and search engines update their links to the resource (in ‘SEO-speak’, it is said that the ‘link-juice’ is sent to the new URL). Even if the specification requires the method (and the body) not to be altered when the redirection is performed, not all user-agents align with it - you can still find this type of bugged software out there. It is therefore recommended to use the 301 code only as a response for GET or HEAD methods and to use the 308 Permanent Redirect for POST methods instead, as the method change is explicitly prohibited with this status. 12HTTP/1.1 301 Moved PermanentlyLocation: http://www.example.org/index.asp 304 Not Modified 比如说一个 css 文件，客户端第二次加载时在请求头里带上 cache-control：max-age=0，以及 If-Modified-Since，如果服务器收到后，发现请求的资源没有改变，会返回一个 304，这样客户端就可以知道使用本地的缓存资源 Indicates that the resource has not been modified since the version specified by the request headers If-Modified-Since or If-None-Match. In such case, there is no need to retransmit the resource since the client still has a previously-downloaded copy.","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://wzes.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://wzes.github.io/tags/HTTP/"}]},{"title":"HTTP Request Response 总结","slug":"Network/HTTP Request&Response 总结","date":"2018-08-23T06:28:00.000Z","updated":"2019-09-02T12:22:34.491Z","comments":true,"path":"2018/08/23/Network/HTTP Request&Response 总结/","link":"","permalink":"https://wzes.github.io/2018/08/23/Network/HTTP Request&Response 总结/","excerpt":"","text":"Request 我用 wireshark 工具分析了一个 HTTP 请求，可以看到大致的格式 其中HTTP的明文数据格式如下 1234567GET URL HTTP/1.1\\r\\n // 请求行Host: www.cnblogs.com\\r\\n // 请求头Connection: keep-alive\\r\\nAccept: application/json, text/javascript, */*; q=0.01\\r\\n....\\r\\n // 空行data // 如果是 POST，可能有请求数据 Accept-Encoding 可接受的数据内容格式，比如是 gzip，服务器收到后根据这个使用 gzip 压缩数据，并在 Content-Encoding 中表明数据格式，这样客户端就可以接收到这个信息 Content-Encoding 发送的数据内容格式，比如是 gzip，服务器收到后根据这个使用 gzip 解压数据 Cookie 格式 12Set-Cookie: Name = Value; Comment = value; Domain = value; Max-Age = value; Path = Value;Secure; Version = 1 * DIGIT; Response 我用 wireshark 工具分析了一个 HTTP 响应请求，可以看到大致的格式 其中HTTP的明文数据格式如下 12345HTTP/1.1 200 OK\\r\\n // 响应行Date: Wed, 22 Aug 2018 02:10:58 GMT\\r\\n // 响应头...\\r\\n // 空行File Data: 5 bytes // 请求数据 Date Example： Date: Tue, 15 Nov 1994 08:12:31 GMT 这个是属于服务器的时间，在RFC标准里面，服务器返回的数据中必须包含这个域，有三种情况除外 If the response status code is 100 (Continue) or 101 (Switching Protocols), the response MAY include a Date header field, at the server’s option 100 和 101 请求可选 If the response status code conveys a server error, e.g. 500 (Internal Server Error) or 503 (Service Unavailable), and it is inconvenient or impossible to generate a valid Date. 服务器出现了问题，这时候也可以不能返回 If the server does not have a clock that can provide a reasonable approximation of the current time, its responses MUST NOT include a Date header field. In this case, the rules is 服务器不能提供可靠的时间服务 Some origin server implementations might not have a clock available.An origin server without a clock MUST NOT assign Expires or Last-Modified values to a response, unless these values were associated with the resource by a system or user with a reliable clock. It MAY assign an Expires value that is known, at or before server configuration time, to be in the past (this allows “pre-expiration” of responses without storing separate Expires values for each resource).","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://wzes.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://wzes.github.io/tags/HTTP/"}]},{"title":"Java8 CopyOnWriteArrayList 源码解析","slug":"Java/Java8 CopyOnWriteArrayList 源码解析","date":"2018-08-21T09:11:00.000Z","updated":"2019-09-02T12:20:48.952Z","comments":true,"path":"2018/08/21/Java/Java8 CopyOnWriteArrayList 源码解析/","link":"","permalink":"https://wzes.github.io/2018/08/21/Java/Java8 CopyOnWriteArrayList 源码解析/","excerpt":"","text":"前言 一看这个，咋这么长的名字，记起来有点麻烦呀！这个类使用的情况不多，最近在看EventBus的时候看到过，所以还是跳出来学习一下，看一下这个类的庐山真面目 是什么东西？ CopyOnWrite，大概能猜到跟写时复制有关，为什么要有这个东西？不难想出这是为了线程安全而设计的，否则直接用 ArrayList 就行了，那好了，说的这个东西就是一个ArrayList ，在此基础上，他是线程安全的，采用了写时复制的方法，那我们可以思考一下，他是怎么做的，如果给我们设计，我们要怎么做呢？ 前世今生 它没有扩展 ArrayList，即使是以此结尾，直接实现了 List，也实现了RandomAccess，Cloneable， Serializable 接口，Doug Lea 写的，就是厉害 12public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 源码解析 属性 我们看到了一个锁，聪明的你可能想到了，是不是可以加锁来实现线程的安全？在写的时候加锁，读的时候可以不用锁 同样使用了 Volatile 的 Object 数组存储元素 两个final 方法设置 elements 123456789101112131415161718192021222324/** * The lock protecting all mutators. (We have a mild preference * for builtin monitors over ReentrantLock when either will do.) */final transient Object lock = new Object();/** The array, accessed only via getArray/setArray. */// Android-changed: renamed array -&gt; elements for backwards compatibility b/33916927private transient volatile Object[] elements;/** * Gets the array. Non-private so as to also be accessible * from CopyOnWriteArraySet class. */final Object[] getArray() &#123; return elements;&#125;/** * Sets the array. */final void setArray(Object[] a) &#123; elements = a;&#125; 构造函数，默认大小为0，也可以传入集合类对象进行复制，或者直接传入数组，这里用到了 Arrays.copyOf，这是一个数组复制的静态函数，底层使用了System.arraycopy，效率很高，反悔了一个新的数组 123456789101112131415161718192021222324252627282930313233343536373839/** * Creates an empty list. */public CopyOnWriteArrayList() &#123; setArray(new Object[0]);&#125;/** * Creates a list containing the elements of the specified * collection, in the order they are returned by the collection&apos;s * iterator. * * @param c the collection of initially held elements * @throws NullPointerException if the specified collection is null */public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) &#123; Object[] elements; if (c.getClass() == CopyOnWriteArrayList.class) elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray(); else &#123; elements = c.toArray(); // defend against c.toArray (incorrectly) not returning Object[] // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652) if (elements.getClass() != Object[].class) elements = Arrays.copyOf(elements, elements.length, Object[].class); &#125; setArray(elements);&#125;/** * Creates a list holding a copy of the given array. * * @param toCopyIn the array (a copy of this array is used as the * internal array) * @throws NullPointerException if the specified array is null */public CopyOnWriteArrayList(E[] toCopyIn) &#123; setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));&#125; 函数 get 没有加锁，直接返回，由于volatile，能保证读到最新的值 123private E get(Object[] a, int index) &#123; return (E) a[index];&#125; set，果不其然，对添加数据使用了加锁，首先检查这个位置是否存在对象，如果不存在，那么需要拷贝一个新的数组，并且添加一个元素，在调用elements更新属性；如果存在了，也需要设置数组，保证volatile的语义，这里不是很明白，既然都加了锁，不需要更新数据时还要更新数据。最后返回 oldValue。 至于为什么，在这里看到有人讨论 concurrency-interest，但感觉也没有数清楚，不过我看到了，之前的jdk版本使用了 Lock而不是 synchronized ，可见synchronized 的性能以及大大提高 1234567891011121314151617public E set(int index, E element) &#123; synchronized (lock) &#123; Object[] elements = getArray(); E oldValue = get(elements, index); if (oldValue != element) &#123; int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len); newElements[index] = element; setArray(newElements); &#125; else &#123; // Not quite a no-op; ensures volatile write semantics setArray(elements); &#125; return oldValue; &#125;&#125; add，依然使用锁，同样先读数组，在复制出一个新的数组，注意，数组长度为 len + 1，预留了一个位置，因此这个数据结构并没有类似 *2 的扩容机制，而是一个一个添加，个人觉得这样效率会大打折扣，当然，为了 tradeoff。在添加元素，最后返回true 12345678910public boolean add(E e) &#123; synchronized (lock) &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125;&#125; add，在某个位置插入一个元素，首先先检查index，看是否越界，这里使用了一个小技巧，计算了移动距离，如果为0，即添加到最后，则直接复制，否则就需要调用两次 copy 函数进行复制 1234567891011121314151617181920public void add(int index, E element) &#123; synchronized (lock) &#123; Object[] elements = getArray(); int len = elements.length; if (index &gt; len || index &lt; 0) throw new IndexOutOfBoundsException(outOfBounds(index, len)); Object[] newElements; int numMoved = len - index; if (numMoved == 0) newElements = Arrays.copyOf(elements, len + 1); else &#123; newElements = new Object[len + 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index, newElements, index + 1, numMoved); &#125; newElements[index] = element; setArray(newElements); &#125;&#125; remove 可以删除某个索引的元素 123456789101112131415161718public E remove(int index) &#123; synchronized (lock) &#123; Object[] elements = getArray(); int len = elements.length; E oldValue = get(elements, index); int numMoved = len - index - 1; if (numMoved == 0) setArray(Arrays.copyOf(elements, len - 1)); else &#123; Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); &#125; return oldValue; &#125;&#125; remove也可以删除某个对象，不过需要遍历数组 12345678910111213141516171819public boolean remove(Object o) &#123; Object[] snapshot = getArray(); int index = indexOf(o, snapshot, 0, snapshot.length); return (index &lt; 0) ? false : remove(o, snapshot, index);&#125;private static int indexOf(Object o, Object[] elements, int index, int fence) &#123; if (o == null) &#123; for (int i = index; i &lt; fence; i++) if (elements[i] == null) return i; &#125; else &#123; for (int i = index; i &lt; fence; i++) if (o.equals(elements[i])) return i; &#125; return -1;&#125; 最后还是调用这个，也是线程安全的函数，逻辑也很简单 123456789101112131415161718192021222324252627282930private boolean remove(Object o, Object[] snapshot, int index) &#123; synchronized (lock) &#123; Object[] current = getArray(); int len = current.length; if (snapshot != current) findIndex: &#123; int prefix = Math.min(index, len); for (int i = 0; i &lt; prefix; i++) &#123; if (current[i] != snapshot[i] &amp;&amp; Objects.equals(o, current[i])) &#123; index = i; break findIndex; &#125; &#125; if (index &gt;= len) return false; if (current[index] == o) break findIndex; index = indexOf(o, current, index, len); if (index &lt; 0) return false; &#125; Object[] newElements = new Object[len - 1]; System.arraycopy(current, 0, newElements, 0, index); System.arraycopy(current, index + 1, newElements, index, len - index - 1); setArray(newElements); return true; &#125;&#125; removeRange 删除一定范围，不用说了，相信他的代码你早就知道该怎么写了 12345void removeRange(int fromIndex, int toIndex) &#123; synchronized (lock) &#123; ..... &#125;&#125; addIfAbsent 如果不存在才添加 123456789101112131415161718192021222324252627282930public boolean addIfAbsent(E e) &#123; Object[] snapshot = getArray(); return indexOf(e, snapshot, 0, snapshot.length) &gt;= 0 ? false : addIfAbsent(e, snapshot);&#125;/** * A version of addIfAbsent using the strong hint that given * recent snapshot does not contain e. */private boolean addIfAbsent(E e, Object[] snapshot) &#123; synchronized (lock) &#123; Object[] current = getArray(); int len = current.length; if (snapshot != current) &#123; // Optimize for lost race to another addXXX operation int common = Math.min(snapshot.length, len); for (int i = 0; i &lt; common; i++) if (current[i] != snapshot[i] &amp;&amp; Objects.equals(e, current[i])) return false; if (indexOf(e, current, common, len) &gt;= 0) return false; &#125; Object[] newElements = Arrays.copyOf(current, len + 1); newElements[len] = e; setArray(newElements); return true; &#125;&#125; 类似还有 addAllIfAbsent，写得还是很不错的，毕竟是 Doug Lea 1234567891011121314151617181920212223public int addAllAbsent(Collection&lt;? extends E&gt; c) &#123; Object[] cs = c.toArray(); if (cs.length == 0) return 0; synchronized (lock) &#123; Object[] elements = getArray(); int len = elements.length; int added = 0; // uniquify and compact elements in cs for (int i = 0; i &lt; cs.length; ++i) &#123; Object e = cs[i]; if (indexOf(e, elements, 0, len) &lt; 0 &amp;&amp; indexOf(e, cs, 0, added) &lt; 0) cs[added++] = e; &#125; if (added &gt; 0) &#123; Object[] newElements = Arrays.copyOf(elements, len + added); System.arraycopy(cs, 0, newElements, len, added); setArray(newElements); &#125; return added; &#125;&#125; 小结 分析别人的源码的过程本身就是一个学习的过程，能从中学到很多新的东西，并且能够巩固以前的知识。 欢迎讨论～","categories":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"Java8 ThreadLocal 源码解析","slug":"Java/Java8 ThreadLocal 源码解析","date":"2018-08-20T15:16:00.000Z","updated":"2019-09-02T12:21:15.926Z","comments":true,"path":"2018/08/20/Java/Java8 ThreadLocal 源码解析/","link":"","permalink":"https://wzes.github.io/2018/08/20/Java/Java8 ThreadLocal 源码解析/","excerpt":"","text":"前言 ThreadLocal ，像是一个神秘的黑衣人，令人望而生畏。唯有下定决心，一探究竟，方能解开他神秘的面纱、在Android中，Handler，EventBus，ConnectionPool 等等，都曾出现它的身影 是什么东西？ 看到Thread，就想到应该是与线程有关吧，其次，Local是说本地，那组合起来就是线程私有，就是说每个线程都有备份，各备份不是同一个对象，一般来说，他的用途就是让各个线程拥有不用的对象，它的对象都是 new 出来的，哪有人可能会问，既然是 new 出来的，那为什么还要用 ThreadLocal，直接 new 一个对象不就行了，你如果不仔细了解 ThreadLocal，就很难解答这样的问题 前世今生 是一个泛型类 1public class ThreadLocal&lt;T&gt; &#123;&#125; 源码解析 属性 nextHashCode 是获取 hashcode 值，HASH_INCREMENT 初始值为0x61c88647，nextHashCode()函数每次调用增加增量获取下一个值，大家可以好好看看Atomic的实现，以及底层Unsafe的语义 12345678910111213141516171819202122private final int threadLocalHashCode = nextHashCode();/** * The next hash code to be given out. Updated atomically. Starts at * zero. */private static AtomicInteger nextHashCode = new AtomicInteger();/** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */private static final int HASH_INCREMENT = 0x61c88647;/** * Returns the next hash code. */private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125; 函数 初始值函数 123protected T initialValue() &#123; return null;&#125; set ，将值拷贝到当前线程，使用ThreadLocalMap，这是一个内部类，要了解ThreadLocal，这个类是不得不了解的 123456789101112public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 一探ThreadLocalMap，前方高能，他是一个静态内部类，类似于WeakHashMap，只不过他没有WeakHashMap那么强大，没有Map那么多的接口，不过作为一个内部类，只需要为ThreadLocal服务就可以了，这一条可以在EffectiveJava里找到，废话不多说，看一下他的Entry，继承自WeakReference，关于WeakReference，又可以花大篇幅来介绍了，不过现在暂时不说了，你只要记住当发生GC的时候，WeakReference的对象都会被回收。同样内部也是用Entry数组，默认大小为16，set 函数需要注意的是如何处理哈希碰撞的问题，这里扯一下，处理哈希碰撞的如HashMap使用了拉链法，而这里使用了简单的开发地址法，具体来说就是如果发生了碰撞，就位置就+1，一直到有位置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273static class ThreadLocalMap &#123; /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as &quot;stale entries&quot; in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; /** * The initial capacity -- MUST be a power of two. */ private static final int INITIAL_CAPACITY = 16; /** * The table, resized as necessary. * table.length MUST always be a power of two. */ private Entry[] table; /** * The number of entries in the table. */ private int size = 0; /** * The next size value at which to resize. */ private int threshold; // Default to 0 &#125; // set 函数，同样也是使用key的hashcode 与 len-1的 // 与值 private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // We don&apos;t use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; 最重要的 get 函数，我们需要记住的是，每个线程有一个ThreadLocalMap，每个Map可以放很多个值，也就是不用的ThreadLocal对象。如果Get 不到数据的话，就会调用InitialValue函数进行赋值，所以有时候我们会重写这个函数，以保证get函数都能获取到正确的值 123456789101112131415161718192021/** * Returns the value in the current thread&apos;s copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread&apos;s value of this thread-local */public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 由于使用了WeakReference，可能会存在值丢失，那ThreadLocalMap又是怎么处理这种情况呢？首先自然是处理hash碰撞的问题，通过nextIndex来遍历，其中如果出现某个key获取不到的话，就会执行 expungeStaleEntry(i) 删除旧的entry，具体的做法就是删除这个entry，以及之后出现为空的所有entry 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; &#125; return null; &#125; private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i; &#125; 小结 一个 ThreadLocal 竟包含了如此多的知识，当你熟读各种源码的时候，各种设计模式，各种细节，作者实现的非常有借鉴意义，理解了这样的源码，在今后的项目中使用类似的，便可以知其然知其所以然，做到各种框架的深度定制，甚至实现自己的框架！ 欢迎讨论～","categories":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"Java8-ThreadLocal-源码解析","slug":"Java/Java8 关于最佳线程数","date":"2018-08-20T15:16:00.000Z","updated":"2019-09-02T12:21:30.398Z","comments":true,"path":"2018/08/20/Java/Java8 关于最佳线程数/","link":"","permalink":"https://wzes.github.io/2018/08/20/Java/Java8 关于最佳线程数/","excerpt":"","text":"前言 关于最佳线程数的设置，总是那么模糊，不知道该如何设置，偶然间在 Java 并发编程实践 里看到了对他的定义： 要使处理器达到期望的使用率，线程池的最佳大小等于： 需要注意的是，我们需要制定一个 CPU 的利用率，如果是 100%，那么线程数就取决于Wait Time / Compute Time 如果我们的任务是计算型任务，那么等待时间为零，那么线程数设置为 CPU + 1 如果我们的任务是 IO 密集型，那么等待时间不为零，需要加大线程数 Java 中获取可用的 CPU 数 1Int NUM_CPU = Runtime.getRuntime().availableProcessors(); 我们可以在很多类库里边看到它的身影，很多需要线程池的类库，凡是不那么抢系统资源的都会通过这个值设置线程池的大小","categories":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"Android EventBus 源码解析","slug":"Android/EventBus","date":"2018-08-19T13:09:00.000Z","updated":"2019-09-02T12:18:23.891Z","comments":true,"path":"2018/08/19/Android/EventBus/","link":"","permalink":"https://wzes.github.io/2018/08/19/Android/EventBus/","excerpt":"","text":"基于最新的 3.1.1 分析 前言 之前分析的都是官方库的一些源码，现在打算尝试分析一些比较优秀的第三方开源库，选择分析EventBus，一方面是因为他的库不大，容易理解，这样我们也容易接受，如果一开始就项分析很大的库，会比较难吧。 是什么东西？ EventBus 是一个基于Android 或者Java 的发布订阅的消息总线，从使用上来说，它允许我们通过注解，就能在Android 中自由的切换线程，发布，接受消息，极大的减轻了我们使用Handler的负担，做了很好的解耦。 官方架构图 先手写一个小例子吧 在onCreate里边注册 1234@Overridepublic void onCreate(Bundle savedInstanceState) &#123; EventBus.getDefault().register(this);&#125; 在onDestroy里边取消 1234@Overridepublic void onDestroy() &#123; EventBus.getDefault().unregister(this);&#125; 在Activity 订阅消息 1234@Subscribe(threadMode = ThreadMode.MAIN)public void subscribe(Object object) &#123; Log.i(TAG, &quot;Recevied: &quot; + object);&#125; 在其他地方发布消息 1new Thread(() -&gt; EventBus.getDefault().post(new Object())).start(); 这样就完成了一次完整的事件发布订阅流程，是不是要比Handler更简单，很方便呢，更清晰？ 前世今生 1public class EventBus &#123;&#125; 源码分析 属性 defaultInstance 是默认的实例，使用Singleton实现，饿汉式，注意volatile的使用，很多同学在写恶汉容易遗漏。DEFAULT_BUILDER 是默认的，唯一。eventTypesCache是事件类型集合，subscriptionsByEventType是根据事件类型分组的订阅集合，typesBySubscriber 是根据订阅者分组的事件类型集合 12345678static volatile EventBus defaultInstance;private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();private static final Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; eventTypesCache = new HashMap&lt;&gt;();private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents; 没看懂 12345678910111213141516private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() &#123; @Override protected PostingThreadState initialValue() &#123; return new PostingThreadState(); &#125;&#125;;/** For ThreadLocal, much faster to set (and get multiple values). */final static class PostingThreadState &#123; final List&lt;Object&gt; eventQueue = new ArrayList&lt;&gt;(); boolean isPosting; boolean isMainThread; Subscription subscription; Object event; boolean canceled;&#125; 五种线程模型，主线程，后台线程，异步线程，和当前线程一样，有顺序的 123456// @Nullableprivate final MainThreadSupport mainThreadSupport;// @Nullableprivate final Poster mainThreadPoster;private final BackgroundPoster backgroundPoster;private final AsyncPoster asyncPoster; 一个是订阅发现者，主要是为了获取订阅的数据，另外就是线程池 12private final SubscriberMethodFinder subscriberMethodFinder;private final ExecutorService executorService; 一些final变量 123456789private final boolean throwSubscriberException;private final boolean logSubscriberExceptions;private final boolean logNoSubscriberMessages;private final boolean sendSubscriberExceptionEvent;private final boolean sendNoSubscriberEvent;private final boolean eventInheritance;private final int indexCount;private final Logger logger; 构造函数 使用默认的建造者去初始化EventBus，主要是对之前属性的初始化 12345678910111213141516171819202122232425262728/** * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a * central bus, consider &#123;@link #getDefault()&#125;. */public EventBus() &#123; this(DEFAULT_BUILDER);&#125;EventBus(EventBusBuilder builder) &#123; logger = builder.getLogger(); subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); mainThreadSupport = builder.getMainThreadSupport(); mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null; backgroundPoster = new BackgroundPoster(this); asyncPoster = new AsyncPoster(this); indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0; subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex); logSubscriberExceptions = builder.logSubscriberExceptions; logNoSubscriberMessages = builder.logNoSubscriberMessages; sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; sendNoSubscriberEvent = builder.sendNoSubscriberEvent; throwSubscriberException = builder.throwSubscriberException; eventInheritance = builder.eventInheritance; executorService = builder.executorService;&#125; getDefault() 使用单例模式，DoubleCheck 1234567891011/** Convenience singleton for apps using a process-wide EventBus instance. */public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance;&#125; 顺便看一下EventBusBuilder 线程池使用的是默认的CachedThreadPool，核心线程数为0，其余变量都为ture，之后再分析用途 123456789101112131415161718private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();boolean logSubscriberExceptions = true;boolean logNoSubscriberMessages = true;boolean sendSubscriberExceptionEvent = true;boolean sendNoSubscriberEvent = true;boolean throwSubscriberException;boolean eventInheritance = true;boolean ignoreGeneratedIndex;boolean strictMethodVerification;ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE;List&lt;Class&lt;?&gt;&gt; skipMethodVerificationForClasses;List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes;Logger logger;MainThreadSupport mainThreadSupport;EventBusBuilder() &#123;&#125; 在重点看一下这几个参数的赋值，首先对mainThreadSupport赋值，调用EventBusBuilder的getMainThreadSupport方法，该方法第一次是通过getAndroidMainLooperOrNull() 获取一个MainLooper，也就是ActivityThread的main中初始化的MainLooper对象 1234567891011121314151617181920212223mainThreadSupport = builder.getMainThreadSupport(); // class evnetbusbuilderMainThreadSupport getMainThreadSupport() &#123; if (mainThreadSupport != null) &#123; return mainThreadSupport; &#125; else if (Logger.AndroidLogger.isAndroidLogAvailable()) &#123; Object looperOrNull = getAndroidMainLooperOrNull(); return looperOrNull == null ? null : new MainThreadSupport.AndroidHandlerMainThreadSupport((Looper) looperOrNull); &#125; else &#123; return null; &#125;&#125;Object getAndroidMainLooperOrNull() &#123; try &#123; return Looper.getMainLooper(); &#125; catch (RuntimeException e) &#123; // Not really a functional Android (e.g. &quot;Stub!&quot; maven dependencies) return null; &#125;&#125; 上一步获取到了一个MainThreadSupport，其中的Looper为MainLooper 1234567891011121314151617181920212223242526public interface MainThreadSupport &#123; boolean isMainThread(); Poster createPoster(EventBus eventBus); class AndroidHandlerMainThreadSupport implements MainThreadSupport &#123; private final Looper looper; public AndroidHandlerMainThreadSupport(Looper looper) &#123; this.looper = looper; &#125; @Override public boolean isMainThread() &#123; return looper == Looper.myLooper(); &#125; @Override public Poster createPoster(EventBus eventBus) &#123; return new HandlerPoster(eventBus, looper, 10); &#125; &#125;&#125; 给mainThreadPoster 赋值，创建了一个HandlerPoster，参数为this，MainLooper， 10，10指的是最大消息处理延时 1mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null; 看一下HandlerPoster的实现，继承自Handler，实现了 Poster的enqueue方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class HandlerPoster extends Handler implements Poster &#123; private final PendingPostQueue queue; private final int maxMillisInsideHandleMessage; private final EventBus eventBus; private boolean handlerActive; protected HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) &#123; super(looper); this.eventBus = eventBus; this.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage; queue = new PendingPostQueue(); &#125; public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123; queue.enqueue(pendingPost); if (!handlerActive) &#123; handlerActive = true; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(&quot;Could not send handler message&quot;); &#125; &#125; &#125; &#125; @Override public void handleMessage(Message msg) &#123; boolean rescheduled = false; try &#123; long started = SystemClock.uptimeMillis(); while (true) &#123; PendingPost pendingPost = queue.poll(); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; handlerActive = false; return; &#125; &#125; &#125; eventBus.invokeSubscriber(pendingPost); long timeInMethod = SystemClock.uptimeMillis() - started; if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(&quot;Could not send handler message&quot;); &#125; rescheduled = true; return; &#125; &#125; &#125; finally &#123; handlerActive = rescheduled; &#125; &#125;&#125;interface Poster &#123; /** * Enqueue an event to be posted for a particular subscription. * * @param subscription Subscription which will receive the event. * @param event Event that will be posted to subscribers. */ void enqueue(Subscription subscription, Object event);&#125; 再来看一下他自己实现的队列，两个方法，入队和出队，线程安全 1234567891011121314151617181920212223242526272829303132333435363738final class PendingPostQueue &#123; private PendingPost head; private PendingPost tail; synchronized void enqueue(PendingPost pendingPost) &#123; if (pendingPost == null) &#123; throw new NullPointerException(&quot;null cannot be enqueued&quot;); &#125; if (tail != null) &#123; tail.next = pendingPost; tail = pendingPost; &#125; else if (head == null) &#123; head = tail = pendingPost; &#125; else &#123; throw new IllegalStateException(&quot;Head present, but no tail&quot;); &#125; notifyAll(); &#125; synchronized PendingPost poll() &#123; PendingPost pendingPost = head; if (head != null) &#123; head = head.next; if (head == null) &#123; tail = null; &#125; &#125; return pendingPost; &#125; synchronized PendingPost poll(int maxMillisToWait) throws InterruptedException &#123; if (head == null) &#123; wait(maxMillisToWait); &#125; return poll(); &#125;&#125; 队列的元素，设计的还不错，使用池的方式获取消PendingPost，获取PendingPost的时候，先检查PendingPost池大小，如果大于零，则从PendingPost池里面取最后一个PendingPost，并且删除，否则，新建一个，当释放PendingPost的时候，将PendingPost的值初始化，并且会受到PendingPost池里面，当然，这个值不能无限大，作者设计的还是挺不错的，这与我们常用的Handler中的Message设计思路差不多，大家也可以学一学 123456789101112131415161718192021222324252627282930313233343536373839final class PendingPost &#123; private final static List&lt;PendingPost&gt; pendingPostPool = new ArrayList&lt;PendingPost&gt;(); Object event;s Subscription subscription; PendingPost next; private PendingPost(Object event, Subscription subscription) &#123; this.event = event; this.subscription = subscription; &#125; static PendingPost obtainPendingPost(Subscription subscription, Object event) &#123; synchronized (pendingPostPool) &#123; int size = pendingPostPool.size(); if (size &gt; 0) &#123; PendingPost pendingPost = pendingPostPool.remove(size - 1); pendingPost.event = event; pendingPost.subscription = subscription; pendingPost.next = null; return pendingPost; &#125; &#125; return new PendingPost(event, subscription); &#125; static void releasePendingPost(PendingPost pendingPost) &#123; pendingPost.event = null; pendingPost.subscription = null; pendingPost.next = null; synchronized (pendingPostPool) &#123; // Don&apos;t let the pool grow indefinitely if (pendingPostPool.size() &lt; 10000) &#123; pendingPostPool.add(pendingPost); &#125; &#125; &#125;&#125; 然后是backgroundPoster，每一个模型都有一个queue，各自处理各自的事情。第一次入队是，使用线程池启动，之后就开启无线循环不断的读取任务，当1s内获取不到任务，再没有任务时则关闭线程，个人觉得这个实现不太好，如果这1s内有任务进来，也不能立刻运行，拜拜浪费了时间，如果使用notify的机制实现会好一些。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950final class BackgroundPoster implements Runnable, Poster &#123; private final PendingPostQueue queue; private final EventBus eventBus; private volatile boolean executorRunning; BackgroundPoster(EventBus eventBus) &#123; this.eventBus = eventBus; queue = new PendingPostQueue(); &#125; public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123; queue.enqueue(pendingPost); if (!executorRunning) &#123; executorRunning = true; eventBus.getExecutorService().execute(this); &#125; &#125; &#125; @Override public void run() &#123; try &#123; try &#123; while (true) &#123; PendingPost pendingPost = queue.poll(1000); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; executorRunning = false; return; &#125; &#125; &#125; eventBus.invokeSubscriber(pendingPost); &#125; &#125; catch (InterruptedException e) &#123; eventBus.getLogger().log(Level.WARNING, Thread.currentThread().getName() + &quot; was interruppted&quot;, e); &#125; &#125; finally &#123; executorRunning = false; &#125; &#125;&#125; AsyncPoster 这个主要是异步的，来一个执行一个 1234567891011121314151617181920212223242526class AsyncPoster implements Runnable, Poster &#123; private final PendingPostQueue queue; private final EventBus eventBus; AsyncPoster(EventBus eventBus) &#123; this.eventBus = eventBus; queue = new PendingPostQueue(); &#125;s public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); queue.enqueue(pendingPost); eventBus.getExecutorService().execute(this); &#125; @Override public void run() &#123; PendingPost pendingPost = queue.poll(); if(pendingPost == null) &#123; throw new IllegalStateException(&quot;No pending post available&quot;); &#125; eventBus.invokeSubscriber(pendingPost); &#125;&#125; 接下来就是重要的 SubscriberMethodFinder 函数， 12345678 class SubscriberMethodFinder &#123;&#125; SubscriberMethodFinder(List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes, boolean strictMethodVerification, boolean ignoreGeneratedIndex) &#123; this.subscriberInfoIndexes = subscriberInfoIndexes; this.strictMethodVerification = strictMethodVerification; this.ignoreGeneratedIndex = ignoreGeneratedIndex;&#125; 熟悉的register函数，首先获取到subscriber对象，一般我们在Activity里面，所以是Activity对象，然后调用subscriberMethodFinder.findSubscriberMethods(subscriberClass)，找到所有订阅的Methods，然后绑定订阅 1234567891011121314151617/** * Registers the given subscriber to receive events. Subscribers must call &#123;@link #unregister(Object)&#125; once they * are no longer interested in receiving events. * &lt;p/&gt; * Subscribers have event handling methods that must be annotated by &#123;@link Subscribe&#125;. * The &#123;@link Subscribe&#125; annotation also allows configuration like &#123;@link * ThreadMode&#125; and priority. */public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125;&#125; 找到某个类中，也就是注册的类中的所有的订阅方法，首先查看方法缓存中是否以及存在，存在则直接返回，不存在则使用反射或者Info去找，获取到所有方法后把它存入缓存，返回所有的方法列表。注意getMethods和getDeclaredMethods的区别，一个是能够获取包括父类多有的public方法，一个是获取本类所有的包括私有的方法， 12345678910111213141516171819List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125; if (ignoreGeneratedIndex) &#123; subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriberClass + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;); &#125; else &#123; METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125;&#125; 查找函数，首先prepareFindState，初始化 FindState，用于存放各种订阅相关的数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) &#123; FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; findUsingReflectionInSingleClass(findState); findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState);&#125;// private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; // 对于每一个方法，获取信息，首先 // 校验修饰符，过滤掉非 Public 的方法 // 以及 abstract，static，bridge or synthetic methods， for (Method method : methods) &#123; int modifiers = method.getModifiers(); if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; // 参数类型只能为一个 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); if (parameterTypes.length == 1) &#123; // 获取注解 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; // 参数类型 Class&lt;?&gt; eventType = parameterTypes[0]; if (findState.checkAdd(method, eventType)) &#123; // 注解的值 ThreadMode threadMode = subscribeAnnotation.threadMode(); // 添加到findState findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(&quot;@Subscribe method &quot; + methodName + &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName(); throw new EventBusException(methodName + &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;); &#125; &#125;&#125;// 初始化 FindStateprivate FindState prepareFindState() &#123; synchronized (FIND_STATE_POOL) &#123; for (int i = 0; i &lt; POOL_SIZE; i++) &#123; FindState state = FIND_STATE_POOL[i]; if (state != null) &#123; FIND_STATE_POOL[i] = null; return state; &#125; &#125; &#125; return new FindState();&#125;static class FindState &#123; final List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(); final Map&lt;Class, Object&gt; anyMethodByEventType = new HashMap&lt;&gt;(); final Map&lt;String, Class&gt; subscriberClassByMethodKey = new HashMap&lt;&gt;(); final StringBuilder methodKeyBuilder = new StringBuilder(128); Class&lt;?&gt; subscriberClass; Class&lt;?&gt; clazz; boolean skipSuperClasses; SubscriberInfo subscriberInfo; void initForSubscriber(Class&lt;?&gt; subscriberClass) &#123; this.subscriberClass = clazz = subscriberClass; skipSuperClasses = false; subscriberInfo = null; &#125; void recycle() &#123; subscriberMethods.clear(); anyMethodByEventType.clear(); subscriberClassByMethodKey.clear(); methodKeyBuilder.setLength(0); subscriberClass = null; clazz = null; skipSuperClasses = false; subscriberInfo = null; &#125; boolean checkAdd(Method method, Class&lt;?&gt; eventType) &#123; // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required. // Usually a subscriber doesn&apos;t have methods listening to the same event type. Object existing = anyMethodByEventType.put(eventType, method); if (existing == null) &#123; return true; &#125; else &#123; if (existing instanceof Method) &#123; if (!checkAddWithMethodSignature((Method) existing, eventType)) &#123; // Paranoia check throw new IllegalStateException(); &#125; // Put any non-Method object to &quot;consume&quot; the existing Method anyMethodByEventType.put(eventType, this); &#125; return checkAddWithMethodSignature(method, eventType); &#125; &#125; private boolean checkAddWithMethodSignature(Method method, Class&lt;?&gt; eventType) &#123; methodKeyBuilder.setLength(0); methodKeyBuilder.append(method.getName()); methodKeyBuilder.append(&apos;&gt;&apos;).append(eventType.getName()); String methodKey = methodKeyBuilder.toString(); Class&lt;?&gt; methodClass = method.getDeclaringClass(); Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass); if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) &#123; // Only add if not already found in a sub class return true; &#125; else &#123; // Revert the put, old class is further down the class hierarchy subscriberClassByMethodKey.put(methodKey, methodClassOld); return false; &#125; &#125; void moveToSuperclass() &#123; if (skipSuperClasses) &#123; clazz = null; &#125; else &#123; clazz = clazz.getSuperclass(); String clazzName = clazz.getName(); /** Skip system classes, this just degrades performance. */ if (clazzName.startsWith(&quot;java.&quot;) || clazzName.startsWith(&quot;javax.&quot;) || clazzName.startsWith(&quot;android.&quot;)) &#123; clazz = null; &#125; &#125; &#125;&#125; 有必要看一下，注解的定义 123456789101112131415161718@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)public @interface Subscribe &#123; ThreadMode threadMode() default ThreadMode.POSTING; /** * If true, delivers the most recent sticky event (posted with * &#123;@link EventBus#postSticky(Object)&#125;) to this subscriber (if event available). */ boolean sticky() default false; /** Subscriber priority to influence the order of event delivery. * Within the same delivery thread (&#123;@link ThreadMode&#125;), higher priority subscribers will receive events before * others with a lower priority. The default priority is 0. Note: the priority does *NOT* affect the order of * delivery among subscribers with different &#123;@link ThreadMode&#125;s! */ int priority() default 0;&#125; 然后就是 subscribe，对于每一个方法，执行 subscribe 函数，将这些方法添加到subscriptionsByEventType消息类型分组的订阅清单，typesBySubscriber消息类型列表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Must be called in synchronized blockprivate void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; Class&lt;?&gt; eventType = subscriberMethod.eventType; Subscription newSubscription = new Subscription(subscriber, subscriberMethod); CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); // 首次为空 if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot; + eventType); &#125; &#125; // 会根据优先级加入到订阅的列表中 int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; // eventType 就是我们自定义的MeesageEvent，用于传递消息的 subscribedEvents.add(eventType); if (subscriberMethod.sticky) &#123; if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125;&#125; Post 发送消息，首先从当前线程获取PostingThreadState，然后入队，再出队执行 12345678910111213141516171819202122/** Posts the given event to the event bus. */public void post(Object event) &#123; PostingThreadState postingState = currentPostingThreadState.get(); List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); if (!postingState.isPosting) &#123; postingState.isMainThread = isMainThread(); postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;); &#125; try &#123; while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125;&#125; eventInheritance 默认为true，允许事件继承，首先获取EventClass所有的父类和接口，并调用postSingleEventForEventType执行 1234567891011121314151617181920212223private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; if (eventInheritance) &#123; List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; logger.log(Level.FINE, &quot;No subscribers registered for event &quot; + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125; &#125;&#125; 获取所有的方法，包括父类和接口，加入到需要通知的事件类型 123456789101112131415161718192021222324252627/** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */private static List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass) &#123; synchronized (eventTypesCache) &#123; List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass); if (eventTypes == null) &#123; eventTypes = new ArrayList&lt;&gt;(); Class&lt;?&gt; clazz = eventClass; while (clazz != null) &#123; eventTypes.add(clazz); addInterfaces(eventTypes, clazz.getInterfaces()); clazz = clazz.getSuperclass(); &#125; eventTypesCache.put(eventClass, eventTypes); &#125; return eventTypes; &#125;&#125;/** Recurses through super interfaces. */static void addInterfaces(List&lt;Class&lt;?&gt;&gt; eventTypes, Class&lt;?&gt;[] interfaces) &#123; for (Class&lt;?&gt; interfaceClass : interfaces) &#123; if (!eventTypes.contains(interfaceClass)) &#123; eventTypes.add(interfaceClass); addInterfaces(eventTypes, interfaceClass.getInterfaces()); &#125; &#125;&#125; 首先通过subscriptionsByEventType.get(eventClass)获取能够接受这个数据类型的所有方法，然后根据每个方法的参数类型进行调用 1234567891011121314151617181920212223242526private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125; &#125; return true; &#125; return false;&#125; POSTING模式直接调用，与当前线程一致 MAIN模式，在主线程调用，则需要获取当前线程是否是主线程，若不是则入主线程队列 MAIN_ORDERED模式，如果mainThreadPoster不为空，则入队，否则直接调用 BACKGROUND模式，若在子线程，则直接调用，否则如后台线程队列 ASYNC模式，直接如异步队列 12345678910111213141516171819202122232425262728293031323334private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case MAIN_ORDERED: if (mainThreadPoster != null) &#123; mainThreadPoster.enqueue(subscription, event); &#125; else &#123; // temporary: technically not correct as poster not decoupled from subscriber invokeSubscriber(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode); &#125;&#125; 直接调用，在post的执行的那个线程，比如说你在子线程调用post，那么isMainThread就是false，则会到mainThreadPoster.enqueue()里面，让主线程去调用，否则直接调用 123456789void invokeSubscriber(Subscription subscription, Object event) &#123; try &#123; subscription.subscriberMethod.method.invoke(subscription.subscriber, event); &#125; catch (InvocationTargetException e) &#123; handleSubscriberException(subscription, event, e.getCause()); &#125; catch (IllegalAccessException e) &#123; throw new IllegalStateException(&quot;Unexpected exception&quot;, e); &#125;&#125; 注销，首先获取需要注销的事件类型，然后针对每一个类型，取消订阅者，最后移除 12345678910111213141516171819202122232425262728/** Unregisters the given subscriber from all event classes. */public synchronized void unregister(Object subscriber) &#123; List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); if (subscribedTypes != null) &#123; for (Class&lt;?&gt; eventType : subscribedTypes) &#123; unsubscribeByEventType(subscriber, eventType); &#125; typesBySubscriber.remove(subscriber); &#125; else &#123; logger.log(Level.WARNING, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass()); &#125;&#125;/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123; List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions != null) &#123; int size = subscriptions.size(); for (int i = 0; i &lt; size; i++) &#123; Subscription subscription = subscriptions.get(i); if (subscription.subscriber == subscriber) &#123; subscription.active = false; subscriptions.remove(i); i--; size--; &#125; &#125; &#125;&#125; 在反射找方法的时候，如果使用索引加速的话，调用了这个方法 12345678910111213141516171819202122232425262728293031323334353637private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; findUsingReflectionInSingleClass(findState); &#125; findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState);&#125;// 获取 Subscriber的信息private SubscriberInfo getSubscriberInfo(FindState findState) &#123; if (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) &#123; SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo(); if (findState.clazz == superclassInfo.getSubscriberClass()) &#123; return superclassInfo; &#125; &#125; if (subscriberInfoIndexes != null) &#123; for (SubscriberInfoIndex index : subscriberInfoIndexes) &#123; SubscriberInfo info = index.getSubscriberInfo(findState.clazz); if (info != null) &#123; return info; &#125; &#125; &#125; return null;&#125; 大概分析的差不多，但感觉还是一头雾水，对一些细节还云里雾里，先写一个小结吧 小结 使用了注解，反射，Handler，线程池，事件池，而且里面有很多优秀的设计，单例，建造者，工厂，要多读多练才能体味里面的精妙 欢迎讨论","categories":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/tags/Android/"}]},{"title":"Android HandlerThread 源码解析","slug":"Android/HandlerThread","date":"2018-08-17T15:51:00.000Z","updated":"2019-09-02T12:18:44.107Z","comments":true,"path":"2018/08/17/Android/HandlerThread/","link":"","permalink":"https://wzes.github.io/2018/08/17/Android/HandlerThread/","excerpt":"","text":"前言 这个东西看着很高端的感觉，刚开始没明白这是用来干啥用的，他的源码也很简单，简单到都想不出来他的场景，后面看到以博客毛瑟顿开，HandlerThread的特点，大概就是说，它用子线程的Looper，使我们的消息在子线程中处理，通常我们都是绑定了主线程的 MessageQueue，一定程度上加大了主线程消息处理的负担。在子线程中处理消息，自然也不能处理消息，可以处理一些后台的任务，但是他是串行处理，所以使用时要注意了。 HandlerThread 是什么东西？ 先看名字，有 Handler，又有 Thread，聪明的你一想就知道了，他是一个 Thread，既然是Thread，那就有 Thread 的特性，比如你可以 start 启动线程。回到正题，其实他就是一个帮你初始化了一个子线程 Looper 的 Thread，那他的使用就是获取这个Looper，绑定到Handler，就可以使处理消息的代码执行在子线程。 前世今生 继承自Thread，使用时可以调用 .start()，注意 run 和 start 的区别 1public class HandlerThread extends Thread &#123;&#125; 源码分析 属性 mPriority 是线程的优先级，默认为Process.THREAD_PRIORITY_DEFAULT，注意，安卓的线程优先级比 Java 的影响要大，虽然 JVM 是抢占式地优先级调度，但其实并不能保证这个语义，开发者不应该完全依赖这个。 mTid 是线程 id mLooper Looper对象 Handler 对象 123456789int mPriority;int mTid = -1;Looper mLooper;private @Nullable Handler mHandler;public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT;&#125; 函数 run 函数很简单，先 Looper.prepare()，给当前线程的初始化一个 Looper 对象，需要注意的是，这个方法不能在当前线程多次调用，会抛出 new RuntimeException(&quot;Only one Looper may be created per thread&quot;); 异常，不明白的可以去看这一篇Handler 源码大白话。有一个 onLooperPrepared() 方法你可以去重写，主要是 Looper.loop() 调用前的一些准备操作 1234567891011121314151617181920/** * Call back method that can be explicitly overridden if needed to execute some * setup before Looper loops. */protected void onLooperPrepared() &#123;&#125;@Overridepublic void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1;&#125; 获取Looper，代码简单易懂，需要注意，如果线程还活着，如果 looper 为空，那么则阻塞等待初始化，这里使用了 synchronized 以及 wait notify 机制，有时间得好好研究一下这个机制，总感觉掌握的还不够 12345678910111213141516171819202122/** * This method returns the Looper associated with this thread. If this thread not been started * or for any reason isAlive() returns false, this method will return null. If this thread * has been started, this method will block until the looper has been initialized. * @return The looper. */public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper;&#125; 关闭Looper，或者使用quitSafely() 这是一个安全的方法 1234567891011121314151617public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false;&#125;public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quitSafely(); return true; &#125; return false;&#125; 一个简单的例子（纯手写,不保证对） 123456789101112131415161718192021@MainThreadprivate HandlerThread mHT = new HandlerThread(&quot;WorkerHandler&quot;);private Handler mH;@Overridepublic void onCreate(Bundle savedInstanceState) &#123; mHT.start(); mH = new Handler(mHT.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; Log.v(&quot;mhT&quot;, &quot;I received the msg: &quot; + msg + &quot; from&quot; + Thread.currentThread()); &#125; &#125;;&#125;@Overridepublic void onDestroy() &#123; mHT.quitSafely();&#125; 小结 如果我们的消息不需要更新UI，可以考虑使用这种子线程消息处理模式。当然，你也可以传入主线程的 Looper，但这违背了 HandlerThread 初衷，即在一个独立的线程中处理消息～ 欢迎讨论，如果有了新的理解，会不断更新～","categories":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/tags/Android/"}]},{"title":"Android Handler 源码解析","slug":"Android/Handler","date":"2018-08-15T12:11:00.000Z","updated":"2019-09-02T12:18:28.019Z","comments":true,"path":"2018/08/15/Android/Handler/","link":"","permalink":"https://wzes.github.io/2018/08/15/Android/Handler/","excerpt":"","text":"前言 我相信，用过Android的人基本都会使用Handler，或者多多少少会听到这个东西，在安卓里面，这东西太重要了，如果你还不会基本用法，那应该是需要反省一下。当然，用过它的人也不必沾沾自喜，我们真的很了解Handler吗，还是说只会使用？你有看过他的每一行代码？仔细思考过吗？对于我来说，确实没有，所以我带着问题，想全面了解 Handler。 是什么东西？ handler，英文有（信息）处理机的意思，这里我们暂且可以认为他有处理消息的功能，当然，这也是他最主要的功能，他还有其他的功能，我们可以根据源码一谈究竟。用最通俗的总结一下，他是用来接收从各个线程发过来的消息，然后集中处理的东西。你可以在主线程（MainThread）处理消息，在子线程（WorkerThread）发送消息，当然，这个关系也可以转换，下面我手写一小段代码展示一下（只为了演示，实际中不会这么写） 123456789// 写在Activity中作为实例变量private Handler mHandler = new Handler() &#123; @Override public void handleMesssage(Message msg) &#123; ui.setText(&quot;msg received&quot;); &#125; &#125;// 启动一个线程发一个消息new Thread(() -&gt; mHandler.sendEmptyMessage()); 上面简单的代码演示了如何从一个子线程发送消息到主线程，然后更新UI，至于Android不能再主线程更新UI，我想这个道理大家多少都知道原因，以后有机会再好好分析。 前世今生 很干净，只有自己 1public class Handler &#123;&#125; 源码分析 属性 这里个都是类变量，MAIN_THREAD_HANDLER 顾名思义，主线程的 Handler 12345678/* * Set this flag to true to detect anonymous, local or member classes * that extend this Handler class and that are not static. These kind * of classes can potentially create leaks. */private static final boolean FIND_POTENTIAL_LEAKS = false;private static final String TAG = &quot;Handler&quot;;private static Handler MAIN_THREAD_HANDLER = null; 接下来这几个很重要，一个是Looper对象，MessageQueue，Callback，mAsynchronous，还有IMessager，集体有什么用，后面用到了再慢慢说 12345final Looper mLooper;final MessageQueue mQueue;final Callback mCallback;final boolean mAsynchronous;IMessenger mMessenger; 这个东西大家用的可能不多，是一个内部接口，主要是说你可以不用写一个Handler子类就可以做到消息处理的功能。比如说上面的代码，我就是实现了自己的子类才能做到消息处理，你也可以实现这个Callback，然后 new Handler（Callback）就可以了。 1234567891011/** * Callback interface you can use when instantiating a Handler to avoid * having to implement your own subclass of Handler. */public interface Callback &#123; /** * @param msg A &#123;@link android.os.Message Message&#125; object * @return True if no further handling is desired */ public boolean handleMessage(Message msg);&#125; 函数 构造函数 4个参数，都有默认值，分别是 Looper.myLooper() 获取到的，如果你在主线程初始化，那默认就是MainLooper，否则就是其他线程自己的Looper，这里有一个要注意的地方，就是说，当前线程必须执行过 Looper.prepare()，一般你在子线程都需要先执行这个方法，但在主线程是不需要的，因为早在应用启动的时候，ActivityThread 的 main 方法以及帮你执行了，这是我们程序比较早的一个入口。然后绑定MessageQueue，默认是Looper的Queue，还有Callback，默认为空，还有异步mAsynchronous ，默认为false。 12345678910111213141516171819202122232425public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125;/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */// 静态方法获取Looper，使用到了ThreadLocal// 这个强大的变量，从当前线程取值，// 前提是你之前有放入过东西，不然怎么取public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125;// 静态方法，往ThreadLocal存在Looper实例private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 然后是我们通常需要重写的函数，里面是消息处理的逻辑 12345/** * Subclasses must implement this to receive messages. */public void handleMessage(Message msg) &#123;&#125; 这个函数原则上你也可以重写，但是不推荐，我们可以看到，它首先判断msg是否带有callback，如果不为空，则执行处理逻辑，否则判断mCallback是否为空，这两个Callback室友区别的，后面这个就是上面那个接口的实现类，而msg的callback是背后自己封装的，稍后我们在看这个细节。如果没有传进去callback，那么则调用handleMessage（），就到了我们重写的那个地方了，这些是在主线程执行的。 123456789101112131415/** * Handle system messages here. */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 发送消息的函数，默认是直接发送，注意，虽然是 EmptyMessage，但还是在内部封装了一个 Message，以后获取Message，不要再傻傻的new Message了，通过Message.obtain 或者 Handler.obtain。这一步可以在子线程调用 12345678910111213141516171819202122232425/** * Sends a Message containing only the what value. * * @return Returns true if the message was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. */public final boolean sendEmptyMessage(int what) &#123; return sendEmptyMessageDelayed(what, 0);&#125;public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis);&#125;// 最后还是调用了atTimepublic final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; 获取MessageQueue，将Message入队，注意，这里msg.target = this，将handler绑定到message上，到时候就能找到消息对应的handler实例了，强调一下，一个线程对应一个queue，一个queue可以有多个handler，所以有需要区分多个handler，就是这里设置target，绑定实例，然后入队，注意，异步也是在这里配置 1234567891011121314151617public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; MessageQueue 的源码，使用synchronised保证顺序性，至于MessageQueue的种种细节，下次在分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don&apos;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; // poll 消息 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; 获取消息，调用MessageQueue的next，然后看到了msg.target.dispatchMessage(msg)这个是在主线程的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; // 获取 Queue 通过 MessageQueue final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; // 获取消息，调用MessageQueue的next Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); final long end; try &#123; msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (slowDispatchThresholdMs &gt; 0) &#123; final long time = end - start; if (time &gt; slowDispatchThresholdMs) &#123; Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot; + Thread.currentThread().getName() + &quot;, h=&quot; + msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what); &#125; &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&apos;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 当然，handler还有其他用法，比如post，但需要注意，这个虽然提交了一个Runnable，但跟随者消息链，你会发现，它的执行是直接在主线程调用run方法，也就是说运行在主线程的，所以使用时候需要注意了，别用错了 1234567891011121314151617public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;// callback message 的callback，与之前Callback有很大的区别private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; 小结 使用方法，继承Handler，或者实现Callback，又或者post 各部分运行在什么地方，主线程和子线程要区分 MessageQueue，Looper，Handler 之间的关系，在什么地方初始化 欢迎讨论","categories":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/tags/Android/"}]},{"title":"JVM-Class-字节码学习笔记","slug":"JVM/JVM Class 字节码学习笔记","date":"2018-08-15T06:47:00.000Z","updated":"2019-09-02T12:22:58.160Z","comments":true,"path":"2018/08/15/JVM/JVM Class 字节码学习笔记/","link":"","permalink":"https://wzes.github.io/2018/08/15/JVM/JVM Class 字节码学习笔记/","excerpt":"","text":"目标使用javap直接阅读字节码 魔数 开头前4个字节为 CAFE BABE，（两个十六进制字符为一个字节），后四个字节为Class 文件的版本号，先次版本号，后主版本号，能向下兼容，不能向后兼容， 之后的两个字节为常量池常量的个数，从1开始计数，在之后就是每一个常量的信息，最多64 k个 常见的有 14 个 Class：tag（u1）+ name_index（u2） Utf8：tag（u1）+ length（u2）+ bytes（length）方法名，字段名，加上包名不能超过64k 基础数据类型，tag（u1）+ bytes（？）值 访问标志，两个字节，为标志位，用于表示类的信息，比如是否是public，final，super，interface，abstract，enum，annotation 类索引，父类索引，接口索引 字段表，访问标志，public protected private 三选一，final volatile 不能同时选择，接口中public static final 是必须的。access_flags, name_index（简单名称）,descriptor_index（全限定名）,attributes_count,attributes 方法表集合access_flags （strictfp，native，synchronized 属性表集合 InnerClass LineNumberTable 源码与字节码对应 LocalVariableTable StackMapTable Signature SourceFile Synthetic 每个属性都引用常量池里来表示 Code 属性，方法体的信息存储在这，code_length 长度固定","categories":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"Java8 LinkedBlockingQueue 源码解析","slug":"Java/Java8 LinkedBlockingQueue 源码解析","date":"2018-08-14T14:48:00.000Z","updated":"2019-09-02T12:21:04.071Z","comments":true,"path":"2018/08/14/Java/Java8 LinkedBlockingQueue 源码解析/","link":"","permalink":"https://wzes.github.io/2018/08/14/Java/Java8 LinkedBlockingQueue 源码解析/","excerpt":"","text":"LinkedBlockingQueue 链表阻塞队列 链表阻塞队列，顾名思义，也就是一个基于队列的阻塞式的链表实现，里面的代码写的很漂亮，生产者消费者模式在这个类中用的酣畅淋漓，其作者是大名鼎鼎的 Doug Lea，掌握这个类是比较重要的。里面很多实现基于锁，可以好好学习一下。 前世今生 继承自AbstractQueue 实现了 BlockingQueue，那我们就来看一下有哪些接口，这些是基础，要牢记 主要就是take（拿）和put（放），其余的offer，poll，add 有更高级的用法，稍后再说 使用场景 我查了一些资料，感觉和 MQ 有点联系，就是说我们可以使用这个东西进行解耦，或者负载均衡，比如说，有很多任务需要提交，我们可以把任务提交给 Queue，消费者负责处理消息，这个可以根据消费者的能力决定任务的执行效率，不会一下字任务过来而导致崩溃，讲道理，可以适合多生产者，多消费者模式，如果有这个，我们可以很好的进行解耦，负载均衡 实现原理大白话 属性 绝对的重头戏，上来就一堆干活，可以去补补 ReentrantLock 和 Condition 的知识，看一下，拿和取都用了一把锁，takeLock 对应的是 notEmpty Condition，putLock 对应的是 notFull Condition， 大致的意思就是，当你拿的时候，如果发现队列为空，则需要等待，当你放的时候，如果发现队列满了，也需要等待，这里的等待靠的就是notEmpty 和 notFull 的 await 方法，当你往队列添加元素成功后，则notEmpty.signal（） 提醒消费者可以拿东西了，反之，当你取完一个东西之后，则 notFull.singal（）提醒生产者可以放东西了。 1234567891011/** Lock held by take, poll, etc */private final ReentrantLock takeLock = new ReentrantLock();/** Wait queue for waiting takes */private final Condition notEmpty = takeLock.newCondition();/** Lock held by put, offer, etc */private final ReentrantLock putLock = new ReentrantLock();/** Wait queue for waiting puts */private final Condition notFull = putLock.newCondition(); 还有一些其他的参数，容量以及对头队尾，默认容量为 Interger.MAX__VALUE，还有原子类的AtomicInterger 用于计数，保证原子性 1234567891011121314151617/** The capacity bound, or Integer.MAX_VALUE if none */private final int capacity;/** Current number of elements */private final AtomicInteger count = new AtomicInteger();/** * Head of linked list. * Invariant: head.item == null */transient Node&lt;E&gt; head;/** * Tail of linked list. * Invariant: last.next == null */private transient Node&lt;E&gt; last; 函数 构造函数，head 和 tail 设置为空的节点对象，稍后在分析作用 12345public LinkedBlockingQueue(int capacity) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.capacity = capacity; last = head = new Node&lt;E&gt;(null);&#125; put 函数，// 首先获取 putLock 的锁，保证putLock的线程安全性 12345678910111213141516171819202122232425262728293031323334353637383940public void put(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); // Note: convention in all put/take/etc is to preset local var // holding count negative to indicate failure unless set. int c = -1; // 构造一个新的节点 Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; // 首先获取 putLock 的锁，保证putLock的线程安全性 putLock.lockInterruptibly(); try &#123; /* * Note that count is used in wait guard even though it is * not protected by lock. This works because count can * only decrease at this point (all other puts are shut * out by lock), and we (or some other waiting put) are * signalled if it ever changes from capacity. Similarly * for all other uses of count in other wait guards. */ // 如果队列已满，则等待消费者调用 notFull.signal（） while (count.get() == capacity) &#123; notFull.await(); &#125; // 入队 enqueue(node); // 原子加1 c = count.getAndIncrement(); // 如果此时队列没有满，调用 signal 更新 count if (c + 1 &lt; capacity) notFull.signal(); &#125; finally &#123; // 释放锁 putLock.unlock(); &#125; // 如果 c 为 0；这里的 c 为之前的值 // 也就是说，现在已经加1了，可以提示生产者 if (c == 0) signalNotEmpty();&#125; 入队，很简单，写的很巧妙，学习一下 12345private void enqueue(Node&lt;E&gt; node) &#123; // assert putLock.isHeldByCurrentThread(); // assert last.next == null; last = last.next = node;&#125; 出队，手动GC 1234567891011private E dequeue() &#123; // assert takeLock.isHeldByCurrentThread(); // assert head.item == null; Node&lt;E&gt; h = head; Node&lt;E&gt; first = h.next; h.next = h; // help GC head = first; E x = first.item; first.item = null; return x; &#125; 获取 takeLock，通知消费者可以消费了 123456789private void signalNotEmpty() &#123; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125;&#125; 顺便看一下，通知生产者可以放入队列了 123456789private void signalNotFull() &#123; final ReentrantLock putLock = this.putLock; putLock.lock(); try &#123; notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125;&#125; 拿数据，首先还是要获取拿的锁，如果count == 0 ，那么则说明没有数据，需要阻塞等待，想象一下，这时候又想放入数据，那么将阻塞在takeLock里面，知道生产者调用了signal，执行出队。 注意一个问题，由于多线程的不定性，每次c &gt; 1时，都需要再次signal，由于，多个消费者到会阻塞到await，而不是外面的 lockInterruptibly，所以每次都需要 signal，更新 count 的状态 123456789101112131415161718192021222324public E take() throws InterruptedException &#123; E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try &#123; // 阻塞，请注意，多个消费者都会阻塞在这里 while (count.get() == 0) &#123; notEmpty.await(); &#125; x = dequeue(); // 注意，获取到更新前的值 c = count.getAndDecrement()； if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125; // 如果之前队列满了，那么现在不会满了，提示生产者可以生产了 if (c == capacity) signalNotFull(); return x;&#125; 这个方法如果没有数据直接返回空 12345678910111213141516171819202122public E poll() &#123; final AtomicInteger count = this.count; if (count.get() == 0) return null; E x = null; int c = -1; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; if (count.get() &gt; 0) &#123; x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) signalNotFull(); return x; &#125; 同样的，这个方法利用了condition 的延迟性，可等待一定时间，如果超过这个时间还没有结果则返回null 123456789101112131415161718192021222324public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123; E x = null; int c = -1; long nanos = unit.toNanos(timeout); final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try &#123; while (count.get() == 0) &#123; if (nanos &lt;= 0) return null; nanos = notEmpty.awaitNanos(nanos); &#125; x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) signalNotFull(); return x; &#125; 放入数据，同样，如果等待一定时间还不能放入，那么将抛弃 1234567891011121314151617181920212223242526 public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); long nanos = unit.toNanos(timeout); int c = -1; final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try &#123; while (count.get() == capacity) &#123; if (nanos &lt;= 0) return false; nanos = notFull.awaitNanos(nanos); &#125; enqueue(new Node&lt;E&gt;(e)); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) signalNotEmpty(); return true;&#125; 为了让大家更加明白 ReentrantLock，我这里给出一个例子供大家学习 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;/** * @author Create by xuantang * @date on 8/22/18 */public class ReentrantLockDemo &#123; private static ReentrantLock mLock = new ReentrantLock(); private static Condition mCondition = mLock.newCondition(); public static void main(String[] args) &#123; new WaitThread(&quot;waiter one&quot;).start(); new WaitThread(&quot;waiter two&quot;).start(); new WaitThread(&quot;waiter three&quot;).start(); new NotifyThread(&quot;notify one&quot;).start(); &#125; static class WaitThread extends Thread &#123; WaitThread(String name) &#123; super(name); &#125; @Override public void run() &#123; try &#123; mLock.lockInterruptibly(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; System.out.println(this.getName() + &quot; Waiting......&quot;); mCondition.await(); System.out.println(this.getName() + &quot; Finished.....&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; mLock.unlock(); &#125; &#125; &#125; static class NotifyThread extends Thread &#123; NotifyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; try &#123; mLock.lockInterruptibly(); mCondition.signal(); System.out.println(this.getName() + &quot; Notify.....&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; mLock.unlock(); &#125; &#125; &#125;&#125; 输入结果，只能唤醒一个，当然你可以使用 signalAll() 唤醒所有的 12345waiter one Waiting......waiter two Waiting......waiter three Waiting......notify one Notify.....waiter one Finished..... 小结 我们看到了可重入锁，Condition的高级用法利用，以及生产者消费者模型，通过了解源码，我们更加深入的学习到了这个模型的用法以及实现。","categories":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"Sqlite 锁学习","slug":"SQLite/Sqlite 锁学习","date":"2018-08-13T06:28:00.000Z","updated":"2019-09-02T12:23:14.556Z","comments":true,"path":"2018/08/13/SQLite/Sqlite 锁学习/","link":"","permalink":"https://wzes.github.io/2018/08/13/SQLite/Sqlite 锁学习/","excerpt":"","text":"锁类型 UNLOCK 无锁 文件没有持有任何锁，即当前数据库不存在任何读或写的操作。其它的进程可以在该数据库上执行任意的读写操作。此状态为缺省状态 SHARED 共享锁 在此状态下，该数据库可以被读取但是不能被写入。在同一时刻可以有任意数量的进程在同一个数据库上持有共享锁，因此读操作是并发的。换句话说，只要有一个或多个共享锁处于活动状态，就不再允许有数据库文件写入的操作存在。 RESERVED 保留锁 假如某个进程在将来的某一时刻打算在当前的数据库中执行写操作，然而此时只是从数据库中读取数据，那么我们就可以简单的理解为数据库文件此时已经拥有了保留锁。当保留锁处于活动状态时，该数据库只能有一个或多个共享锁存在，即同一数据库的同一时刻只能存在一个保留锁和多个共享锁. 需要说明的是update操作 实际上是一个读操作加一个写操作 PENDING 未决锁 PENDING锁的意思是说，某个进程正打算在该数据库上执行写操作，然而此时该数据库中却存在很多共享锁(读操作)，那么该写操作就必须处于等待状态，即等待所有共享锁消失为止，与此同时，新的读操作将不再被允许，以防止写锁饥饿的现象发生。在此等待期间，该数据库文件的锁状态为PENDING，在等到所有共享锁消失以后，PENDING锁状态的数据库文件将在获取排他锁之后进入EXCLUSIVE状态。 EXCLUSIVE 排它锁 在执行写操作之前，该进程必须先获取该数据库的排他锁。然而一旦拥有了排他锁，任何其它锁类型都不能与之共存。因此，为了最大化并发效率，SQLite 将会最小化排他锁被持有的时间总量。","categories":[{"name":"SQLite","slug":"SQLite","permalink":"https://wzes.github.io/categories/SQLite/"}],"tags":[{"name":"SQLite","slug":"SQLite","permalink":"https://wzes.github.io/tags/SQLite/"}]},{"title":"Android AsyncTask 源码解析","slug":"Android/AsyncTask","date":"2018-08-12T09:12:00.000Z","updated":"2019-09-02T12:17:30.118Z","comments":true,"path":"2018/08/12/Android/AsyncTask/","link":"","permalink":"https://wzes.github.io/2018/08/12/Android/AsyncTask/","excerpt":"","text":"是什么东西？ 顾名思义，异步任务，就是说我们可以让我们异步执行任务，不过通常使用它是为了异步执行，主线程更新UI，我们都知道，Android 的UI更新操作，都会检查是否是主线程，如果不是的话就会报出异常，这一步是在ViewRootImpl里面做的，这里就不多说了。在使用的时候，我们只需要将后台处理的代码写在doInBackground，更新UI的工作写在onPostExecute就行了，就可以轻松实现一个线程切换，更新UI的效果。那这里你可能会问。为什么不用Handler，我也许会告诉你，使用 AsyncTask 有很多好处，待会会慢慢告诉你，你也可以根据源码，一探究竟。 前世今生 没有继承自任何东西，Object 除外，使用了模板定义，Params 代表你要传的参数类型，Progress 代表更新数据类型，Result 是任务执行玩返回数据类型。 1public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123;&#125; 使用场景 只要需要开启子线程的都可以使用它。在项目中，随便 new Thread 并不是一个好习惯，滥用不说，很有可能造成内存泄露 实现原理大白话 有两个东西很关键，一个是线程池，一个是 Handler，线程池负责执行任务， Handler 负责通知，说道这，聪明的你大概猜到了实现方式，但这并不够，我们需要细细的品味这个类是如何写成的。 源码解析 属性 通过使用 Runtime 对象获取可用的cpu 个数，在创建线程池时创建合适的线程数量，线程池的参数主要是核心线程数，这里最小值2， 最大值4，当处理器个数为4时，创建3个核心线程数，最大线程数为 cpu个数的两倍 + 1，关于核心线程数，最大线程数，大家可自行去了解作用，以后创建线程池，大家可要记住了，以这样创建线程池数是比较合理的。KeepAliveTime 是线程存活时间，超过这个时间的线程要被回收，至于哪一些线程，待会再说 1234567private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();// We want at least 2 threads and at most 4 threads in the core pool,// preferring to have 1 less than the CPU count to avoid saturating// the CPU with background workprivate static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE_SECONDS = 30; 静态线程工厂，在类加载是就会被创建，里面使用了AtomicInteger 用来计数。使用了LinkedBlockingQueue作为任务队列 123456789101112131415private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement()); &#125;&#125;;private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);/** * An &#123;@link Executor&#125; that can be used to execute tasks in parallel. */public static final Executor THREAD_POOL_EXECUTOR; 使用静态代码块初始化线程池，参数为以上分析的数据，注意，allowCoreThreadTimeOut 设置为true，意思是允许核心线程数被回收，默认是不会被回收的 1234567static &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor;&#125; 还有一个重头戏，单任务执行器，默认不是用上面的线程池执行任务，而是使用序列执行器执行任务，意识就是，同一时刻只能执行一个任务，注意这些都是静态的，也就是说，一个进程，不管你新建了多少个 Task对象，他也只能单个任务执行，这样就很好的管理了资源，那他是如何做到单任务执行的呢，实现方式可以说是既巧妙又无语，且看注释 1234567891011121314151617181920212223242526272829303132public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static class SerialExecutor implements Executor &#123; // 保存任务 final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; // 新任务进来，不执行，而是使用匿名内部类创建一个Task加到任务队列里， // 当这个执行完的时候，才会去调用下一个任务，就做到了单任务执行。 mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); // 默认先 if (mActive == null) &#123; scheduleNext(); &#125; &#125; // 这里是真正去执行的 // 注意，使用到了 synchronized 的可重入特性！ protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; 一些静态的变量基本看完了，下面来看一下构造函数，有点长 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. * * @hide */public AsyncTask(@Nullable Looper callbackLooper) &#123; // 首先获取 Handler 对象，这里有主线程 Handler 和子线程Handler 之分 mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); // 异步执行的，实现了callable接口 mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; // 为了防止多次多次调用实例 mTaskInvoked.set(true); Result result = null; try &#123; // 设置进程的优先级 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // noinspection unchecked // 在这里执行doInBackground函数， // 这是我们需要重写的 result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; // 执行完，这里还是在子线程 postResult(result); &#125; return result; &#125; &#125;; // FutureTask 对象，封装Callable 对象 mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; // 结束时调用 @Override protected void done() &#123; try &#123; // 如果没有被调用的话，通过get获取结果 postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; 执行完以后，使用Handler 进行通知，注意，这里将结果装入Message对象中，直接发送。一个小技巧，我们在发送消息是尽可能使用 obtainMessage 获取Message对象要比new一个好得多。 12345678// 返回结果，使用handlerprivate Result postResult(Result result) &#123; @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 那执行入口呢? MainThread 代表主线程执行 123456789101112131415161718192021222324252627282930@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; // 先检查是否合法 if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; // 执行 exec.execute(mFuture); return this;&#125; 一些我们可能需要实现的函数 12345678910111213141516171819// 我们将后台逻辑写在这里@WorkerThreadprotected abstract Result doInBackground(Params... params);@MainThreadprotected void onPreExecute() &#123;&#125;// 执行完回调@MainThreadprotected void onPostExecute(Result result) &#123;&#125;// 如果有进度条更新@MainThreadprotected void onProgressUpdate(Progress... values) &#123;&#125;@MainThreadprotected void onCancelled() &#123;&#125; 如何更新进度条？只需要在 doInBackground 中调用即可，将参数传入，使用handler机制 1234567@WorkerThreadprotected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125; Handler 处理消息的地方，静态类 1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 当然，你也可以取消任务，不过只能取消还没执行的任务，底层是调用 thread.interrupt 方法，简单粗暴，关于他的使用，可以写一堆东西来说，这里暂且不展开说 1234public final boolean cancel(boolean mayInterruptIfRunning) &#123; mCancelled.set(true); return mFuture.cancel(mayInterruptIfRunning);&#125; 当然，如果不要于UI交互，你也可以使用这个执行后台逻辑，直接调用executeOnExecutor，使用静态的execute提交，这里是单任务的 123public static void execute(Runnable runnable) &#123; sDefaultExecutor.execute(runnable); &#125; 当然，也可以多任务一起执行，调用executeOnExecutor时指定内部的线程池即可AsyncTask.THREAD_POOL_EXECUTOR 总结 我们了解这AsyncTask这个类，大致知道了他是怎么实现了，如果要进一步了解的话，线程池，锁这些东西必不可少的～ 如有错误，欢迎讨论","categories":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/tags/Android/"}]},{"title":"Java8 PriorityQueue 源码解析","slug":"Java/Java8 PriorityQueue 源码解析","date":"2018-08-10T13:23:00.000Z","updated":"2019-09-02T12:21:11.225Z","comments":true,"path":"2018/08/10/Java/Java8 PriorityQueue 源码解析/","link":"","permalink":"https://wzes.github.io/2018/08/10/Java/Java8 PriorityQueue 源码解析/","excerpt":"","text":"PriorityQueue 优先级队列 前世今生 extends AbstractQueue AbstractQueue extends AbstractCollection implements Queue 实现原理大白话 内部使用你所熟悉的数据结构最堆来实现，每次都是取堆顶的元素。至于堆怎么实现，其实很简单，就一个数组而已，这里就不讨论怎么实现堆了。默认是根据传入的对象进行比较建立初始堆的。比如说 String 实现了 Comparable 接口，里面就是根据这个进行排序建立初始堆的。 主要的构造函数 123// 可以使用外排序 Comparator 来构建你自己的堆，默认为空// initialCapacity 为初始堆大小，一般来说，为了避免扩容，或者空间浪费，我们要选择合适的值，默认值为 DEFAULT_INITIAL_CAPACITY = 11public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) 常用的方法 添加元素 123456789101112131415161718192021public boolean add(E e) &#123; return offer(e); &#125;// 调用的是offerpublic boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); // 几乎所有的集合类都有这个，顾名思义，主要是记录修改次数，实际上是为了防止你在遍历的时候更改了数据，造成不一致，会抛出ConcurrentModificationException 异常，注意，这与并发没有多大联系 modCount++; int i = size; // 检查是否需要扩容，queue就是真实数据 if (i &gt;= queue.length) grow(i + 1); size = i + 1; if (i == 0) queue[0] = e; else // 使用经典的 siftUp 上移最后添加的元素， 保证我们的堆还是有序的 siftUp(i, e); return true; &#125; 删除元素 12345678910111213// 同样使用 siftDown，首先将最后一个元素移到堆顶，再调整堆即可public E poll() &#123; if (size == 0) return null; int s = --size; modCount++; E result = (E) queue[0]; E x = (E) queue[s]; queue[s] = null; if (s != 0) siftDown(0, x); return result; &#125; 获取堆顶元素 12345// 直接数组返回// 也可以使用 element()，是 abstractQueue 的方法，调用的也是 peek() 再一次感受到多态对象的强大public E peek() &#123; return (size == 0) ? null : (E) queue[0]; &#125; 获取后一位置的元素 123456789// 因为使用的是最堆的数据结构，所以只能遍历，效率较低private int indexOf(Object o) &#123; if (o != null) &#123; for (int i = 0; i &lt; size; i++) if (o.equals(queue[i])) return i; &#125; return -1; &#125; 关于siftUp 1234567// 如果没有外排序，则使用内排序private void siftUp(int k, E x) &#123; if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x); &#125; 简单看一个函数，复习一下堆 123456789101112131415private void siftUpComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x; while (k &gt; 0) &#123; // 一如既往使用位运算提高效率 int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; // 如果父元素小的话，说明最小堆已经都建好了， // 否则交换继续调整 if (key.compareTo((E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = key; &#125; 你可能遇到的坑 如果你中途改变了数据，有关排序的字段，最小堆是不会自动重新构建，那么，这个优先级队列就会失效！！！！！！举个例子，你把一堆学生按身高放入优先级队列，突然，有几个学生的身高改变了，这个最小堆是不会重构的，这时候得不到你想要的值，那有没有重构的函数，抱歉，没有！heapify 是私有的函数，但是你可以通过 new PriorityQueue(queue)，重新构建一个","categories":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"SparseArray 源码解析","slug":"Android/LruCache","date":"2018-07-26T02:19:16.000Z","updated":"2019-09-02T12:19:07.920Z","comments":true,"path":"2018/07/26/Android/LruCache/","link":"","permalink":"https://wzes.github.io/2018/07/26/Android/LruCache/","excerpt":"","text":"LruCache 是什么东西？ LRU 咋一看这么熟悉，操作系统里面内存管理，页面置换时替换算法之一，英文全拼为Least Recently Used 以为最近最少使用，简单来说，就是替换掉最老的数据。其核心思想为如果数据最近被访问过，那么将来被访问的几率也更高。另外一个比较简单的算法是 FIFO，First In First Out 先进先出，就是淘汰最先使用的，也就是说留下最近使用的，看似这两个很像，实际上区别还是很大的，当缓存命中时，LRU会将元素移到队首，而FIFO不会变 我觉得这是对于 LRU 和 FIFO 比较正确的定义，就实现方式来说，FIFO 相对简单些 前世今生 12// 很干净，没有父类（Object 除外）public class LruCache&lt;K, V&gt; &#123;&#125; 使用场景 主要是用于缓存数据的场景，节约内存，比如图片的缓存 实现原理大白话 他的实现还是很简单，很清晰的，使用一个 LinkedHashMap 作为数据存储结构，你使用这个东西的时候可以当一个 Key-Value 内存数据库使用。只不过，它主要是为了缓存，当数据量达到阈值值，会根据LRU删除数据，那有的同学可能会问，为什么要删啊？其实这就是使用它原因，删掉一部分可能不使用的数据，节约出宝贵的内存，要是你不管内存的话，那就另当别论了 存储数据格式 12head -&gt; node -&gt; node -&gt; node -&gt; node -&gt; node -&gt; tailnode = &lt;Key, Value&gt; 源码分析 属性 1234567891011121314151617181920// 数据存储private final LinkedHashMap&lt;K, V&gt; map;/** Size of this cache in units. Not necessarily the number of elements. */private int size;// 阈值设置，超过阈值就会抛弃private int maxSize;/** * 下面的统计数据主要是用来评估的 */// 调用 put 的次数private int putCount;// 创建 key 的次数private int createCount;// 淘汰数据 的次数private int evictionCount;// 命中的次数private int hitCount;// 未命中的次数private int missCount; 方法 构造函数 1234567891011public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;); &#125; this.maxSize = maxSize; // 在这里初始化 cache ，默认大小为 0 // true 这个很关键，代表 access-order， // true 则链表的顺序是为访问顺序，刚好符合LRU的特性 // false 则 插入顺序 this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);&#125; put 存数据 12345678910111213141516171819202122232425262728293031323334/** * Caches &#123;@code value&#125; for &#123;@code key&#125;. The value is moved to the head of * the queue. * * @return the previous value mapped by &#123;@code key&#125;. */ public final V put(K key, V value) &#123; // 注意不允许为空，HashMap 是可以允许你 Key Value 为空的 if (key == null || value == null) &#123; throw new NullPointerException(&quot;key == null || value == null&quot;); &#125; V previous; // 锁住自身的对象，线程安全 synchronized (this) &#123; putCount++; // 计算存入数据的大小 size += safeSizeOf(key, value); // 存入数据，如果 key 重复，则返回旧数据 // 具体实现可查看 HashMap 的putVal函数 previous = map.put(key, value); // 如果有旧数据，自然要更新大小 if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; // entryRemoved 空方法，可重写 if (previous != null) &#123; entryRemoved(false, key, previous, value); &#125; // 调整大小 trimToSize(maxSize); return previous;&#125; 调整大小函数 123456789101112131415161718192021222324252627282930313233343536public void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; // 对象锁 synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + &quot;.sizeOf() is reporting inconsistent results!&quot;); &#125; // 如果内存大小小于阈值，则结束循环，否则删除队首数据 if (size &lt;= maxSize) &#123; break; &#125; // remove the head // head -&gt; next -&gt; next -&gt; tail // 获取队首数据 Map.Entry&lt;K, V&gt; toEvict = map.eldest(); if (toEvict == null) &#123; break; &#125; key = toEvict.getKey(); value = toEvict.getValue(); // 删除 map.remove(key); // 减小 size -= safeSizeOf(key, value); // 擦除加1 evictionCount++; &#125; // 可重写，监听清除 entryRemoved(true, key, value, null); &#125; &#125; get 刚开始的时候你可能会困惑，说好的 lru 怎么没看到 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public final V get(K key) &#123; if (key == null) &#123; throw new NullPointerException(&quot;key == null&quot;); &#125; V mapValue; synchronized (this) &#123; // 拿到数据直接返回了 // 更换节点的工作，LinkedHashMap 帮我们做了 mapValue = map.get(key); if (mapValue != null) &#123; hitCount++; return mapValue; &#125; missCount++; &#125; /* * Attempt to create a value. This may take a long time, and the map * may be different when create() returns. If a conflicting value was * added to the map while create() was working, we leave that value in * the map and release the created value. */ // 缓存失效 // 或者不存在key，同样 create 也是空方法，使用者根据自己需求去实现 V createdValue = create(key); if (createdValue == null) &#123; return null; &#125; // 就是一个 put 操作 synchronized (this) &#123; createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) &#123; // There was a conflict so undo that last put map.put(key, mapValue); &#125; else &#123; size += safeSizeOf(key, createdValue); &#125; &#125; if (mapValue != null) &#123; entryRemoved(false, key, createdValue, mapValue); return mapValue; &#125; else &#123; trimToSize(maxSize); return createdValue; &#125; &#125; 看完这几个函数，大概知道了原理 再来看一个非常重要的函数，内存大小的计算，通常也是需要使用者自己重写 1234567891011121314151617181920private int safeSizeOf(K key, V value) &#123; int result = sizeOf(key, value); if (result &lt; 0) &#123; throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value); &#125; return result;&#125;/** * Returns the size of the entry for &#123;@code key&#125; and &#123;@code value&#125; in * user-defined units. The default implementation returns 1 so that size * is the number of entries and max size is the maximum number of entries. * * &lt;p&gt;An entry&apos;s size must not change while it is in the cache. */// 子类可重写，默认返回1，根据使用情况自己计算// 扯一句，关于 Java 对象在内存的大小如何计算，请自行去查找protected int sizeOf(K key, V value) &#123; return 1;&#125; 总结 HashMap 是个很重要的东西，下一次我们在慢慢分析 今天跟大家分享了一个很简单的数据结构，也是你可以效仿的对象，还是那句，Read the fucking source code 纯属个人观点，如果有错，欢迎指正。","categories":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/categories/Android/"},{"name":"Java","slug":"Android/Java","permalink":"https://wzes.github.io/categories/Android/Java/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"SparseArray 源码解析","slug":"Android/SparseArray","date":"2018-07-26T02:19:16.000Z","updated":"2019-09-02T12:19:23.678Z","comments":true,"path":"2018/07/26/Android/SparseArray/","link":"","permalink":"https://wzes.github.io/2018/07/26/Android/SparseArray/","excerpt":"","text":"是什么东西？ sparse 是稀疏的意思，顾名思义，是一个稀疏数组，但实际上，他是一个key 只能为 int 的key-value 的数据结构，类似于HashMap Android Developer 中对它的解释 SparseArrays map integers to Objects. Unlike a normal array of Objects, there can be gaps in the indices. It is intended to be more memory efficient than using a HashMap to map Integers to Objects, both because it avoids auto-boxing keys and its data structure doesn’t rely on an extra entry object for each mapping. Note that this container keeps its mappings in an array data structure, using a binary search to find keys. The implementation is not intended to be appropriate for data structures that may contain large numbers of items. It is generally slower than a traditional HashMap, since lookups require a binary search and adds and removes require inserting and deleting entries in the array. For containers holding up to hundreds of items, the performance difference is not significant, less than 50%. To help with performance, the container includes an optimization when removing keys: instead of compacting its array immediately, it leaves the removed entry marked as deleted. The entry can then be re-used for the same key, or compacted later in a single garbage collection step of all removed entries. This garbage collection will need to be performed at any time the array needs to be grown or the the map size or entry values are retrieved. It is possible to iterate over the items in this container using keyAt(int) and valueAt(int). Iterating over the keys using keyAt(int) with ascending values of the index will return the keys in ascending order, or the values corresponding to the keys in ascending order in the case of valueAt(int). 为什么要使用它？ 一句话：内存效率更高。他避免了Integer 的自动拆装箱，会自动压缩数组或者扩容，没有使用 entry 的数据结构 性能呢？ 通常来说，要比 HashMap 慢，但数据量小于100时，性能下降少于50%，为什么慢这么多？因为二分搜索，其次，插入删除，数组需要压缩或者扩容，导致比较慢。对此，有一个删除时的优化，删除时不立即压缩数组，而是需要在需要增长数组或检索映射大小或条目值的任何时候执行此垃圾收集 怎么设计的？ 其实，首页说的基本原理很清楚，它将映射关系保留在数组数据结构中，使用二分搜索来查找键， 适合什么场景？ key 为 int 的HashMap场景 源码分析 属性 12345678910// 删除后将value[index] = DELETED；等待 gcprivate static final Object DELETED = new Object();// 标记是否需要 gc (不是jvm的gc，而是数组内部自定义的gc，压缩数组)private boolean mGarbage = false;// 存放 key 集合private int[] mKeys;// 存放value 集合private Object[] mValues;// 集合中存在的未被删除元素的个数private int mSize; 方法 获取值get 使用二分搜索找到mValues 中的位置， 如果搜索不到则返回空 123456789101112131415/** * Gets the Object mapped from the specified key, or the specified Object * if no such mapping has been made. */@SuppressWarnings(&quot;unchecked&quot;)public E get(int key, E valueIfKeyNotFound) &#123; // 使用二分搜索找到mValues 中的位置 int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &lt; 0 || mValues[i] == DELETED) &#123; return valueIfKeyNotFound; &#125; else &#123; return (E) mValues[i]; &#125;&#125; 二分搜索的实现，使用位运算提高效率，无符号右移（注意&gt;&gt; 和 &gt;&gt;&gt; 的区别） 123456789101112131415161718192021// This is Arrays.binarySearch(), but doesn&apos;t do any argument validation.static int binarySearch(int[] array, int size, int value) &#123; int lo = 0; int hi = size - 1; while (lo &lt;= hi) &#123; // 使用位运算提高效率，无符号右移（注意&gt;&gt; 和 &gt;&gt;&gt; 的区别） final int mid = (lo + hi) &gt;&gt;&gt; 1; final int midVal = array[mid]; if (midVal &lt; value) &#123; lo = mid + 1; &#125; else if (midVal &gt; value) &#123; hi = mid - 1; &#125; else &#123; return mid; // value found &#125; &#125; // 巧妙的返回找不到的位置，去反一般小于0, return ~lo; // value not present&#125; 什么地方进行 gc？ get remove 操作不进行gc put size() keyAt valueAt 会检查 mGarbage 的标志进行 gc gc 传说中的gc函数 123456789101112131415161718192021222324252627private void gc() &#123; // Log.e(&quot;SparseArray&quot;, &quot;gc start with &quot; + mSize); int n = mSize; int o = 0; int[] keys = mKeys; Object[] values = mValues; // 遍历将值为DELETED的位置删除 for (int i = 0; i &lt; n; i++) &#123; Object val = values[i]; if (val != DELETED) &#123; if (i != o) &#123; keys[o] = keys[i]; values[o] = val; values[i] = null; &#125; o++; &#125; &#125; // 更改 size 的大小，但keys 的大小没有变 mGarbage = false; mSize = o; // Log.e(&quot;SparseArray&quot;, &quot;gc end with &quot; + mSize);&#125; put 函数，优先在 DELETE 位置插入，插入后在检查是否需要 GC 12345678910111213141516171819202122232425262728293031/** * Adds a mapping from the specified key to the specified value, * replacing the previous mapping from the specified key if there * was one. */ public void put(int key, E value) &#123; int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &gt;= 0) &#123; mValues[i] = value; &#125; else &#123; i = ~i; if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123; mKeys[i] = key; mValues[i] = value; return; &#125; // 是否需要 gc if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123; gc(); // Search again because indices may have changed. i = ~ContainerHelpers.binarySearch(mKeys, mSize, key); &#125; // 插入，扩容 mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key); mValues = GrowingArrayUtils.insert(mValues, mSize, i, value); mSize++; &#125; &#125; GrowingArrayUtils.insert 插入以及扩容 1234567891011121314151617181920/** * Primitive boolean version of &#123;@link #insert(Object[], int, int, Object)&#125;. */public static boolean[] insert(boolean[] array, int currentSize, int index, boolean element) &#123; assert currentSize &lt;= array.length; // 普通情况 if (currentSize + 1 &lt;= array.length) &#123; System.arraycopy(array, index, array, index + 1, currentSize - index); array[index] = element; return array; &#125; // currentSize = array.length 的情况，进行扩容 boolean[] newArray = ArrayUtils.newUnpaddedBooleanArray(growSize(currentSize)); // 数组的复制都使用 System.arraycopy，效率高 System.arraycopy(array, 0, newArray, 0, index); newArray[index] = element; System.arraycopy(array, index, newArray, index + 1, array.length - index); return newArray;&#125; growSize增长函数，小于 4 时直接增到 8， 之后以2的位数增长，这与很多增长函数差不多，只不过在这没有用位运算有点遗憾 123456789/** * Given the current size of an array, returns an ideal size to which the array should grow. * This is typically double the given size, but should not be relied upon to do so in the * future. */public static int growSize(int currentSize) &#123; // 增长函数 return currentSize &lt;= 4 ? 8 : currentSize * 2;&#125; 以上这几个都是很经典的函数以及实现，需要掌握！ 总结 Android 源码中对 SparseArray 应用还是比较多的，可能是想解决由于早期 Android 内存小的问题，但在日益低廉的内存面前，是否还有必要使用，提高内存效率还是得打一个问号。 欢迎讨论～","categories":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/categories/Android/"},{"name":"Java","slug":"Android/Java","permalink":"https://wzes.github.io/categories/Android/Java/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"https://wzes.github.io/tags/Java/"}]},{"title":"Android Repositories","slug":"Android/Android-repositories","date":"2018-07-05T12:35:00.000Z","updated":"2019-09-02T12:18:04.105Z","comments":true,"path":"2018/07/05/Android/Android-repositories/","link":"","permalink":"https://wzes.github.io/2018/07/05/Android/Android-repositories/","excerpt":"","text":"Android Repositories 众所周知啊，Android 的仓库源 google jcenter 国内是超级慢的，换个 aliyun 起飞了 123456789101112131415mavenCentral()maven &#123; url &quot;[https://jitpack.io](https://jitpack.io)&quot; &#125;maven &#123; url &quot;[http://maven.aliyun.com/nexus/content/groups/public/](http://maven.aliyun.com/nexus/content/groups/public/)&quot; &#125;maven &#123; url &apos;[http://maven.oschina.net/content/groups/public/&apos;](http://maven.oschina.net/content/groups/public/&apos;) &#125;maven &#123; url &apos;[https://oss.sonatype.org/content/repositories/snapshots/&apos;](https://oss.sonatype.org/content/repositories/snapshots/&apos;) &#125;maven &#123; url &quot;[http://maven.springframework.org/release](http://maven.springframework.org/release)&quot; &#125;maven &#123; url &quot;[http://maven.restlet.org](http://maven.restlet.org)&quot; &#125;maven &#123; url &quot;[http://mirrors.ibiblio.org/maven2](http://mirrors.ibiblio.org/maven2)&quot; &#125;maven &#123;url &quot;[http://repo.baichuan-android.taobao.com/content/groups/BaichuanRepositories/](http://repo.baichuan-android.taobao.com/content/groups/BaichuanRepositories/)&quot;&#125;maven &#123; url &apos;[https://maven.fabric.io/public&apos;](https://maven.fabric.io/public&apos;) &#125;jcenter()google()jcenter &#123; url &quot;[http://jcenter.bintray.com/](http://jcenter.bintray.com/)&quot; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://wzes.github.io/tags/Android/"}]},{"title":"MySQL 导入大文本数据历险记","slug":"MySQL/MySQL 导入大文本数据历险记","date":"2018-06-10T12:57:00.000Z","updated":"2019-09-01T15:25:33.204Z","comments":true,"path":"2018/06/10/MySQL/MySQL 导入大文本数据历险记/","link":"","permalink":"https://wzes.github.io/2018/06/10/MySQL/MySQL 导入大文本数据历险记/","excerpt":"背景 今天接到一个任务，往一张 mysql 数据库表里导入一点文本数据，压缩文件在百度云上，一看 2 G 大小，百度云还各种限速，直接不想下载了，项目小姐姐问遇到啥问题？我更她说，下载困难，估计当时她哭笑不得，没办，最终还是得开工，直接拿 u盘 copy 的。","text":"背景 今天接到一个任务，往一张 mysql 数据库表里导入一点文本数据，压缩文件在百度云上，一看 2 G 大小，百度云还各种限速，直接不想下载了，项目小姐姐问遇到啥问题？我更她说，下载困难，估计当时她哭笑不得，没办，最终还是得开工，直接拿 u盘 copy 的。 问题 废了几分钟才 copy 完，解压后 13.9G，挂不得她们都不知道里面装的是啥，然而难不倒我，linux 系统可谓是编程利器。 检查 csv 文件行数 1wc -l filename 半天没跑出来，等不及，直接又上了另外一个命令 12head -n filenametail -n filename 看了一下时间跨度，最终选定最后一天的数据进行导入，那就得锁定最后一天是从第几行开始的，一路tail -n filename 试出来了的，接下来就是把这部分数据截取到新文件 1tail -n filename &gt; new_file.csv 新文件只剩 1 个 G 了，突然想起还有字符编码的问题，我数据库用的是 utf-8，而 windows 平台的数据一般是 GBK 格式，一波百度后找到了 iconv 命令，一行命令就解决了，速度贼快，以后妈妈再也不用担心我的字符编码问题了 1iconv -f GBK -t UTF-8 input_file -o output_file 然而开始要上传到服务器，阿里云的服务器上传数据也是需要一点时间。突然想，把文件切分一下吧，分批，或者开几个线程一起上传，又一波百度，发现了 split， 按行切分或者按大小切分 12split -l 1000000 filenamesplit -C 100M filename 然后愉快的先上传了一个小块到了服务器，打开 mysql，找到 load data 的命令，当然一开始不会那么成功，各种问题都会出现 双引号问题，默认会把双引号当做字段内容填充，就导致非 字符类型的数据不能导入 字符问题，utf-8 还要再重新指定，即使我的数据本来就是 utf-8 字段对应问题，插入的表很多字段都只能为空 更奇怪的是每次只成功了一半，还发现了 show warnings 可以查看警告信息，最后发现时 access 导出数据时是使用 \\t 分割行的，orz 1show warnings 最后附上成功导入的脚本 123456LOAD DATA LOCAL INFILE &quot;filename&quot; INTO TABLE tablename CHARACTER SET utf8 FIELDS TERMINATED BY &apos;,&apos; ENCLOSED BY &quot;&quot;&quot;&quot; LINES TERMINATED BY &apos;\\r&apos; (COLUMN1, COLUMN2, ......); 测试成功后，将切割的数据合并 1cat x* &gt; file 再执行命令，大功告成！！ 总结 敲命令还是很有成就感的，有时候要比使用某些软件效率要高，至少大多数软件对大文件读取都没有做优化，这对于经常接触大文件的人简直是噩梦！！atom 打开几M的数据都卡，替换更卡！果然使用 vim 替换功能，但是 vim 也不发操控大文件（几个G以上），当然我们可以写个脚本，可以将文件切割，逐一对文件进行操作！也不是不行！","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://wzes.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://wzes.github.io/tags/MySQL/"}]}]}